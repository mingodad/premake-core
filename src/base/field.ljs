//-
// base/field.ljs
//
// Fields hold a particular bit of information about a configuration, such
// as the language of a project or the list of files it uses. Each field has
// a particular data "kind", which describes the structure of the information
// it holds, such a simple string, or a list of paths.
//
// The field.* functions here manage the definition of these fields, and the
// accessor functions required to get, set, remove, and merge their values.
//
// Copyright (c) 2014 Jason Perkins and the Premake project
//-

	var p = premake;
	p.field = {};
	var field = p.field;


// Lists to hold all of the registered fields and data kinds

	field._list = {};
	field._loweredList = {};
	field._sortedList = null;
	field._kinds = {};

	// For historical reasons
	premake.fields = field._list;

// A cache for data kind accessor functions

	field._accessors = {};


//-
// Register a new field.
//
// @param f
//    A table describing the new field, with these keys:
//     name     A unique string name for the field, to be used to identify
//              the field in future operations.
//     kind     The kind of values that can be stored into this field. Kinds
//              can be chained together to create more complex types, such as
//              "list:string".
//
//    In addition, any custom keys set on the field description will be
//    maintained.
//
// @return
//    A populated field object. Or nil and an error message if the field could
//    not be registered.
//-

	function field.new(f) {
		// Translate the old approaches to data kind definitions to the new
		// one used here. These should probably be deprecated eventually.

		if( f.kind->startswith("key-") ) {
			f.kind = f.kind->sub(5);
			f.keyed = true;
		}

		if( f.kind->endswith("-list") ) {
			f.kind = f.kind->sub(1, -6);
			f.list = true;
		}

		var kind = f.kind;

		if( kind == "object" || kind == "array" ) {
			kind = "table";
		}

		if( f.list ) {
			kind = "list:" .. kind;
		}

		if( f.keyed ) {
			kind = "keyed:" .. kind;
		}

		// Store the translated kind with a new name, so legacy add-on code
		// can continue to work with the old value.

		f._kind = kind;

		// Make sure scope is always an array; don't overwrite old value
		if( type(f.scope) == "table" ) {
			f.scopes = f.scope;
		} else {
			f.scopes = { f.scope };
		}

		// All fields must have a valid store() function
		if( ! field.accessor(f, "store") ) {
			return null, "invalid field kind '" .. f._kind .. "'";
		}

		field._list[f.name] = f;
		field._loweredList[f.name->lower()] = f;
		field._sortedList = null;

		return f;
	}



//-
// Remove a previously created field definition.
//-

	function field.unregister(f) {
		field._list[f.name] = null;
		field._loweredList[f.name->lower()] = null;
		field._sortedList = null;
	}



//-
// Returns an iterator for the list of registered fields; the
// ordering of returned results is arbitrary.
//-

	function field.each() {
		var index;
		return function () {
			index = next(field._list, index);
			return field._list[index];
		};
	}



//-
// Returns an iterator for the list of registered fields; the
// results are in a prioritized order, then alphabetized.
//-

	function field.eachOrdered() {
		if( ! field._sortedList ) {
			// no priorities yet, just alpha sort
			var keys = table.keys(field._list);
			table.sort(keys);

			field._sortedList = {};
			for( i = 1, #keys ) {
				field._sortedList[i] = field._list[keys[i]];
			}
		}

		var i = 0;
		return function () {
			++i    ;
			return field._sortedList[i];
		};
	}


//-
// Register a new kind of data for field storage.
//
// @param tag
//    A unique name of the kind; used in the kind string in new field
//    definitions (see new(), above).
// @param settings
//    A table containing the processor functions for the new kind. If
//    nil, no change is made to the current field settings.
// @return
//    The settings table for the specified tag.
//-

	function field.kind(tag, settings) {
		if( settings ) {
			field._kinds[tag] = settings;
		}
		return field._kinds[tag];
	}



//-
// Build an "accessor" function to process incoming values for a field. This
// function should be an interview question.
//
// An accessor function takes the form of:
//
//    function (field, current, value, nextAccessor)
//
// It receives the target field, the current value of that field, and the new
// value that has been provided by the project script. It then returns the
// new value for the target field.
//
// @param f
//    The field for which an accessor should be returned.
// @param method
//    The type of accessor function required; currently this should be one of
//    "store", "remove", or "merge" though it is possible for add-on modules to
//    extend the available methods by implementing appropriate processing
//    functions.
// @return
//    An accessor function for the field's kind and method. May return nil
//    if no processing functions are available for the given method.
//-


	function field.accessor(f, method) {
		// Prepare a cache for accessors using this method; each encountered
		// kind only needs to be fully processed once.

		field._accessors[method] = field._accessors[method] || {};
		var cache = field._accessors[method];

		// Helper function recurses over each piece of the field's data kind,
		// building an accessor function for each sequence encountered. Results
		// cached from earlier calls are reused again.

		var function accessorForKind(kind) {
			// I'll end up with a kind of "" when I hit the end of the string
			if( kind == "" ) {
				return null;
			}

			// Have I already cached a result from an earlier call?
			if( cache[kind] ) {
				return cache[kind];
			}

			// Split off the first piece from the rest of the kind. If the
			// incoming kind is "list:key:string", thisKind will be "list"
			// and nextKind will be "key:string".

			var thisKind = kind->match('(.-):') || kind;
			var nextKind = kind->sub(#thisKind + 2);

			// Get the processor function for this kind. Processors perform
			// data validation and storage appropriate for the data structure.

			var functions = field._kinds[thisKind];
			if( ! functions ) {
				return null, "Invalid field kind '" .. thisKind .. "'";
			}

			var processor = functions[method];
			if( ! processor ) {
				return null;
			}

			// Now recurse to get the accessor function for the remaining parts
			// of the field's data kind. If the kind was "list:key:string", then
			// the processor function handles the "list" part, and this function
			// takes care of the "key:string" part.

			var nextAccessor = accessorForKind(nextKind);

			// Now here's the magic: wrap the processor and the next accessor
			// up together into a Matryoshka doll of function calls, each call
			// handling just it's level of the kind.

			accessor = function(f, current, value) {
				return processor(f, current, value, nextAccessor);
			};

			// And cache the result so I don't have to go through that again
			cache[kind] = accessor;
			return accessor;
		}

		return accessorForKind(f._kind);
	}



	function field.compare(f, a, b) {
		var processor = field.accessor(f, "compare");
		if( processor ) {
			return processor(f, a, b);
		} else {
			return (a == b);
		}
	}



//-
// Fetch a field description by name.
//-

	function field.get(name) {
		return field._list[name] || field._loweredList[name->lower()];
	}



	function field.merge(f, current, value) {
		var processor = field.accessor(f, "merge");
		if( processor ) {
			return processor(f, current, value);
		} else {
			return value;
		}
	}


//-
// Is this a field that supports merging values together? Non-merging fields
// can simply overwrite their values, merging fields can call merge() to
// combine two values together.
//-

	function field.merges(f) {
		return (field.accessor(f, "merge") != null);
	}



//-
// Retrieve a property from a field, based on it's data kind. Allows extra
// information to be stored along with the data kind definitions; use this
// call to find the first value in the field's data kind chain.
//-

	function field.property(f, tag) {
		var kinds = string.explode(f._kind, ":", true);
		for( i, kind in ipairs(kinds) ) {
			var value = field._kinds[kind][tag];
			if( value != null ) {
				return value;
			}
		}
	}




//-
// Override one of the field kind accessor functions. This works just like
// p.override(), but applies the new function to the internal field
// description and clears the accessor caches to make sure the change gets
// picked up by future operations.
//-

	function field.override(fieldName, accessorName, func) {
		var kind = field.kind(fieldName);
		p.override(kind, accessorName, func);
		field._accessors = {};
	}


	function field.remove(f, current, value) {
		var processor = field.accessor(f, "remove");
		if( processor ) {
			return processor(f, current, value);
		} else {
			return value;
		}
	}



	function field.removes(f) {
		return (field.accessor(f, "merge") != null && field.accessor(f, "remove") != null);
	}



	function field.store(f, current, value) {
		var processor = field.accessor(f, "store");
		if( processor ) {
			return processor(f, current, value);
		} else {
			return value;
		}
	}



	function field.translate(f, value) {
		var processor = field.accessor(f, "translate");
		if( processor ) {
			return processor(f, value, null)[1];
		} else {
			return value;
		}
	}


	function field.translates(f) {
		return (field.accessor(f, "translate") != null);
	}

