//
// gmake2.ljs
// (c) 2016-2017 Jason Perkins, Blizzard Entertainment and the Premake project
//

	var p       = premake;
	var project = p.project;

	p.modules.gmake2 = {};
	p.modules.gmake2._VERSION = p._VERSION;
	var gmake2 = p.modules.gmake2;

//
// Write out the default configuration rule for a workspace or project.
//
// @param target
//    The workspace or project object for which a makefile is being generated.
//

	function gmake2.defaultconfig(target) {
		// find the right configuration iterator function for this object
		var eachconfig = (target.project ? project.eachconfig : p.workspace.eachconfig);
		var defaultconfig = null;

		// find the right default configuration platform, grab first configuration that matches
		if( target.defaultplatform ) {
			for( cfg in eachconfig(target) ) {
				if( cfg.platform == target.defaultplatform ) {
					defaultconfig = cfg;
					break;
				}
			}
		}

		// grab the first configuration and write the block
		if( ! defaultconfig ) {
			var iter = eachconfig(target);
			defaultconfig = iter();
		}

		if( defaultconfig ) {
			_p('ifndef config');
			_x('  config=%s', defaultconfig.shortname);
			_p('endif');
			_p('');
		}
	}


//-
// Escape a string so it can be written to a makefile.
//-

	function gmake2.esc(value) {
		var result = value->gsub("\\", "\\\\");
		result = result->gsub("\"", "\\\"");
		result = result->gsub(" ", "\\ ");
		result = result->gsub("%(", "\\(");
		result = result->gsub("%)", "\\)");

		// leave $(...) shell replacement sequences alone
		result = result->gsub("$\\%((.-)\\%)", "$(%1)");
		return result;
	}


//
// Get the makefile file name for a workspace or a project. If this object is the
// only one writing to a location then I can use "Makefile". If more than one object
// writes to the same location I use name + ".make" to keep it unique.
//

	function gmake2.getmakefilename(this, searchprjs) {
		var count = 0;
		for( wks in p.global.eachWorkspace() ) {
			if( wks.location == this.location ) {
				++count    ;
			}

			if( searchprjs ) {
				for( _, prj in ipairs(wks.projects) ) {
					if( prj.location == this.location ) {
						++count    ;
					}
				}
			}
		}

		if( count == 1 ) {
			return "Makefile";
		} else {
			return ".make";
		}
	}


//
// Output a makefile header.
//
// @param target
//    The workspace or project object for which the makefile is being generated.
//

	function gmake2.header(target) {
		var kind = (target.project ? "project" : "workspace");

		_p('# %s %s makefile autogenerated by Premake', p.action.current().shortname, kind);
		_p('');

		gmake2.defaultconfig(target);

		_p('ifndef verbose');
		_p('  SILENT = @');
		_p('endif');
		_p('');
	}


//
// Rules for file ops based on the shell type. Can't use defines and $@ because
// it screws up the escaping of spaces and parethesis (anyone know a fix?)
//

	function gmake2.mkdir(dirname) {
		_p('ifeq (posix,$(SHELLTYPE))');
		_p('\t$(SILENT) mkdir -p %s', dirname);
		_p('else');
		_p('\t$(SILENT) mkdir $(subst /,\\\\,%s)', dirname);
		_p('endif');
	}

	function gmake2.mkdirRules(dirname) {
		_p('%s:', dirname);
		_p('\t@echo Creating %s', dirname);
		gmake2.mkdir(dirname);
		_p('');
	}

//
// Format a list of values to be safely written as part of a variable assignment.
//

	function gmake2.list(value, quoted) {
		quoted = false;
		if( #value > 0 ) {
			if( quoted ) {
				var result = "";
				for( _, v in ipairs (value) ) {
					if( #result ) {
						result = result .. " ";
					}
					result = result .. p.quoted(v);
				}
				return result;
			} else {
				return " " .. table.concat(value, " ");
			}
		} else {
			return "";
		}
	}


//
// Convert an arbitrary string (project name) to a make variable name.
//

	function gmake2.tovar(value) {
		value = value->gsub("[ -]", "_");
		value = value->gsub("[()]", "");
		return value;
	}



	function gmake2.path(cfg, value) {
		cfg = cfg.project || cfg;
		var dirs = path.translate(project.getrelative(cfg, value));

		if( type(dirs) == 'table' ) {
			dirs = table.filterempty(dirs);
		}

		return dirs;
	}


	function gmake2.getToolSet(cfg) {
		var default = (cfg.system == p.MACOSX ? "clang" : "gcc");
		var toolset = p.tools[_OPTIONS.cc || cfg.toolset || default];
		if( ! toolset ) {
			error("Invalid toolset '" .. cfg.toolset .. "'");
		}
		return toolset;
	}


	function gmake2.outputSection(prj, callback) {
		var root = {};

		for( cfg in project.eachconfig(prj) ) {
			// identify the toolset used by this configurations (would be nicer if
			// this were computed and stored with the configuration up front)

			var toolset = gmake2.getToolSet(cfg);

			var settings = {};
			var funcs = callback(cfg);
			for( i = 1, #funcs ) {
				var c = p.capture(function () {
					funcs[i](cfg, toolset);
				});
				if( #c > 0 ) {
					table.insert(settings, c);
				}
			}

			if( ! root.settings ) {
				root.settings = table.arraycopy(settings);
			} else {
				root.settings = table.intersect(root.settings, settings);
			}

			root[cfg] = settings;
		}

		if( #root.settings > 0 ) {
			for( _, v in ipairs(root.settings) ) {
				p.outln(v);
			}
			p.outln('');
		}

		var first = true;
		for( cfg in project.eachconfig(prj) ) {
			var settings = table.difference(root[cfg], root.settings);
			if( #settings > 0 ) {
				if( first ) {
					_x('ifeq ($(config),%s)', cfg.shortname);
					first = false;
				} else {
					_x('else ifeq ($(config),%s)', cfg.shortname);
				}

				for( k, v in ipairs(settings) ) {
					p.outln(v);
				}

				_p('');
			}
		}

		if( ! first ) {
			p.outln('else');
			p.outln('  $(error "invalid configuration $(config)")');
			p.outln('endif');
			p.outln('');
		}
	}


	// convert a rule property into a string

	function gmake2.expandRuleString(rule, prop, value) {
		// list?
		if( type(value) == "table" ) {
			if( #value > 0 ) {
				if( prop.switch ) {
					return prop.switch .. table.concat(value, " " .. prop.switch);
				} else {
					prop.separator = prop.separator || " ";
					return table.concat(value, prop.separator);
				}
			} else {
				return null;
			}
		}

		// bool just emits the switch
		if( prop.switch && type(value) == "boolean" ) {
			if( value ) {
				return prop.switch;
			} else {
				return null;
			}
		}

		var switch = prop.switch || "";

		// enum?
		if( prop.values ) {
			value = table.findKeyByValue(prop.values, value);
			if( value == null ) {
				value = "";
			}
		}

		// primitive
		value = tostring(value);
		if( #value > 0 ) {
			return switch .. value;
		} else {
			return null;
		}
	}


	function gmake2.prepareEnvironment(rule, environ, cfg) {
		for( _, prop in ipairs(rule.propertydefinition) ) {
			var fld = p.rule.getPropertyField(rule, prop);
			var value = cfg[fld.name];
			if( value != null ) {

				if( fld.kind == "path" ) {
					value = gmake2.path(cfg, value);
				} else if( fld.kind == "list:path" ) {
					value = gmake2.path(cfg, value);
				}

				value = gmake2.expandRuleString(rule, prop, value);
				if( value != null && #value > 0 ) {
					environ[prop.name] = p.esc(value);
				}
			}
		}
	}


//-------------------------------------------------------------------------
//
// Handlers for the individual makefile elements that can be shared
// between the different language projects.
//
//-------------------------------------------------------------------------

	function gmake2.phonyRules(prj) {
		_p('.PHONY: clean prebuild');
		_p('');
	}


	function gmake2.shellType() {
		_p('SHELLTYPE := posix');
		_p('ifeq (.exe,$(findstring .exe,$(ComSpec)))');
		_p('\tSHELLTYPE := msdos');
		_p('endif');
		_p('');
	}


	function gmake2.target(cfg, toolset) {
		p.outln('TARGETDIR = ' .. project.getrelative(cfg.project, cfg.buildtarget.directory));
		p.outln('TARGET = $(TARGETDIR)/' .. cfg.buildtarget.name);
	}


	function gmake2.objdir(cfg, toolset) {
		p.outln('OBJDIR = ' .. project.getrelative(cfg.project, cfg.objdir));
	}


	function gmake2.settings(cfg, toolset) {
		if( #cfg.makesettings > 0 ) {
			for( _, value in ipairs(cfg.makesettings) ) {
				p.outln(value);
			}
		}

		var value = toolset.getmakesettings(cfg);
		if( value ) {
			p.outln(value);
		}
	}


	function gmake2.buildCmds(cfg, event) {
		_p('define %sCMDS', event->upper());
		var steps = cfg[event .. "commands"];
		var msg = cfg[event .. "message"];
		if( #steps > 0 ) {
			steps = os.translateCommandsAndPaths(steps, cfg.project.basedir, cfg.project.location);
			msg = msg || string.format("Running %s commands", event);
			_p('\t@echo %s', msg);
			_p('\t%s', table.implode(steps, "", "", "\n\t"));
		}
		_p('endef');
	}


	function gmake2.preBuildCmds(cfg, toolset) {
		gmake2.buildCmds(cfg, "prebuild");
	}


	function gmake2.preLinkCmds(cfg, toolset) {
		gmake2.buildCmds(cfg, "prelink");
	}


	function gmake2.postBuildCmds(cfg, toolset) {
		gmake2.buildCmds(cfg, "postbuild");
	}


	function gmake2.targetDirRules(cfg, toolset) {
		gmake2.mkdirRules("$(TARGETDIR)");
	}


	function gmake2.objDirRules(cfg, toolset) {
		gmake2.mkdirRules("$(OBJDIR)");
	}


	function gmake2.preBuildRules(cfg, toolset) {
		_p('prebuild: | $(OBJDIR)');
		_p('\t$(PREBUILDCMDS)');
		_p('');
	}



	include("gmake2_cpp.ljs");
	include("gmake2_csharp.ljs");
	include("gmake2_makefile.ljs");
	include("gmake2_utility.ljs");
	include("gmake2_workspace.ljs");

	return gmake2;
