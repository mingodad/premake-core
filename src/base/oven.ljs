//
// base/oven.ljs
//
// Process the workspaces, projects, and configurations that were specified
// by the project script, and make them suitable for use by the exporters
// and actions. Fills in computed values (e.g. object directories) and
// optimizes the layout of the data for faster fetches.
//
// Copyright (c) 2002-2014 Jason Perkins and the Premake project
//

	var p = premake;

	p.oven = {};

	var oven = p.oven;
	var context = p.context;


//
// These fields get special treatment, "bubbling up" from the configurations
// to the project. This allows you to express, for example: "use this config
// map if this configuration is present in the project", and saves the step
// of clearing the current configuration filter before creating the map.
//

	p.oven.bubbledFields = {
		configmap = true,
		vpaths = true
	};



//-
// Traverses the container hierarchy built up by the project scripts and
// filters, merges, and munges the information based on the current runtime
// environment in preparation for doing work on the results, like exporting
// project files.
//
// This call replaces the existing the container objects with their
// processed replacements. If you are using the provided container APIs
// (p.global.*, p.workspace.*, etc.) this will be transparent.
//-

	function oven.bake() {
		// reset the root _isBaked state.
		// this really only affects the unit-tests, since that is the only place
		// where multiple bakes per 'exe run' happen.
		var root = p.api.rootContainer();
		root._isBaked = false;

		p.container.bake(root);
	}

	function oven.bakeWorkspace(wks) {
		return p.container.bake(wks);
	}

	p.alias(oven, "bakeWorkspace", "bakeSolution");


	var function addCommonContextFilters(this) {
		context.addFilter(this, "_ACTION", _ACTION);
		context.addFilter(this, "action", _ACTION);

		this.system = this.system || os.target();
		context.addFilter(this, "system", os.getSystemTags(this.system));
		context.addFilter(this, "host", os.getSystemTags(os.host()));

		// Add command line options to the filtering options
		var options = {};
		for( key, value in pairs(_OPTIONS) ) {
			var term = key;
			if( value != "" ) {
				term = term .. "=" .. tostring(value);
			}
			table.insert(options, term);
		}
		context.addFilter(this, "_OPTIONS", options);
		context.addFilter(this, "options", options);
	}

//-
// Bakes a specific workspace object.
//-

	function p.workspace.bake(this) {
		// Add filtering terms to the context and then compile the results. These
		// terms describe the "operating environment"; only results contained by
		// configuration blocks which match these terms will be returned.

		addCommonContextFilters(this);

		// Set up my token expansion environment

		this.environ = {
			wks = this,
			sln = this,
		};

		context.compile(this);

		// Specify the workspaces's file system location; when path tokens are
		// expanded in workspace values, they will be made relative to this.

		this.location = this.location || this.basedir;
		context.basedir(this, this.location);

		// Build a master list of configuration/platform pairs from all of the
		// projects contained by the workspace; I will need this when generating
		// workspace files in order to provide a map from workspace configurations
		// to project configurations.

		this.configs = oven.bakeConfigs(this);

		// Now bake down all of the projects contained in the workspace, and
		// store that for future reference

		p.container.bakeChildren(this);

		// I now have enough information to assign unique object directories
		// to each project configuration in the workspace.

		oven.bakeObjDirs(this);

		// now we can post process the projects for 'buildoutputs' files
		// that have the 'compilebuildoutputs' flag
		oven.addGeneratedFiles(this);
	}


	function oven.addGeneratedFiles(wks) {

		var function addGeneratedFile(cfg, source, filename) {
			// mark that we have generated files.
			cfg.project.hasGeneratedFiles = true;

			// add generated file to the project.
			var files = cfg.project._.files;
			var node = files[filename];
			if( ! node ) {
				node = p.fileconfig.new(filename, cfg.project);
				files[filename] = node;
				table.insert(files, node);
			}

			// always overwrite the dependency information.
			node.dependsOn = source;
			node.generated = true;

			// add to config if not already added.
			if( ! p.fileconfig.getconfig(node, cfg) ) {
				p.fileconfig.addconfig(node, cfg);
			}
		}

		var function addFile(cfg, node) {
			var filecfg = p.fileconfig.getconfig(node, cfg);
			if( ! filecfg || filecfg.flags.ExcludeFromBuild || ! filecfg.compilebuildoutputs ) {
				return;
			}

			if( p.fileconfig.hasCustomBuildRule(filecfg) ) {
				var buildoutputs = filecfg.buildoutputs;
				if( buildoutputs && #buildoutputs > 0 ) {
					for( _, output in ipairs(buildoutputs) ) {
						if( ! path.islinkable(output) ) {
							addGeneratedFile(cfg, node, output);
						}
					}
				}
			}
		}


		for( prj in p.workspace.eachproject(wks) ) {
			var files = table.shallowcopy(prj._.files);
			for( cfg in p.project.eachconfig(prj) ) {
				table.foreachi(files, function(node) {
					addFile(cfg, node);
				});
			}

			// generated files might screw up the object sequences.
			if( prj.hasGeneratedFiles && p.project.isnative(prj) ) {
				oven.assignObjectSequences(prj);
			}
		}
	}


	function p.project.bake(this) {
		verbosef('    Baking %s...', this.name);

		this.solution = this.workspace;
		this.global = this.workspace.global;

		var wks = this.workspace;

		// Add filtering terms to the context to make it as specific as I can.
		// Start with the same filtering that was applied at the workspace level.

		context.copyFilters(this, wks);

		// Now filter on the current system and architecture, allowing the
		// values that might already in the context to override my defaults.

		this.system = this.system || os.target();
		context.addFilter(this, "system", os.getSystemTags(this.system));
		context.addFilter(this, "host", os.getSystemTags(os.host()));
		context.addFilter(this, "architecture", this.architecture);
		context.addFilter(this, "tags", this.tags);

		// The kind is a configuration level value, but if it has been set at the
		// project level allow that to influence the other project-level results.

		context.addFilter(this, "kind", this.kind);

		// Allow the project object to also be treated like a configuration

		this.project = this;

		// Populate the token expansion environment

		this.environ = {
			wks = wks,
			sln = wks,
			prj = this,
		};

		// Go ahead and distill all of that down now; this is my new project object

		context.compile(this);

		p.container.bakeChildren(this);

		// Set the context's base directory to the project's file system
		// location. Any path tokens which are expanded in non-path fields
		// are made relative to this, ensuring a portable generated project.

		this.location = this.location || this.basedir;
		context.basedir(this, this.location);

		// This bit could use some work: create a canonical set of configurations
		// for the project, along with a mapping from the workspace's configurations.
		// This works, but it could probably be simplified.

		var cfgs = table.fold(this.configurations || {}, this.platforms || {});
		oven.bubbleFields(this, this, cfgs);
		this._cfglist = oven.bakeConfigList(this, cfgs);

		// Don't allow a project-level system setting to influence the configurations

		var projectSystem = this.system;
		this.system = null;

		// Finally, step through the list of configurations I built above and
		// bake all of those down into configuration contexts as well. Store
		// the results with the project.

		this.configs = {};

		for( _, pairing in ipairs(this._cfglist) ) {
			var buildcfg = pairing[1];
			var platform = pairing[2];
			var cfg = oven.bakeConfig(wks, this, buildcfg, platform);

			if( p.action.supportsconfig(p.action.current(), cfg) ) {
				this.configs[(buildcfg || "*") .. (platform || "")] = cfg;
			}
		}

		// Process the sub-objects that are contained by this project. The
		// configuration build stuff above really belongs in here now.

		this._ = {};
		this._.files = oven.bakeFiles(this);

		// If this type of project generates object files, look for files that will
		// generate object name collisions (i.e. src/hello.cpp and tests/hello.cpp
		// both create hello.o) and assign unique sequence numbers to each. I need
		// to do this up front to make sure the sequence numbers are the same for
		// all the tools, even they reorder the source file list.

		if( p.project.isnative(this) ) {
			oven.assignObjectSequences(this);
		}

		// at the end, restore the system, so it's usable elsewhere.
		this.system = projectSystem;
	}


	function p.rule.bake(this) {
		// Add filtering terms to the context and then compile the results. These
		// terms describe the "operating environment"; only results contained by
		// configuration blocks which match these terms will be returned.

		addCommonContextFilters(this);

		// Populate the token expansion environment

		this.environ = {
			rule = this,
		};

		// Go ahead and distill all of that down now; this is my new rule object

		context.compile(this);

		// sort the propertydefinition table.
		table.sort(this.propertydefinition, function (a, b) {
			return a.name < b.name;
		});

		// Set the context's base directory to the rule's file system
		// location. Any path tokens which are expanded in non-path fields
		// are made relative to this, ensuring a portable generated rule.

		this.location = this.location || this.basedir;
		context.basedir(this, this.location);
	}



//
// Assigns a unique objects directory to every configuration of every project
// in the workspace, taking any objdir settings into account, to ensure builds
// from different configurations won't step on each others' object files.
// The path is built from these choices, in order:
//
//   [1] -> the objects directory as set in the config
//   [2] -> [1] + the platform name
//   [3] -> [2] + the build configuration name
//   [4] -> [3] + the project name
//
// @param wks
//    The workspace to process. The directories are modified inline.
//

	function oven.bakeObjDirs(wks) {
		// function to compute the four options for a specific configuration
		var function getobjdirs(cfg) {
			// the "!" prefix indicates the directory is not to be touched
			var objdir = cfg.objdir || "obj";
			var i = objdir->find("!", 1, true);
			if( i ) {
				cfg.objdir = objdir->sub(1, i - 1) .. objdir->sub(i + 1);
				return null;
			}

			var dirs = {};

			var dir = path.getabsolute(path.join(cfg.project.location, objdir));
			table.insert(dirs, dir);

			if( cfg.platform ) {
				dir = path.join(dir, cfg.platform);
				table.insert(dirs, dir);
			}

			dir = path.join(dir, cfg.buildcfg);
			table.insert(dirs, dir);

			dir = path.join(dir, cfg.project.name);
			table.insert(dirs, dir);

			return dirs;
		}

		// walk all of the configs in the workspace, and count the number of
		// times each obj dir gets used
		var counts = {};
		var configs = {};

		for( prj in p.workspace.eachproject(wks) ) {
			for( cfg in p.project.eachconfig(prj) ) {
				// get the dirs for this config, and associate them together,
				// and increment a counter for each one discovered
				var dirs = getobjdirs(cfg);
				if( dirs ) {
					configs[cfg] = dirs;
					for( _, dir in ipairs(dirs || {}) ) {
						counts[dir] = (counts[dir] || 0) + 1;
					}
				}
			}
		}

		// now walk the list again, and assign the first unique value
		for( cfg, dirs in pairs(configs) ) {
			for( _, dir in ipairs(dirs) ) {
				if( counts[dir] == 1 ) {
					cfg.objdir = dir;
					break;
				}
			}
		}
	}


//
// Create a list of workspace-level build configuration/platform pairs.
//

	function oven.bakeConfigs(wks) {
		var buildcfgs = wks.configurations || {};
		var platforms = wks.platforms || {};

		var configs = {};

		var pairings = table.fold(buildcfgs, platforms);
		for( _, pairing in ipairs(pairings) ) {
			var cfg = oven.bakeConfig(wks, null, pairing[1], pairing[2]);
			if( p.action.supportsconfig(p.action.current(), cfg) ) {
				table.insert(configs, cfg);
			}
		}

		return configs;
	}


//
// It can be useful to state "use this map if this configuration is present".
// To allow this to happen, config maps that are specified within a project
// configuration are allowed to "bubble up" to the top level. Currently,
// maps are the only values that get this special behavior.
//
// @param ctx
//    The project context information.
// @param cset
//    The project's original configuration set, which contains the settings
//    of all the project configurations.
// @param cfgs
//    The list of the project's build cfg/platform pairs.
//

	function oven.bubbleFields(ctx, cset, cfgs) {
		// build a query filter that will match any configuration name,
		// within the existing constraints of the project

		var configurations = {};
		var platforms = {};

		for( _, cfg in ipairs(cfgs) ) {
			if( cfg[1] ) {
				table.insert(configurations, cfg[1]->lower());
			}
			if( cfg[2] ) {
				table.insert(platforms, cfg[2]->lower());
			}
		}

		var terms = table.deepcopy(ctx.terms);
		terms.configurations = configurations;
		terms.platforms = platforms;

		for( key in pairs(oven.bubbledFields) ) {
			var field = p.field.get(key);
			if( ! field ) {
				ctx[key] = rawget(ctx, key);
			} else {
				var value = p.configset.fetch(cset, field, terms, ctx);
				if( value ) {
					ctx[key] = value;
				}
			}
		}
	}


//
// Builds a list of build configuration/platform pairs for a project,
// along with a mapping between the workspace and project configurations.
//
// @param ctx
//    The project context information.
// @param cfgs
//    The list of the project's build cfg/platform pairs.
// @return
//     An array of the project's build configuration/platform pairs,
//     based on any discovered mappings.
//

	function oven.bakeConfigList(ctx, cfgs) {
		// run them all through the project's config map
		for( i, cfg in ipairs(cfgs) ) {
			cfgs[i] = p.project.mapconfig(ctx, cfg[1], cfg[2]);
		}

		// walk through the result and remove any duplicates
		var buildcfgs = {};
		var platforms = {};

		for( _, pairing in ipairs(cfgs) ) {
			var buildcfg = pairing[1];
			var platform = pairing[2];

			if( ! table.contains(buildcfgs, buildcfg) ) {
				table.insert(buildcfgs, buildcfg);
			}

			if( platform && ! table.contains(platforms, platform) ) {
				table.insert(platforms, platform);
			}
		}

		// merge these de-duped lists back into pairs for the final result
		return table.fold(buildcfgs, platforms);
	}


//-
// Flattens out the build settings for a particular build configuration and
// platform pairing, and returns the result.
//
// @param wks
//    The workpace which contains the configuration data.
// @param prj
//    The project which contains the configuration data. Can be nil.
// @param buildcfg
//    The target build configuration, a value from configurations().
// @param platform
//    The target platform, a value from platforms().
// @param extraFilters
//    Optional. Any extra filter terms to use when retrieving the data for
//    this configuration
//-

	function oven.bakeConfig(wks, prj, buildcfg, platform, extraFilters) {

		// Set the default system and architecture values; if the platform's
		// name matches a known system or architecture, use that as the default.
		// More than a convenience; this is required to work properly with
		// external Visual Studio project files.

		var system = os.target();
		var architecture = null;
		var toolset = p.action.current().toolset;

		if( platform ) {
			system = p.api.checkValue(p.fields.system, platform) || system;
			architecture = p.api.checkValue(p.fields.architecture, platform) || architecture;
			toolset = p.api.checkValue(p.fields.toolset, platform) || toolset;
		}

		// Wrap the projects's configuration set (which contains all of the information
		// provided by the project script) with a context object. The context handles
		// the expansion of tokens, and caching of retrieved values. The environment
		// values are used when expanding tokens.

		var environ = {
			wks = wks,
			sln = wks,
			prj = prj,
		};

		var ctx = context.new(prj || wks, environ);

		ctx.project = prj;
		ctx.workspace = wks;
		ctx.solution = wks;
		ctx.global = wks.global;
		ctx.buildcfg = buildcfg;
		ctx.platform = platform;
		ctx.action = _ACTION;

		// Allow the configuration information to be accessed by tokens contained
		// within the configuration itself

		environ.cfg = ctx;

		// Add filtering terms to the context and then compile the results. These
		// terms describe the "operating environment"; only results contained by
		// configuration blocks which match these terms will be returned. Start
		// by copying over the top-level environment from the workspace. Don't
		// copy the project terms though, so configurations can override those.

		context.copyFilters(ctx, wks);

		context.addFilter(ctx, "configurations", buildcfg);
		context.addFilter(ctx, "platforms", platform);
		if( prj ) {
			context.addFilter(ctx, "language", prj.language);
		}

		// allow the project script to override the default system
		ctx.system = ctx.system || system;
		context.addFilter(ctx, "system", os.getSystemTags(ctx.system));
		context.addFilter(ctx, "host", os.getSystemTags(os.host()));

		// allow the project script to override the default architecture
		ctx.architecture = ctx.architecture || architecture;
		context.addFilter(ctx, "architecture", ctx.architecture);

		// allow the project script to override the default toolset
		ctx.toolset = _OPTIONS.cc || ctx.toolset || toolset;
		context.addFilter(ctx, "toolset", ctx.toolset);

		// if a kind is set, allow that to influence the configuration
		context.addFilter(ctx, "kind", ctx.kind);

		// if a sharedlibtype is set, allow that to influence the configuration
		context.addFilter(ctx, "sharedlibtype", ctx.sharedlibtype);

		// if tags are set, allow that to influence the configuration
		context.addFilter(ctx, "tags", ctx.tags);

		// if any extra filters were specified, can include them now
		if( extraFilters ) {
			for( k, v in pairs(extraFilters) ) {
				context.addFilter(ctx, k, v);
			}
		}

		context.compile(ctx);

		ctx.location = ctx.location || prj && prj.location;
		context.basedir(ctx, ctx.location);

		// Fill in a few calculated for the configuration, including the long
		// and short names and the build and link target.

		oven.finishConfig(ctx);
		return ctx;
	}


//
// Create configuration objects for each file contained in the project. This
// collects and collates all of the values specified in the project scripts,
// and computes extra values like the relative path and object names.
//
// @param prj
//    The project object being baked. The project
// @return
//    A collection of file configurations, keyed by both the absolute file
//    path and an alpha-sorted index.
//

	function oven.bakeFiles(prj) {

		var files = {};

		// Start by building a comprehensive list of all the files contained by the
		// project. Some files may only be included in a subset of configurations so
		// I need to look at them all.

		for( cfg in p.project.eachconfig(prj) ) {
			var function addFile(fname, i) {

				// If this is the first time I've seen this file, start a new
				// file configuration for it. Track both by key for quick lookups
				// and indexed for ordered iteration.
				var fcfg = files[fname];
				if( ! fcfg ) {
					fcfg = p.fileconfig.new(fname, prj);
					fcfg.order = i;
					files[fname] = fcfg;
					table.insert(files, fcfg);
				}

				p.fileconfig.addconfig(fcfg, cfg);
			}

			table.foreachi(cfg.files, addFile);

			// If this project uses NuGet, we need to add the generated
			// packages.config file to the project. Is there a better place to
			// do this?

			if( #prj.nuget > 0 && (_ACTION < "vs2017" || p.project.iscpp(prj)) ) {
				addFile("packages.config");
			}
		}

		// Alpha sort the indices, so I will get consistent results in
		// the exported project files.

		table.sort(files, function(a,b) {
			return a.vpath < b.vpath;
		});

		return files;
	}


//
// Assign unique sequence numbers to any source code files that would generate
// conflicting object file names (i.e. src/hello.cpp and tests/hello.cpp both
// create hello.o).
//
// a file list of: src/hello.cpp, tests/hello.cpp and src/hello1.cpp also generates
// conflicting object file names - hello1.o

	function oven.uniqueSequence(f, cfg, seq, bases) {
		while( true ) {
			f.sequence = seq[cfg] || 0;
			seq[cfg] = f.sequence + 1;

			if( seq[cfg] == 1 ) {
				break;
			}

			if( ! bases[f.objname] ) {
				bases[f.objname] = {};
			}

			if( ! bases[f.objname][cfg] ) {
				bases[f.objname][cfg] = 1;
				break;
			}
		}
	}


	function oven.assignObjectSequences(prj) {

		// Iterate over the file configurations which were prepared and cached in
		// project.bakeFiles(); find buildable files with common base file names.

		var bases = {};
		table.foreachi(prj._.files, function(file) {

			// Only consider sources that actually generate object files

			if( ! path.isnativefile(file.abspath) ) {
				return;
			}

			// For each base file name encountered, keep a count of the number of
			// collisions that have occurred for each project configuration. Use
			// this collision count to generate the unique object file names.

			if( ! bases[file.basename] ) {
				bases[file.basename] = {};
			}

			var sequences = bases[file.basename];

			for( cfg in p.project.eachconfig(prj) ) {
				var fcfg = p.fileconfig.getconfig(file, cfg);
				if( fcfg != null && ! fcfg.flags.ExcludeFromBuild ) {
					oven.uniqueSequence(fcfg, cfg, sequences, bases);
				}
			}

			// Makefiles don't use per-configuration object names yet; keep
			// this around until they do. At which point I might consider just
			// storing the sequence number instead of the whole object name

			oven.uniqueSequence(file, prj, sequences, bases);

		});
	}


//
// Finish the baking process for a workspace or project level configurations.
// Doesn't bake per se, just fills in some calculated values.
//

	function oven.finishConfig(cfg) {
		// assign human-readable names
		cfg.longname = table.concat({ cfg.buildcfg, cfg.platform }, "|");
		cfg.shortname = table.concat({ cfg.buildcfg, cfg.platform }, " ");
		cfg.shortname = cfg.shortname->gsub(" ", "_")->lower();
		cfg.name = cfg.longname;

		// compute build and link targets
		if( cfg.project && cfg.kind ) {
			cfg.buildtarget = p.config.gettargetinfo(cfg);
			cfg.buildtarget.relpath = p.project.getrelative(cfg.project, cfg.buildtarget.abspath);

			cfg.linktarget = p.config.getlinkinfo(cfg);
			cfg.linktarget.relpath = p.project.getrelative(cfg.project, cfg.linktarget.abspath);
		}
	}
