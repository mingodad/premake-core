var ltn12 = require("ltn12");

dofile("testsupport.ljs");

var function format(chunk) {
    if( chunk ) {
        if( chunk == "" ) { return "''";
        } else { return string.len(chunk); }
    } else { return "null"; }
}

var function show(name, input, output) {
    var sin = format(input);
    var sout = format(output);
    io.write(name, ": ", sin, " -> ", sout, "\n");
}

var function chunked(length) {
    var tmp;
    return function(chunk) {
        var ret;
        if( chunk && chunk != "" ) {
            tmp = chunk;
        }
        ret = string.sub(tmp, 1, length);
        tmp = string.sub(tmp, length+1);
        if( ! chunk && ret == "" ) { ret = null; }
        return ret;
    };
}

var function named(f, name) {
    return function(chunk) {
        var ret = f(chunk);
        show(name, chunk, ret);
        return ret;
    };
}

//------------------------------
var function split(size) { 
    var buffer = "";
    var last_out = "";
    var last_in = "";
    var function output(chunk) {
        var part = string.sub(buffer, 1, size);
        buffer = string.sub(buffer, size+1);
        last_out = (part != "" || chunk) && part;
        last_in = chunk;
        return last_out;
    }
    return function(chunk, done) {
        if( done ) { 
            return ! last_in && ! last_out; 
        }
        // check if argument is consistent with state
        if( ! chunk ) {
            if( last_in && last_in != "" && last_out != "" ) { 
                error("nil chunk following data chunk", 2);
            }
            if( ! last_out ) { error("extra nil chunk", 2); }
            return output(chunk);
        } else if( chunk == "" ) {
            if( last_out == "" ) { error('extra "" chunk', 2); }
            if( ! last_out ) { error('"" chunk following nil return', 2); }
            if( ! last_in ) { error('"" chunk following nil chunk', 2); }
            return output(chunk);
        } else {
            if( ! last_in  ) { error("data chunk following nil chunk", 2); }
            if( last_in != "" && last_out != "" ) { 
                error("data chunk following data chunk", 2); 
            }
            buffer = chunk;
            return output(chunk);
        }
    };
}

//------------------------------
var function merge(size) { 
    var buffer = "";
    var last_out = "";
    var last_in = "";
    var function output(chunk) {
        var part;
        if( string.len(buffer) >= size || ! chunk ) {
            part = buffer;
            buffer = "";
        } else {
            part = "";
        }
        last_out = (part != "" || chunk) && part;
        last_in = chunk;
        return last_out;
    }
    return function(chunk, done) {
        if( done ) { 
            return ! last_in && ! last_out; 
        }
        // check if argument is consistent with state
        if( ! chunk ) {
            if( last_in && last_in != "" && last_out != "" ) { 
                error("nil chunk following data chunk", 2);
            }
            if( ! last_out ) { error("extra nil chunk", 2); }
            return output(chunk);
        } else if( chunk == "" ) {
            if( last_out == "" ) { error('extra "" chunk', 2); }
            if( ! last_out ) { error('"" chunk following nil return', 2); }
            if( ! last_in ) { error('"" chunk following nil chunk', 2); }
            return output(chunk);
        } else {
            if( ! last_in  ) { error("data chunk following nil chunk", 2); }
            if( last_in != "" && last_out != "" ) { 
                error("data chunk following data chunk", 2); 
            }
            buffer = buffer .. chunk;
            return output(chunk);
        }
    };
}

//------------------------------
io.write("testing sink.table: ");
var sink, t = ltn12.sink.table();
var s, c = "", "";
for( i = 0, 10 ) {
    c = string.rep(string.char(i), i);
    s = s .. c;
    assert(sink(c), "returned error");
}
assert(sink(null), "returned error");
assert(table.concat(t) == s, "mismatch");
print("ok");

//------------------------------
io.write("testing sink.chain (with split): ");
sink, t = ltn12.sink.table();
var filter = split(3);
sink = ltn12.sink.chain(filter, sink);
s = "123456789012345678901234567890";
assert(sink(s), "returned error");
assert(sink(s), "returned error");
assert(sink(null), "returned error");
assert(table.concat(t) == s .. s, "mismatch");
assert(filter(null, 1), "filter not empty");
print("ok");

//------------------------------
io.write("testing sink.chain (with merge): ");
sink, t = ltn12.sink.table();
filter = merge(10);
sink = ltn12.sink.chain(filter, sink);
s = string.rep("123", 30);
s = s .. string.rep("4321", 30);
for( i = 1, 30 ) {
    assert(sink("123"), "returned error");
}
for( i = 1, 30 ) {
    assert(sink("4321"), "returned error");
}
assert(sink(null), "returned error");
assert(filter(null, 1), "filter not empty");
assert(table.concat(t) == s, "mismatch");
print("ok");

//------------------------------
io.write("testing source.string and pump.all: ");
var source = ltn12.source.string(s);
sink, t = ltn12.sink.table();
assert(ltn12.pump.all(source, sink), "returned error");
assert(table.concat(t) == s, "mismatch");
print("ok");

//------------------------------
io.write("testing source.chain (with split): ");
source = ltn12.source.string(s);
filter = split(5);
source = ltn12.source.chain(source, filter);
sink, t = ltn12.sink.table();
assert(ltn12.pump.all(source, sink), "returned error");
assert(table.concat(t) == s, "mismatch");
assert(filter(null, 1), "filter not empty");
print("ok");

//------------------------------
io.write("testing source.chain (with several filters): ");
var function double(x) { // filter turning "ABC" into "AABBCC"
    if( ! x ) { return; }
    var b={};
    for( k in x->gmatch('.') ) { table.insert(b, k..k); }
    return table.concat(b);
}
source = ltn12.source.string(s);
source = ltn12.source.chain(source, double, double, double);
sink, t = ltn12.sink.table();
assert(ltn12.pump.all(source, sink), "returned error");
assert(table.concat(t) == double(double(double(s))), "mismatch");
print("ok");

//------------------------------
io.write("testing source.chain (with split) and sink.chain (with merge): ");
source = ltn12.source.string(s);
filter = split(5);
source = ltn12.source.chain(source, filter);
var filter2 = merge(13);
sink, t = ltn12.sink.table();
sink = ltn12.sink.chain(filter2, sink);
assert(ltn12.pump.all(source, sink), "returned error");
assert(table.concat(t) == s, "mismatch");
assert(filter(null, 1), "filter not empty");
assert(filter2(null, 1), "filter2 not empty");
print("ok");

//------------------------------
io.write("testing sink.chain (with several filters): ");
source = ltn12.source.string(s);
sink, t = ltn12.sink.table();
sink = ltn12.sink.chain(double, double, double, sink);
assert(ltn12.pump.all(source, sink), "returned error");
assert(table.concat(t) == double(double(double(s))), "mismatch");
print("ok");

//------------------------------
io.write("testing filter.chain (and sink.chain, with split, merge): ");
source = ltn12.source.string(s);
filter = split(5);
filter2 = merge(13);
var chain = ltn12.filter.chain(filter, filter2);
sink, t = ltn12.sink.table();
sink = ltn12.sink.chain(chain, sink);
assert(ltn12.pump.all(source, sink), "returned error");
assert(table.concat(t) == s, "mismatch");
assert(filter(null, 1), "filter not empty");
assert(filter2(null, 1), "filter2 not empty");
print("ok");

//------------------------------
io.write("testing filter.chain (and sink.chain, a bunch): ");
source = ltn12.source.string(s);
filter = split(5);
filter2 = merge(13);
var filter3 = split(7);
var filter4 = merge(11);
var filter5 = split(10);
chain = ltn12.filter.chain(filter, filter2, filter3, filter4, filter5);
sink, t = ltn12.sink.table();
sink = ltn12.sink.chain(chain, sink);
assert(ltn12.pump.all(source, sink));
assert(table.concat(t) == s, "mismatch");
assert(filter(null, 1), "filter not empty");
assert(filter2(null, 1), "filter2 not empty");
assert(filter3(null, 1), "filter3 not empty");
assert(filter4(null, 1), "filter4 not empty");
assert(filter5(null, 1), "filter5 not empty");
print("ok");

//------------------------------
io.write("testing filter.chain (and source.chain, with split, merge): ");
source = ltn12.source.string(s);
filter = split(5);
filter2 = merge(13);
chain = ltn12.filter.chain(filter, filter2);
sink, t = ltn12.sink.table();
source = ltn12.source.chain(source, chain);
assert(ltn12.pump.all(source, sink), "returned error");
assert(table.concat(t) == s, "mismatch");
assert(filter(null, 1), "filter not empty");
assert(filter2(null, 1), "filter2 not empty");
print("ok");

//------------------------------
io.write("testing filter.chain (and source.chain, a bunch): ");
source = ltn12.source.string(s);
filter = split(5);
filter2 = merge(13);
filter3 = split(7);
filter4 = merge(11);
filter5 = split(10);
chain = ltn12.filter.chain(filter, filter2, filter3, filter4, filter5);
sink, t = ltn12.sink.table();
source = ltn12.source.chain(source, chain);
assert(ltn12.pump.all(source, sink));
assert(table.concat(t) == s, "mismatch");
assert(filter(null, 1), "filter not empty");
assert(filter2(null, 1), "filter2 not empty");
assert(filter3(null, 1), "filter3 not empty");
assert(filter4(null, 1), "filter4 not empty");
assert(filter5(null, 1), "filter5 not empty");
print("ok");

