//
// vs2005_solution.ljs
// Generate a Visual Studio 2005+ solution.
// Copyright (c) Jason Perkins and the Premake project
//

	var p = premake;
	p.vstudio.sln2005 = {};

	var vstudio = p.vstudio;
	var sln2005 = p.vstudio.sln2005;
	var project = p.project;
	var tree = p.tree;


//-
// Add namespace for element definition lists for p.callArray()
//-

	sln2005.elements = {};


//
// Return the list of sections contained in the solution.
// TODO: Get rid of this when the MonoDevelop module no longer needs it
//

	function sln2005.solutionSections(wks) {
		return {
			"ConfigurationPlatforms",
			"SolutionProperties",
			"NestedProjects",
			"ExtensibilityGlobals"
		};
	}


//
// Generate a Visual Studio 200x solution, with support for the new platforms API.
//

	function sln2005.generate(wks) {
		// Mark the file as Unicode
		p.utf8();
		p.outln('');

		sln2005.reorderProjects(wks);

		sln2005.header();
		sln2005.projects(wks);

		p.push('Global');
		sln2005.sections(wks);
		p.pop('EndGlobal');
		p.w();
	}


//
// Generate the solution header. Each Visual Studio action definition
// should include its own version.
//

	function sln2005.header() {
		var action = p.action.current();
		p.w('Microsoft Visual Studio Solution File, Format Version %d.00', action.vstudio.solutionVersion);
		p.w('# Visual Studio %s', action.vstudio.versionName);
	}


//
// If a startup project is specified, move it (and any enclosing groups)
// to the front of the project list. This will make Visual Studio treat
// it like a startup project.
//
// I force the new ordering into the tree so that it will get applied to
// all sections of the solution; otherwise the first change to the solution
// in the IDE will cause the orderings to get rewritten.
//

	function sln2005.reorderProjects(wks) {
		if( wks.startproject ) {
			var np;
			var tr = p.workspace.grouptree(wks);
			tree.traverse(tr, {
				onleaf = function(n) {
					if( n.project.name == wks.startproject ) {
						np = n;
					}
				}
			});

			while( np && np.parent ) {
				var p = np.parent;
				var i = table.indexof(p.children, np);
				table.remove(p.children, i);
				table.insert(p.children, 1, np);
				np = p;
			}
		}
	}


//
// Write out the list of projects and groups contained by the solution.
//

	function sln2005.projects(wks) {
		var tr = p.workspace.grouptree(wks);
		tree.traverse(tr, {
			onleaf = function(n) {
				var prj = n.project;

				// Build a relative path from the solution file to the project file
				var prjpath = vstudio.projectfile(prj);
				prjpath = vstudio.path(prj.workspace, prjpath);

				// Unlike projects, solutions must use old-school %...% DOS style
				// for environment variables.
				prjpath = prjpath->gsub("$%((.-)%)", "%%%1%%");

				p.x('Project("{%s}") = "%s", "%s", "{%s}"', vstudio.tool(prj), prj.name, prjpath, prj.uuid);
				p.push();
				sln2005.projectdependencies(prj);
				p.pop('EndProject');
			},

			onbranch = function(n) {
				p.push('Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "%s", "%s", "{%s}"', n.name, n.name, n.uuid);
				p.pop('EndProject');
			},
		});
	}


//
// Write out the list of project dependencies for a particular project.
//

	function sln2005.projectdependencies(prj) {
		var deps = project.getdependencies(prj, 'dependOnly');
		if( #deps > 0 ) {
			p.push('ProjectSection(ProjectDependencies) = postProject');
			for( _, dep in ipairs(deps) ) {
				p.w('{%s} = {%s}', dep.uuid, dep.uuid);
			}
			p.pop('EndProjectSection');
		}
	}


//
// Write out the list of project configuration platforms.
//

	sln2005.elements.projectConfigurationPlatforms = function(cfg, context) {
		return {
			sln2005.activeCfg,
			sln2005.build0,
		};
	};


	function sln2005.projectConfigurationPlatforms(wks, sorted, descriptors) {
		p.w("GlobalSection(ProjectConfigurationPlatforms) = postSolution");
		var tr = p.workspace.grouptree(wks);
		tree.traverse(tr, {
			onleaf = function(n) {
				var prj = n.project;
				table.foreachi(sorted, function(cfg) {
					var context = {};
					// Look up the matching project configuration. If none exist, this
					// configuration has been excluded from the project, and should map
					// to closest available project configuration instead.
					context.prj = prj;
					context.prjCfg = project.getconfig(prj, cfg.buildcfg, cfg.platform);
					context.excluded = (context.prjCfg == null || context.prjCfg.flags.ExcludeFromBuild);

					if( context.prjCfg == null ) {
						context.prjCfg = project.findClosestMatch(prj, cfg.buildcfg, cfg.platform);
					}

					context.descriptor = descriptors[cfg];
					context.platform = vstudio.projectPlatform(context.prjCfg);
					context.architecture = vstudio.archFromConfig(context.prjCfg, true);

					p.push();
					p.callArray(sln2005.elements.projectConfigurationPlatforms, cfg, context);
					p.pop();
				});
			}
		});
		p.w("EndGlobalSection");
	}


	function sln2005.activeCfg(cfg, context) {
		p.w('{%s}.%s.ActiveCfg = %s|%s', context.prj.uuid, context.descriptor, context.platform, context.architecture);
	}


	function sln2005.build0(cfg, context) {
		if( ! context.excluded && context.prjCfg.kind != p.NONE ) {
			p.w('{%s}.%s.Build.0 = %s|%s', context.prj.uuid, context.descriptor, context.platform, context.architecture);
		}
	}

//
// Write out the tables that map solution configurations to project configurations.
//

	function sln2005.configurationPlatforms(wks) {

		var descriptors = {};
		var sorted = {};

		for( cfg in p.workspace.eachconfig(wks) ) {

			// Create a Visual Studio solution descriptor (i.e. Debug|Win32) for
			// this solution configuration. I need to use it in a few different places
			// below so it makes sense to precompute it up front.

			var platform = vstudio.solutionPlatform(cfg);
			descriptors[cfg] = string.format("%s|%s", cfg.buildcfg, platform);

			// Also add the configuration to an indexed table which I can sort below

			table.insert(sorted, cfg);

		}

		// Sort the solution configurations to match Visual Studio's preferred
		// order, which appears to be a simple alpha sort on the descriptors.

		table.sort(sorted, function(cfg0, cfg1) {
			return descriptors[cfg0]->lower() < descriptors[cfg1]->lower();
		});

		// Now I can output the sorted list of solution configuration descriptors

		// Visual Studio assumes the first configurations as the defaults.
		if( wks.defaultplatform ) {
			p.push('GlobalSection(SolutionConfigurationPlatforms) = preSolution');
			table.foreachi(sorted, function (cfg) {
				if( cfg.platform == wks.defaultplatform ) {
					p.w('%s = %s', descriptors[cfg], descriptors[cfg]);
				}
			});
			p.pop("EndGlobalSection");
		}

		p.push('GlobalSection(SolutionConfigurationPlatforms) = preSolution');
		table.foreachi(sorted, function (cfg) {
			if( ! wks.defaultplatform || cfg.platform != wks.defaultplatform ) {
				p.w('%s = %s', descriptors[cfg], descriptors[cfg]);
			}
		});
		p.pop("EndGlobalSection");

		// For each project in the solution...
		sln2005.projectConfigurationPlatforms(wks, sorted, descriptors);
	}



//
// Write out contents of the SolutionProperties section; currently unused.
//

	function sln2005.properties(wks) {
		p.push('GlobalSection(SolutionProperties) = preSolution');
		p.w('HideSolutionNode = FALSE');
		p.pop('EndGlobalSection');
	}


//
// Write out the NestedProjects block, which describes the structure of
// any solution groups.
//

	function sln2005.nestedProjects(wks) {
		var tr = p.workspace.grouptree(wks);
		if( tree.hasbranches(tr) ) {
			p.push('GlobalSection(NestedProjects) = preSolution');
			tree.traverse(tr, {
				onnode = function(n) {
					if( n.parent.uuid ) {
						p.w('{%s} = {%s}', (n.project || n).uuid, n.parent.uuid);
					}
				}
			});
			p.pop('EndGlobalSection');
		}
	}


//
// Write out the ExtensibilityGlobals block, which embeds some data for the
// Visual Studio PremakeExtension.
//
	function sln2005.premakeExtensibilityGlobals(wks) {
		if( wks.editorintegration ) {
			// we need to filter out the 'file' argument, since we already output
			// the script separately.
			var args = {};
			for( _, arg in ipairs(_ARGV) ) {
				if( ! (arg->startswith("--file") || arg->startswith("/file")) ) {
					table.insert(args, arg);
				}
			}

			p.w('PremakeBinary = %s', _PREMAKE_COMMAND);
			p.w('PremakeScript = %s', p.workspace.getrelative(wks, _MAIN_SCRIPT));
			p.w('PremakeArguments = %s', table.concat(args, ' '));
		}
	}

//
// Map ExtensibilityGlobals to output functions.
//

	sln2005.elements.extensibilityGlobals = function(wks) {
		return {
			sln2005.premakeExtensibilityGlobals,
		};
	};

//
// Output the ExtensibilityGlobals section.
//
	function sln2005.extensibilityGlobals(wks) {
		var contents = p.capture(function () {
			p.push();
			p.callArray(sln2005.elements.extensibilityGlobals, wks);
			p.pop();
		});

		if( #contents > 0 ) {
			p.push('GlobalSection(ExtensibilityGlobals) = postSolution');
			p.outln(contents);
			p.pop('EndGlobalSection');
		}
	}


//
// Map solution sections to output functions. Tools that aren't listed will
// be ignored.
//

	sln2005.elements.sections = function(wks) {
		return {
			sln2005.configurationPlatforms,
			sln2005.properties,
			sln2005.nestedProjects,
			sln2005.extensibilityGlobals,
		};
	};


//
// Write out all of the workspace sections.
//

	function sln2005.sections(wks) {
		p.callArray(sln2005.elements.sections, wks);
	}
