//
// Name:        codelite/codelite_project.ljs
// Purpose:     Generate a CodeLite C/C++ project file.
// Author:      Ryan Pusztai
// Modified by: Andrea Zanellato
//              Manu Evans
//              Tom van Dijck
// Created:     2013/05/06
// Copyright:   (c) 2008-2016 Jason Perkins and the Premake project
//

	var p = premake;
	var tree = p.tree;
	var project = p.project;
	var config = p.config;
	var codelite = p.modules.codelite;

	codelite.project = {};
	var m = codelite.project;


	function codelite.getLinks(cfg) {
		// System libraries are undecorated, add the required extension
		return config.getlinks(cfg, "system", "fullpath");
	}

	function codelite.getSiblingLinks(cfg) {
		// If we need sibling projects to be listed explicitly, add them on
		return config.getlinks(cfg, "siblings", "fullpath");
	}


	m.elements = {};

	m.ctools = {
		gcc = "gnu gcc",
		clang = "clang",
		msc = "Visual C++",
	};
	m.cxxtools = {
		gcc = "gnu g++",
		clang = "clang++",
		msc = "Visual C++",
	};

	function m.getcompilername(cfg) {
		var tool = _OPTIONS.cc || cfg.toolset || p.CLANG;

		var toolset = p.tools[tool];
		if( ! toolset ) {
			error("Invalid toolset '" + (_OPTIONS.cc || cfg.toolset) + "'");
		}

		if( p.languages.isc(cfg.language) ) {
			return m.ctools[tool];
		} else if( p.languages.iscpp(cfg.language) ) {
			return m.cxxtools[tool];
		}
	}

	function m.getcompiler(cfg) {
		var toolset = p.tools[_OPTIONS.cc || cfg.toolset || p.CLANG];
		if( ! toolset ) {
			error("Invalid toolset '" + (_OPTIONS.cc || cfg.toolset) + "'");
		}
		return toolset;
	}

	var function configuration_iscustombuild(cfg) {

		return cfg && (cfg.kind == p.MAKEFILE) && (#cfg.buildcommands > 0);
	}

	var function configuration_isfilelist(cfg) {

		return cfg && (cfg.buildaction == "None") && ! configuration_iscustombuild(cfg);
	}

	var function configuration_needresoptions(cfg) {

		return cfg && config.findfile(cfg, ".rc") && ! configuration_iscustombuild(cfg);
	}


	m.internalTypeMap = {
		ConsoleApp = "Console",
		WindowedApp = "Console",
		Makefile = "",
		SharedLib = "Library",
		StaticLib = "Library"
	};

	function m.header(prj) {
		_p('<?xml version="1.0" encoding="UTF-8"?>');

		var type = m.internalTypeMap[prj.kind] || "";
		_x('<CodeLite_Project Name="%s" InternalType="%s">', prj.name, type);
	}

	function m.plugins(prj) {
//		_p(1, '<Plugins>')
			// <Plugin Name="CMakePlugin">
			// <Plugin Name="qmake">
//		_p(1, '</Plugins>')

		_p(1, '<Plugins/>');
	}

	function m.description(prj) {
		_p(1, '<Description/>');

		// TODO: ...
	}

	function m.files(prj) {
		var tr = project.getsourcetree(prj);
		tree.traverse(tr, {
			// folders are handled at the internal nodes
			onbranchenter = function(node, depth) {
				_p(depth, '<VirtualDirectory Name="%s">', node.name);
			},
			onbranchexit = function(node, depth) {
				_p(depth, '</VirtualDirectory>');
			},
			// source files are handled at the leaves
			onleaf = function(node, depth) {
				var excludesFromBuild = {};
				for( cfg in project.eachconfig(prj) ) {
					var cfgname = codelite.cfgname(cfg);
					var fcfg = p.fileconfig.getconfig(node, cfg);
					if( ! fcfg || fcfg.flags.ExcludeFromBuild ) {
						table.insert(excludesFromBuild, cfgname);
					}
				}

				if( #excludesFromBuild > 0 ) {
					_p(depth, '<File Name="%s" ExcludeProjConfig="%s" />', node.relpath, table.concat(excludesFromBuild, ';'));
				} else {
					_p(depth, '<File Name="%s"/>', node.relpath);
				}
			},
		}, true);
	}

	function m.dependencies(prj) {

		// TODO: dependencies don't emit a line for each config if there aren't any...

//		_p(1, '<Dependencies/>')

		var dependencies = project.getdependencies(prj);
		for( cfg in project.eachconfig(prj) ) {
			cfgname = codelite.cfgname(cfg);
			if( #dependencies > 0 ) {
				_p(1, '<Dependencies Name="%s">', cfgname);
					for( _, dependency in ipairs(dependencies) ) {
						_p(2, '<Project Name="%s"/>', dependency.name);
					}
				_p(1, '</Dependencies>');
			} else {
				_p(1, '<Dependencies Name="%s"/>', cfgname);
			}
		}
	}


	function m.global_compiler(prj) {
		_p(3, '<Compiler Options="" C_Options="" Assembler="">');
		_p(4, '<IncludePath Value="."/>');
		_p(3, '</Compiler>');
	}

	function m.global_linker(prj) {
		_p(3, '<Linker Options="">');
		_p(4, '<LibraryPath Value="."/>');
		_p(3, '</Linker>');
	}

	function m.global_resourceCompiler(prj) {
		_p(3, '<ResourceCompiler Options=""/>');
	}

	m.elements.globalSettings = function(prj) {
		return {
			m.global_compiler,
			m.global_linker,
			m.global_resourceCompiler,
		};
	};


	function m.compiler(cfg) {
		if( configuration_iscustombuild(cfg) || configuration_isfilelist(cfg) ) {
			_p(3, '<Compiler Required="no"/>');
			return;
		}

		var toolset = m.getcompiler(cfg);
		var cxxflags = table.concat(table.join(toolset.getcxxflags(cfg), cfg.buildoptions), ";");
		var cflags   = table.concat(table.join(toolset.getcflags(cfg), cfg.buildoptions), ";");
		var asmflags = "";
		var pch      = "";

		_x(3, '<Compiler Options="%s" C_Options="%s" Assembler="%s" Required="yes" PreCompiledHeader="%s" PCHInCommandLine="no" UseDifferentPCHFlags="no" PCHFlags="">', cxxflags, cflags, asmflags, pch);

		for( _, includedir in ipairs(cfg.includedirs) ) {
			_x(4, '<IncludePath Value="%s"/>', project.getrelative(cfg.project, includedir));
		}
		for( _, define in ipairs(cfg.defines) ) {
			_x(4, '<Preprocessor Value="%s"/>', p.esc(define));
		}
		_p(3, '</Compiler>');
	}

	function m.linker(cfg) {
		if( configuration_iscustombuild(cfg) || configuration_isfilelist(cfg) ) {
			_p(3, '<Linker Required="no"/>');
			return;
		}

		var toolset = m.getcompiler(cfg);
		var flags   = table.join(toolset.getldflags(cfg), cfg.linkoptions, toolset.getlinks(cfg));

		_x(3, '<Linker Required="yes" Options="%s">', table.concat(flags, ";"));

		for( _, libdir in ipairs(cfg.libdirs) ) {
			_p(4, '<LibraryPath Value="%s"/>', project.getrelative(cfg.project, libdir));
		}
		_p(3, '</Linker>');
	}

	function m.resourceCompiler(cfg) {
		if( ! configuration_needresoptions(cfg) ) {
			_p(3, '<ResourceCompiler Options="" Required="no"/>');
			return;
		}

		var toolset = m.getcompiler(cfg);
		var defines = table.implode(toolset.getdefines(table.join(cfg.defines, cfg.resdefines)), "", ";", "");
		var options = table.concat(cfg.resoptions, ";");

		_x(3, '<ResourceCompiler Options="%s%s" Required="yes">', defines, options);
		for( _, includepath in ipairs(table.join(cfg.includedirs, cfg.resincludedirs)) ) {
			_x(4, '<IncludePath Value="%s"/>', project.getrelative(cfg.project, includepath));
		}
		_p(3, '</ResourceCompiler>');
	}

	function m.general(cfg) {
		if( configuration_isfilelist(cfg) ) {
			_p(3, '<General IntermediateDirectory="." WorkingDirectory="." PauseExecWhenProcTerminates="no"/>');
			return;
		}

		var prj = cfg.project;

		var isExe = prj.kind == "WindowedApp" || prj.kind == "ConsoleApp";
		var targetpath = project.getrelative(prj, cfg.buildtarget.directory);
		var objdir     = project.getrelative(prj, cfg.objdir);
		var targetname = project.getrelative(prj, cfg.buildtarget.abspath);
		var workingdir = cfg.debugdir || prj.location;
		var command    = (isExe ? path.getrelative(workingdir, cfg.buildtarget.abspath) : "");
		var cmdargs    = (isExe ? table.concat(cfg.debugargs, " ") : ""); // TODO: should this be debugargs instead?
		var useseparatedebugargs = "no";
		var debugargs  = "";
		workingdir = (isExe ? project.getrelative(prj, cfg.debugdir) : "");
		var pauseexec  = (prj.kind == "ConsoleApp" ? "yes" : "no");
		var isguiprogram = (prj.kind == "WindowedApp" ? "yes" : "no");
		var isenabled  = (cfg.flags.ExcludeFromBuild ? "no" : "yes");
		var ldPath = '';

		for( _, libdir in ipairs(cfg.libdirs) ) {
			ldPath = ldPath .. ":" .. project.getrelative(cfg.project, libdir);
		}

		if( ldPath == null || ldPath == '' ) {
			_x(3, '<General OutputFile="%s" IntermediateDirectory="%s" Command="%s" CommandArguments="%s" UseSeparateDebugArgs="%s" DebugArguments="%s" WorkingDirectory="%s" PauseExecWhenProcTerminates="%s" IsGUIProgram="%s" IsEnabled="%s"/>',
				targetname, objdir, command, cmdargs, useseparatedebugargs, debugargs, workingdir, pauseexec, isguiprogram, isenabled);
		} else {
			ldPath = string.sub(ldPath, 2);
			_x(3, '<General OutputFile="%s" IntermediateDirectory="%s" Command="LD_LIBRARY_PATH=%s %s" CommandArguments="%s" UseSeparateDebugArgs="%s" DebugArguments="%s" WorkingDirectory="%s" PauseExecWhenProcTerminates="%s" IsGUIProgram="%s" IsEnabled="%s"/>',
 				targetname, objdir, ldPath, command, cmdargs, useseparatedebugargs, debugargs, workingdir, pauseexec, isguiprogram, isenabled);
		}
	}

	function m.environment(cfg) {
		var envs = table.concat(cfg.debugenvs, "\n");

		_p(3, '<Environment EnvVarSetName="&lt;Use Defaults&gt;" DbgSetName="&lt;Use Defaults&gt;">');
		_x(4, '<![CDATA[%s]]>', envs);
		_p(3, '</Environment>');
	}

	function m.debugger(cfg) {

		_p(3, '<Debugger IsRemote="%s" RemoteHostName="%s" RemoteHostPort="%s" DebuggerPath="" IsExtended="%s">', (cfg.debugremotehost ? "yes" : "no"), cfg.debugremotehost || "", (cfg.debugport ? tostring(cfg.debugport) : ""), (cfg.debugextendedprotocol ? "yes" : "no"));
		if( #cfg.debugsearchpaths > 0 ) {
			_p(4, '<DebuggerSearchPaths>%s</DebuggerSearchPaths>', table.concat(p.esc(project.getrelative(cfg.project, cfg.debugsearchpaths)), "\n"));
		} else {
			_p(4, '<DebuggerSearchPaths/>');
		}
		if( #cfg.debugconnectcommands > 0 ) {
			_p(4, '<PostConnectCommands>%s</PostConnectCommands>', table.concat(p.esc(cfg.debugconnectcommands), "\n"));
		} else {
			_p(4, '<PostConnectCommands/>');
		}
		if( #cfg.debugstartupcommands > 0 ) {
			_p(4, '<StartupCommands>%s</StartupCommands>', table.concat(p.esc(cfg.debugstartupcommands), "\n"));
		} else {
			_p(4, '<StartupCommands/>');
		}
		_p(3, '</Debugger>');
	}

	function m.preBuild(cfg) {
		if( #cfg.prebuildcommands > 0 ) {
			_p(3, '<PreBuild>');
			var commands = os.translateCommandsAndPaths(cfg.prebuildcommands, cfg.project.basedir, cfg.project.location);
			for( _, command in ipairs(commands) ) {
				_x(4, '<Command Enabled="yes">%s</Command>',
				p.esc(command));
			}
			_p(3, '</PreBuild>');
		}
	}

	function m.postBuild(cfg) {
		if( #cfg.postbuildcommands > 0 ) {
			_p(3, '<PostBuild>');
			var commands = os.translateCommandsAndPaths(cfg.postbuildcommands, cfg.project.basedir, cfg.project.location);
			for( _, command in ipairs(commands) ) {
				_x(4, '<Command Enabled="yes">%s</Command>',
				p.esc(command));
			}
			_p(3, '</PostBuild>');
		}
	}

	function m.customBuild(cfg) {
		if( ! configuration_iscustombuild(cfg) ) {
			_p(3, '<CustomBuild Enabled="no"/>');
			return;
		}

		var build   = table.implode(cfg.buildcommands,"","","");
		var clean   = table.implode(cfg.cleancommands,"","","");
		var rebuild = table.implode(cfg.rebuildcommands,"","","");

		_p(3, '<CustomBuild Enabled="yes">');
		_x(4, '<BuildCommand>%s</BuildCommand>', build);
		_x(4, '<CleanCommand>%s</CleanCommand>', clean);
		_x(4, '<RebuildCommand>%s</RebuildCommand>', rebuild);
		_p(4, '<PreprocessFileCommand></PreprocessFileCommand>');
		_p(4, '<SingleFileCommand></SingleFileCommand>');
		_p(4, '<MakefileGenerationCommand></MakefileGenerationCommand>');
		_p(4, '<ThirdPartyToolName></ThirdPartyToolName>');
		_p(4, '<WorkingDirectory></WorkingDirectory>');
		_p(3, '</CustomBuild>');
	}

	function m.additionalRules(cfg) {
		if( configuration_iscustombuild(cfg) ) {
			_p(3, '<AdditionalRules/>');
			return;
		}

		_p(3, '<AdditionalRules>');
		_p(4, '<CustomPostBuild/>');
		_p(4, '<CustomPreBuild/>');
		_p(3, '</AdditionalRules>');
	}

	function m.isCpp11(cfg) {
		return (cfg.cppdialect == 'gnu++11') || (cfg.cppdialect == 'C++11') || (cfg.cppdialect == 'gnu++0x') || (cfg.cppdialect == 'C++0x');
	}

	function m.isCpp14(cfg) {
		return (cfg.cppdialect == 'gnu++14') || (cfg.cppdialect == 'C++14') || (cfg.cppdialect == 'gnu++1y') || (cfg.cppdialect == 'C++1y');
	}

	function m.completion(cfg) {
		_p(3, '<Completion EnableCpp11="%s" EnableCpp14="%s">',
			(m.isCpp11(cfg) ? "yes" : "no"),
			(m.isCpp14(cfg) ? "yes" : "no")
		);
		_p(4, '<ClangCmpFlagsC/>');
		_p(4, '<ClangCmpFlags/>');
		_p(4, '<ClangPP/>'); // TODO: we might want to set special code completion macros...?
		_p(4, '<SearchPaths/>'); // TODO: search paths for code completion?
		_p(3, '</Completion>');
	}

	m.elements.settings = function(cfg) {
		return {
			m.compiler,
			m.linker,
			m.resourceCompiler,
			m.general,
			m.environment,
			m.debugger,
			m.preBuild,
			m.postBuild,
			m.customBuild,
			m.additionalRules,
			m.completion,
		};
	};

	m.types =
	{
		ConsoleApp  = "Executable",
		Makefile    = "",
		SharedLib   = "Dynamic Library",
		StaticLib   = "Static Library",
		WindowedApp = "Executable",
		Utility     = "",
	};

	m.debuggers =
	{
		Default = "GNU gdb debugger",
		GDB = "GNU gdb debugger",
		LLDB = "LLDB Debugger",
	};

	function m.settings(prj) {
		_p(1, '<Settings Type="%s">', m.types[prj.kind] || "");

		_p(2, '<GlobalSettings>');
		p.callArray(m.elements.globalSettings, prj);
		_p(2, '</GlobalSettings>');

		for( cfg in project.eachconfig(prj) ) {

			var cfgname  = codelite.cfgname(cfg);
			var compiler = m.getcompilername(cfg);
			var debugger = m.debuggers[cfg.debugger] || m.debuggers.Default;
			var type = m.types[cfg.kind];

			_x(2, '<Configuration Name="%s" CompilerType="%s" DebuggerType="%s" Type="%s" BuildCmpWithGlobalSettings="append" BuildLnkWithGlobalSettings="append" BuildResWithGlobalSettings="append">', cfgname, compiler, debugger, type);

			p.callArray(m.elements.settings, cfg);

			_p(2, '</Configuration>');
		}

		_p(1, '</Settings>');
	}


	m.elements.project = function(prj) {
		return {
			m.header,
			m.plugins,
			m.description,
			m.files,
			m.dependencies,
			m.settings,
		};
	};

//
// Project: Generate the CodeLite project file.
//
	function m.generate(prj) {
		p.utf8();

		p.callArray(m.elements.project, prj);

		_p('</CodeLite_Project>');
	}
