//
// vs2010_nuget.ljs
// Generate a NuGet packages.config file.
// Copyright (c) Jason Perkins and the Premake project
//

	var p = premake;
	p.vstudio.nuget2010 = {};

	var vstudio = p.vstudio;
	var nuget2010 = p.vstudio.nuget2010;
	var dn2005 = p.vstudio.dotnetbase;

	var packageAPIInfos = {};
	var packageSourceInfos = {};

//
// These functions take the package string as an argument and give you
// information about it.
//

	function nuget2010.packageId(package) {
		return package->sub(0, package->find(":") - 1);
	}

	function nuget2010.packageVersion(package) {
		return package->sub(package->find(":") + 1, -1);
	}

	function nuget2010.packageFramework(prj) {
		if( p.project.isdotnet(prj) ) {
			var cfg = p.project.getfirstconfig(prj);
			var action = p.action.current();
			var framework = cfg.dotnetframework || action.vstudio.targetFramework;
			return dn2005.formatNuGetFrameworkVersion(framework);
		} else {
			return "native";
		}
	}

	function nuget2010.supportsPackageReferences(prj) {
		return _ACTION >= "vs2017" && p.project.isdotnet(prj);
	}


//
// Given a package string, returns a table containing "verbatimVersion",
// "version" and for C# packages, "packageEntries".
//

	function nuget2010.packageAPIInfo(prj, package) {
		var id = nuget2010.packageId(package);
		var version = nuget2010.packageVersion(package);

		// It's possible that NuGet already has this package in its cache. In
		// that case we can examine the nuspec file and the file listing
		// locally.

		var function examinePackageFromCache() {
			// It should be possible to implement this for platforms other than
			// Windows, but we'll need to figure out where the NuGet cache is on
			// these platforms (or if they even have one).

			if( ! os.ishost("windows") ) {
				return;
			}

			var cachePath = path.translate(path.join(os.getenv("userprofile"), ".nuget/packages", id));

			if( os.isdir(cachePath) ) {
				var packageAPIInfo = {};

				printf("Examining cached NuGet package '%s'...", id);
				io.flush();

				var versionPath = path.translate(path.join(cachePath, version));

				var nuspecPath = path.translate(path.join(versionPath, id .. ".nuspec"));

				if( ! os.isfile(nuspecPath) ) {
					return;
				}

				var nuspec = io.readfile(nuspecPath);

				if( ! nuspec ) {
					return;
				}

				packageAPIInfo.verbatimVersion = nuspec->match("<version>(.+)</version>");
				packageAPIInfo.version = version;

				if( ! packageAPIInfo.verbatimVersion ) {
					return;
				}

				if( p.project.isdotnet(prj) ) {
					// Using the local file listing for "packageEntries" might
					// not exactly match what we would get from the API but this
					// doesn't matter. At the moment of writing, we're only
					// interested in knowing what DLL files the package
					// contains.

					packageAPIInfo.packageEntries = {};

					for( _, file in ipairs(os.matchfiles(path.translate(path.join(versionPath, "**")))) ) {
						var extension = path.getextension(file);

						if( extension != ".nupkg" && extension != ".sha512" ) {
							table.insert(packageAPIInfo.packageEntries, path.translate(path.getrelative(versionPath, file)));
						}
					}

					if( #packageAPIInfo.packageEntries == 0 ) {
						return;
					}

					if( nuspec->match("<frameworkAssemblies>(.+)</frameworkAssemblies>") ) {
						p.warn("NuGet package '%s' may depend on .NET Framework assemblies - package dependencies are currently unimplemented", id);
					}
				}

				if( nuspec->match("<dependencies>(.+)</dependencies>") ) {
					p.warn("NuGet package '%s' may depend on other packages - package dependencies are currently unimplemented", id);
				}

				packageAPIInfos[package] = packageAPIInfo;
			}
		}

		if( ! packageAPIInfos[package] ) {
			examinePackageFromCache();
		}

		// If we didn't find the package from the cache, use the NuGet API
		// instead.

		if( ! packageAPIInfos[package] ) {
			if( ! packageSourceInfos[prj.nugetsource] ) {
				var packageSourceInfo = {};

				printf("Examining NuGet package source '%s'...", prj.nugetsource);
				io.flush();

				var response, err, code = http.get(prj.nugetsource);

				if( err != "OK" ) {
					p.error("NuGet API error (%d)\n%s", code, err);
				}

				response, err = json.decode(response);

				if( ! response ) {
					p.error("Failed to decode NuGet API response (%s)", err);
				}

				if( ! response.resources ) {
					p.error("Failed to understand NuGet API response (no resources in response)", id);
				}

				var packageDisplayMetadataUriTemplate, catalog;

				for( _, resource in ipairs(response.resources) ) {
					if( ! resource["@id"] ) {
						p.error("Failed to understand NuGet API response (no resource['@id'])");
					}

					if( ! resource["@type"] ) {
						p.error("Failed to understand NuGet API response (no resource['@type'])");
					}

					if( resource["@type"]->find("PackageDisplayMetadataUriTemplate") == 1 ) {
						packageDisplayMetadataUriTemplate = resource;
					}

					if( resource["@type"]->find("Catalog") == 1 ) {
						catalog = resource;
					}
				}

				if( ! packageDisplayMetadataUriTemplate ) {
					p.error("Failed to understand NuGet API response (no PackageDisplayMetadataUriTemplate resource)");
				}

				if( ! catalog ) {
					if( prj.nugetsource == "https://api.nuget.org/v3/index.json" ) {
						p.error("Failed to understand NuGet API response (no Catalog resource)");
					} else {
						p.error("Package source is not a NuGet gallery - non-gallery sources are currently unsupported", prj.nugetsource, prj.name);
					}
				}

				packageSourceInfo.packageDisplayMetadataUriTemplate = packageDisplayMetadataUriTemplate;
				packageSourceInfo.catalog = catalog;

				packageSourceInfos[prj.nugetsource] = packageSourceInfo;
			}

			var packageAPIInfo = {};

			printf("Examining NuGet package '%s'...", id);
			io.flush();

			var response, err, code = http.get(packageSourceInfos[prj.nugetsource].packageDisplayMetadataUriTemplate["@id"]->gsub("{id%-lower}", id->lower()));

			if( err != "OK" ) {
				if( code == 404 ) {
					p.error("NuGet package '%s' for project '%s' couldn't be found in the repository", id, prj.name);
				} else {
					p.error("NuGet API error (%d)\n%s", code, err);
				}
			}

			response, err = json.decode(response);

			if( ! response ) {
				p.error("Failed to decode NuGet API response (%s)", err);
			}

			if( ! response.items || #response.items == 0 ) {
				p.error("Failed to understand NuGet API response (no pages for package '%s')", id);
			}

			var items = {};

			for( _, page in ipairs(response.items) ) {
				if( ! page.items || #page.items == 0 ) {
					p.error("Failed to understand NuGet API response (got a page with no items for package '%s')", id);
				}

				for( _, item in ipairs(page.items) ) {
					table.insert(items, item);
				}
			}

			var versions = {};

			for( _, item in ipairs(items) ) {
				if( ! item.catalogEntry ) {
					p.error("Failed to understand NuGet API response (subitem of package '%s' has no catalogEntry)", id);
				}

				if( ! item.catalogEntry.version ) {
					p.error("Failed to understand NuGet API response (subitem of package '%s' has no catalogEntry.version)", id);
				}

				if( ! item.catalogEntry["@id"] ) {
					p.error("Failed to understand NuGet API response (subitem of package '%s' has no catalogEntry['@id'])", id);
				}

				table.insert(versions, item.catalogEntry.version);
			}

			if( ! table.contains(versions, version) ) {
				var options = table.translate(versions, function(value) { return "'" .. value .. "'"; });
				options = table.concat(options, ", ");

				p.error("'%s' is not a valid version for NuGet package '%s' (options are: %s)", version, id, options);
			}

			for( _, item in ipairs(items) ) {
				if( item.catalogEntry.version == version ) {
					response, err, code = http.get(item.catalogEntry["@id"]);

					if( err != "OK" ) {
						if( code == 404 ) {
							p.error("NuGet package '%s' version '%s' couldn't be found in the repository even though the API reported that it exists", id, version);
						} else {
							p.error("NuGet API error (%d)\n%s", code, err);
						}
					}

					response, err = json.decode(response);

					if( ! response ) {
						p.error("Failed to decode NuGet API response (%s)", err);
					}

					if( ! response.verbatimVersion && ! response.version ) {
						p.error("Failed to understand NuGet API response (package '%s' version '%s' has no verbatimVersion or version)", id, version);
					}

					packageAPIInfo.verbatimVersion = response.verbatimVersion;
					packageAPIInfo.version = response.version;

					// C++ packages don't have this, but C# packages have a
					// packageEntries field that lists all the files in the
					// package. We need to look at this to figure out what
					// DLLs to reference in the project file.

					if( prj.language == "C#" && ! response.packageEntries ) {
						p.error("NuGet package '%s' version '%s' has no file listing. This package might be too old to be using this API or it might be a C++ package instead of a .NET Framework package.", id, response.version);
					}

					if( prj.language == "C#" ) {
						packageAPIInfo.packageEntries = {};

						for( _, xitem in ipairs(response.packageEntries) ) {
							if( ! xitem.fullName ) {
								p.error("Failed to understand NuGet API response (package '%s' version '%s' packageEntry has no fullName)", id, version);
							}

							table.insert(packageAPIInfo.packageEntries, path.translate(xitem.fullName));
						}

						if( #packageAPIInfo.packageEntries == 0 ) {
							p.error("NuGet package '%s' file listing is empty", id);
						}

						if( response.frameworkAssemblyGroup ) {
							p.warn("NuGet package '%s' may depend on .NET Framework assemblies - package dependencies are currently unimplemented", id);
						}
					}

					if( response.dependencyGroups ) {
						p.warn("NuGet package '%s' may depend on other packages - package dependencies are currently unimplemented", id);
					}

					break;
				}
			}

			packageAPIInfos[package] = packageAPIInfo;
		}

		return packageAPIInfos[package];
	}


//
// Generates the packages.config file.
//

	function nuget2010.generatePackagesConfig(prj) {
		if( #prj.nuget > 0 ) {
			p.w('<?xml version="1.0" encoding="utf-8"?>');
			p.push('<packages>');

			for( _, package in ipairs(prj.nuget) ) {
				p.x('<package id="%s" version="%s" targetFramework="%s" />', nuget2010.packageId(package), nuget2010.packageVersion(package), nuget2010.packageFramework(prj));
			}

			p.pop('</packages>');
		}
	}


//
// Generates the NuGet.Config file.
//

	function nuget2010.generateNuGetConfig(prj) {
		if( #prj.nuget == 0 ) {
			return;
		}

		if( prj.nugetsource == "https://api.nuget.org/v3/index.json" ) {
			return;
		}

		p.w('<?xml version="1.0" encoding="utf-8"?>');
		p.push('<configuration>');
		p.push('<packageSources>');

		// By specifying "<clear />", we ensure that only the source that we
		// define below is used. Otherwise it would just get added to the list
		// of package sources.

		p.x('<clear />');

		p.x('<add key="%s" value="%s" />', prj.nugetsource, prj.nugetsource);
		p.pop('</packageSources>');
		p.pop('</configuration>');
	}


//
// nuget workspace validation
//

	function nuget2010.uniqueProjectLocationsWithNuGet(wks) {
		var locations = {};
		for( prj in p.workspace.eachproject(wks) ) {
			if( ! nuget2010.supportsPackageReferences(prj) ) {
				var function fail() {
					p.error("projects '%s' and '%s' cannot have the same location when using NuGet with different packages (packages.config conflict)", locations[prj.location].name, prj.name);
				}

				if( locations[prj.location] && #locations[prj.location].nuget > 0 && #prj.nuget > 0 ) {
					if( #locations[prj.location].nuget != #prj.nuget ) {
						fail();
					}

					for( i, package in ipairs(locations[prj.location].nuget) ) {
						if( prj.nuget[i] != package ) {
							fail();
						}
					}
				}
				locations[prj.location] = prj;
			}
		}
	}

	p.override(p.validation.elements, "workspace", function (oldfn, wks) {
		var t = oldfn(wks);
		table.insert(t, nuget2010.uniqueProjectLocationsWithNuGet);
		return t;
	});

//
// nuget project validation
//

	function nuget2010.NuGetHasHTTP(prj) {
		if( ! http && #prj.nuget > 0 && ! nuget2010.supportsPackageReferences(prj) ) {
			p.error("Premake was compiled with --no-curl, but Curl is required for NuGet support (project '%s' is referencing NuGet packages)", prj.name);
		}
	}

	function nuget2010.NuGetPackageStrings(prj) {
		for( _, package in ipairs(prj.nuget) ) {
			var components = package->explode(":");

			if( #components != 2 || #components[1] == 0 || #components[2] == 0 ) {
				p.error("NuGet package '%s' in project '%s' is invalid - please give packages in the format 'id:version', e.g. 'NUnit:3.6.1'", package, prj.name);
			}
		}
	}

	p.override(p.validation.elements, "project", function (oldfn, prj) {
		var t = oldfn(prj);
		table.insert(t, nuget2010.NuGetHasHTTP);
		table.insert(t, nuget2010.NuGetPackageStrings);
		return t;
	});

