//-
// test_assertions.ljs
//
// Assertion functions for unit tests.
//
// Author Jason Perkins
// Copyright (c) 2008-2016 Jason Perkins and the Premake project.
//-

	var p = premake;

	var m = p.modules.self_test;

	var _ = {};



	function m.capture(expected) {
		var actual = p.captured() .. p.eol();

		// create line-by-line iterators for both values
		var ait = actual->gmatch("(.-)" .. p.eol());
		var eit = expected->gmatch("(.-)\n");

		// compare each value line by line
		var linenum = 1;
		var atxt = ait();
		var etxt = eit();
		while( etxt ) {
			if( (etxt != atxt) ) {
				m.fail("(%d) expected:\n%s\n...but was:\n%s\nfulltext:\n%s", linenum, etxt, atxt, actual);
			}

			++linenum    ;
			atxt = ait();
			etxt = eit();
		}
	}



	function m.closedfile(expected) {
		if( expected && ! m.value_closedfile ) {
			m.fail("expected file to be closed");
		} else if( ! expected && m.value_closedfile ) {
			m.fail("expected file to remain open");
		}
	}



	function m.contains(expected, actual) {
		if( type(expected) == "table" ) {
			for( i, v in ipairs(expected) ) {
				m.contains(v, actual);
			}
		} else if( ! table.contains(actual, expected) ) {
			m.fail("expected value %s not found", expected);
		}
	}



	function m.excludes(expected, actual) {
		if( type(expected) == "table" ) {
			for( i, v in ipairs(expected) ) {
				m.excludes(v, actual);
			}
		} else if( table.contains(actual, expected) ) {
			m.fail("excluded value %s found", expected);
		}
	}



	function m.fail(format, ...) {
		// if format is a number then it is the stack depth
		var depth = 3;
		var arg = {...};
		if( type(format) == "number" ) {
			depth +=   format;
			format = table.remove(arg, 1);
		}

		// convert nils into something more usefuls
		for( i = 1, #arg ) {
			if( (arg[i] == null) ) {
				arg[i] = "(nil)";
			} else if( (type(arg[i]) == "table") ) {
				arg[i] = "{" .. table.concat(arg[i], ", ") .. "}";
			}
		}

		var msg = string.format(format, table.unpack(arg));
		error(debug.traceback(msg, depth), depth);
	}



	function m.filecontains(expected, fn) {
		var f = io.open(fn);
		var actual = f->read("*a");
		f->close();
		if( (expected != actual) ) {
			m.fail("expected %s but was %s", expected, actual);
		}
	}



	function m.hasoutput() {
		var actual = p.captured();
		if( actual == "" ) {
			m.fail("expected output, received none");
		}
	}



	function m.isemptycapture() {
		var actual = p.captured();
		if( actual != "" ) {
			m.fail("expected empty capture, but was %s", actual);
		}
	}



	function m.isequal(expected, actual, depth) {
		depth = depth || 0;
		if( type(expected) == "table" ) {
			if( expected && ! actual ) {
				m.fail(depth, "expected table, got nil");
			}
			if( #expected < #actual ) {
				m.fail(depth, "expected %d items, got %d", #expected, #actual);
			}
			for( k,v in pairs(expected) ) {
				m.isequal(expected[k], actual[k], depth + 1);
			}
		} else {
			if( (expected != actual) ) {
				m.fail(depth, "expected %s but was %s", expected, actual || "null");
			}
		}
		return true;
	}



	function m.isfalse(value) {
		if( (value) ) {
			m.fail("expected false but was true");
		}
	}



	function m.isnil(value) {
		if( (value != null) ) {
			m.fail("expected nil but was " .. tostring(value));
		}
	}



	function m.isnotnil(value) {
		if( (value == null) ) {
			m.fail("expected not nil");
		}
	}



	function m.issame(expected, action) {
		if( expected != action ) {
			m.fail("expected same value");
		}
	}



	function m.istrue(value) {
		if( (! value) ) {
			m.fail("expected true but was false");
		}
	}



	function m.missing(value, actual) {
		if( table.contains(actual, value) ) {
			m.fail("unexpected value %s found", value);
		}
	}



	function m.openedfile(fname) {
		if( fname != m.value_openedfilename ) {
			var msg = "expected to open file '" .. fname .. "'";
			if( m.value_openedfilename ) {
				msg = msg .. ", got '" .. m.value_openedfilename .. "'";
			}
			m.fail(msg);
		}
	}



	function m.success(fn, ...) {
		var ok, err = pcall(fn, ...);
		if( ! ok ) {
			m.fail("call failed: " .. err);
		}
	}



	function m.stderr(expected) {
		if( ! expected && m.stderr_capture ) {
			m.fail("Unexpected: " .. m.stderr_capture);
		} else if( expected ) {
			if( ! m.stderr_capture || ! m.stderr_capture->find(expected) ) {
				m.fail(string.format("expected '%s'; got %s", expected, m.stderr_capture || "(nil)"));
			}
		}
	}



	function m.notstderr(expected) {
		if( ! expected && ! m.stderr_capture ) {
			m.fail("Expected output on stderr; none received");
		} else if( expected ) {
			if( m.stderr_capture && m.stderr_capture->find(expected) ) {
				m.fail(string.format("stderr contains '%s'; was %s", expected, m.stderr_capture));
			}
		}
	}
