//
// d/actions/gmake.ljs
// Define the D makefile action(s).
// Copyright (c) 2013-2015 Andrew Gough, Manu Evans, and the Premake project
//

	var p = premake;
	var m = p.modules.d;

	m.make = {};

	var dmake = m.make;

	require ("gmake");

	var make = p.make;
	var cpp = p.make.cpp;
	var project = p.project;
	var config = p.config;
	var fileconfig = p.fileconfig;

// This check may be unnecessary as we only 'require' this file from d.ljs
// IFF the action already exists, however this may help if this file is
// directly required, rather than d.ljs itself.
	var gmake = p.action.get( 'gmake' );
	if( gmake == null ) {
		error( "Failed to locate prequisite action 'gmake'" );
	}

//
// Patch the gmake action with the allowed tools...
//
	gmake.valid_languages = table.join(gmake.valid_languages, { p.D } );
	gmake.valid_tools.dc = { "dmd", "gdc", "ldc" };

	function m.make.separateCompilation(prj) {
		var some = false;
		var all = true;
		for( cfg in project.eachconfig(prj) ) {
			if( cfg.compilationmodel == "File" ) {
				some = true;
			} else {
				all = false;
			}
		}
		return (all ? "all" : (some ? "some" : "none"));
	}


//
// Override the GMake action 'onProject' funtion to provide
// D knowledge...
//
	p.override( gmake, "onProject", function(oldfn, prj) {
		p.escaper(make.esc);
		if( project.isd(prj) ) {
			var makefile = make.getmakefilename(prj, true);
			p.generate(prj, makefile, m.make.generate);
			return;
		}
		oldfn(prj);
	});

	p.override( make, "objdir", function(oldfn, cfg) {
		if( cfg.project.language != "D" || cfg.compilationmodel == "File" ) {
			oldfn(cfg);
		}
	});

	p.override( make, "objDirRules", function(oldfn, prj) {
		if( prj.language != "D" || m.make.separateCompilation(prj) != "none" ) {
			oldfn(prj);
		}
	});


//-
// Add namespace for element definition lists for p.callarray()
//-

	m.elements = {};

//
// Generate a GNU make C++ project makefile, with support for the new platforms API.
//

	m.elements.makefile = function(prj) {
		return {
			make.header,
			make.phonyRules,
			m.make.configs,
			m.make.objects,		// TODO: This is basically identical to make.cppObjects(), and should ideally be merged/shared
			make.shellType,
			m.make.targetRules,
			make.targetDirRules,
			make.objDirRules,
			make.cppCleanRules,	// D clean code is identical to C/C++
			make.preBuildRules,
			make.preLinkRules,
			m.make.dFileRules,
		};
	};

	function m.make.generate(prj) {
		p.callArray(m.elements.makefile, prj);
	}


	function m.make.buildRule(prj) {
		_p('$(TARGET): $(SOURCEFILES) $(LDDEPS)');
		_p('\t@echo Building %s', prj.name);
		_p('\t$(SILENT) $(BUILDCMD)');
		_p('\t$(POSTBUILDCMDS)');
	}

	function m.make.linkRule(prj) {
		_p('$(TARGET): $(OBJECTS) $(LDDEPS)');
		_p('\t@echo Linking %s', prj.name);
		_p('\t$(SILENT) $(LINKCMD)');
		_p('\t$(POSTBUILDCMDS)');
	}

	function m.make.targetRules(prj) {
		var separateCompilation = m.make.separateCompilation(prj);
		if( separateCompilation == "all" ) {
			m.make.linkRule(prj);
		} else if( separateCompilation == "none" ) {
			m.make.buildRule(prj);
		} else {
			for( cfg in project.eachconfig(prj) ) {
				_x('ifeq ($(config),%s)', cfg.shortname);
				if( cfg.compilationmodel == "File" ) {
					m.make.linkRule(prj);
				} else {
					m.make.buildRule(prj);
				}
				_p('endif');
			}
		}
		_p('');
	}

	function m.make.dFileRules(prj) {
		var separateCompilation = m.make.separateCompilation(prj);
		if( separateCompilation != "none" ) {
			make.cppFileRules(prj);
		}
	}

//
// Override the 'standard' file rule to support D source files
//

	p.override(cpp, "standardFileRules", function(oldfn, prj, node) {
		// D file
		if( path.isdfile(node.abspath) ) {
			_p('\t$(SILENT) $(DC) $(ALL_DFLAGS) $(OUTPUTFLAG) -c $<');
		} else {
			oldfn(prj, node);
		}
	});

//
// Let make know it can compile D source files
//

	p.override(make, "fileType", function(oldfn, node) {
		if( path.isdfile(node.abspath) ) {
			return "objects";
		} else {
			return oldfn(node);
		}
	});


//
// Write out the settings for a particular configuration.
//

	m.elements.makeconfig = function(cfg) {
		return {
			m.make.dTools,
			make.target,
			m.make.target,
			make.objdir,
			m.make.versions,
			m.make.debug,
			m.make.imports,
			m.make.stringImports,
			m.make.dFlags,
			make.libs,
			make.ldDeps,
			make.ldFlags,
			m.make.linkCmd,
			make.preBuildCmds,
			make.preLinkCmds,
			make.postBuildCmds,
			m.make.allRules,
			make.settings,
		};
	};

	function m.make.configs(prj) {
		for( cfg in project.eachconfig(prj) ) {
			// identify the toolset used by this configurations (would be nicer if
			// this were computed and stored with the configuration up front)

			var toolset = p.tools[_OPTIONS.dc || cfg.toolset || "dmd"];
			if( ! toolset ) {
				error("Invalid toolset '" + (_OPTIONS.dc || cfg.toolset) + "'");
			}

			_x('ifeq ($(config),%s)', cfg.shortname);
			p.callArray(m.elements.makeconfig, cfg, toolset);
			_p('endif');
			_p('');
		}
	}

	function m.make.dTools(cfg, toolset) {
		var tool = toolset.gettoolname(cfg, "dc");
		if( tool ) {
			_p('  DC = %s', tool);
		}
	}

	function m.make.target(cfg, toolset) {
		if( cfg.compilationmodel == "File" ) {
			_p('  OUTPUTFLAG = %s', toolset.gettarget('"$@"'));
		}
	}

	function m.make.versions(cfg, toolset) {
		_p('  VERSIONS +=%s', make.list(toolset.getversions(cfg.versionconstants, cfg.versionlevel)));
	}

	function m.make.debug(cfg, toolset) {
		_p('  DEBUG +=%s', make.list(toolset.getdebug(cfg.debugconstants, cfg.debuglevel)));
	}

	function m.make.imports(cfg, toolset) {
		var imports = p.esc(toolset.getimportdirs(cfg, cfg.importdirs));
		_p('  IMPORTS +=%s', make.list(imports));
	}

	function m.make.stringImports(cfg, toolset) {
		var stringImports = p.esc(toolset.getstringimportdirs(cfg, cfg.stringimportdirs));
		_p('  STRINGIMPORTS +=%s', make.list(stringImports));
	}

	function m.make.dFlags(cfg, toolset) {
		_p('  ALL_DFLAGS += $(DFLAGS)%s $(VERSIONS) $(DEBUG) $(IMPORTS) $(STRINGIMPORTS) $(ARCH)', make.list(table.join(toolset.getdflags(cfg), cfg.buildoptions)));
	}

	function m.make.linkCmd(cfg, toolset) {
		if( cfg.compilationmodel == "File" ) {
			_p('  LINKCMD = $(DC) ' .. toolset.gettarget("$(TARGET)") .. ' $(ALL_LDFLAGS) $(LIBS) $(OBJECTS)');

//			local cc = (p.languages.isc(cfg.language) ? "CC" : "CXX")
//			_p('  LINKCMD = $(%s) -o $(TARGET) $(OBJECTS) $(RESOURCES) $(ARCH) $(ALL_LDFLAGS) $(LIBS)', cc)
		} else {
			_p('  BUILDCMD = $(DC) ' .. toolset.gettarget("$(TARGET)") .. ' $(ALL_DFLAGS) $(ALL_LDFLAGS) $(LIBS) $(SOURCEFILES)');
		}
	}

	function m.make.allRules(cfg, toolset) {
		// TODO: The C++ version has some special cases for OSX and Windows... check whether they should be here too?
		if( cfg.compilationmodel == "File" ) {
			_p('all: $(TARGETDIR) $(OBJDIR) prebuild prelink $(TARGET)');
		} else {
			_p('all: $(TARGETDIR) prebuild prelink $(TARGET)');
		}
		_p('\t@:');
//		_p('')
	}


//
// List the objects file for the project, and each configuration.
//

// TODO: This is basically identical to make.cppObjects(), and should ideally be merged/shared

	function m.make.objects(prj) {
		// create lists for intermediate files, at the project level and
		// for each configuration
		var root = { sourcefiles={}, objects={} };
		var configs = {};
		for( cfg in project.eachconfig(prj) ) {
			configs[cfg] = { sourcefiles={}, objects={} };
		}

		// now walk the list of files in the project
		var tr = project.getsourcetree(prj);
		p.tree.traverse(tr, {
			onleaf = function(node, depth) {
				// figure out what configurations contain this file, and
				// if it uses custom build rules
				var incfg = {};
				var inall = true;
				var custom = false;
				for( cfg in project.eachconfig(prj) ) {
					var filecfg = fileconfig.getconfig(node, cfg);
					if( filecfg && ! filecfg.flags.ExcludeFromBuild ) {
						incfg[cfg] = filecfg;
						custom = fileconfig.hasCustomBuildRule(filecfg);
					} else {
						inall = false;
					}
				}

				if( ! custom ) {
					// skip files that aren't compiled
					if( ! path.isdfile(node.abspath) ) {
						return;
					}

					var sourcename = node.relpath;

					// TODO: assign a unique object file name to avoid collisions
					var objectname = "$(OBJDIR)/" .. node.objname .. ".o";

					// if this file exists in all configurations, write it to
					// the project's list of files, else add to specific cfgs
					if( inall ) {
						table.insert(root.sourcefiles, sourcename);
						table.insert(root.objects, objectname);
					} else {
						for( cfg in project.eachconfig(prj) ) {
							if( incfg[cfg] ) {
								table.insert(configs[cfg].sourcefiles, sourcename);
								table.insert(configs[cfg].objects, objectname);
							}
						}
					}

				} else {
					for( cfg in project.eachconfig(prj) ) {
						var filecfg = incfg[cfg];
						if( filecfg ) {
							// if the custom build outputs an object file, add it to
							// the link step automatically to match Visual Studio
							var output = project.getrelative(prj, filecfg.buildoutputs[1]);
							if( path.isobjectfile(output) ) {
								table.insert(configs[cfg].objects, output);
							}
						}
					}
				}

			}
		});

		var separateCompilation = m.make.separateCompilation(prj);

		// now I can write out the lists, project level first...
		var function listobjects(_v_var, list) {
			_p('%s \\', _v_var);
			for( _, objectname in ipairs(list) ) {
				_x('\t%s \\', objectname);
			}
			_p('');
		}

		if( separateCompilation != "all" ) {
			listobjects('SOURCEFILES :=', root.sourcefiles);
		}
		if( separateCompilation != "none" ) {
			listobjects('OBJECTS :=', root.objects, 'o');
		}

		// ...then individual configurations, as needed
		for( cfg in project.eachconfig(prj) ) {
			var files = configs[cfg];
			if( (#files.sourcefiles > 0 && separateCompilation != "all") || (#files.objects > 0 && separateCompilation != "none") ) {
				_x('ifeq ($(config),%s)', cfg.shortname);
				if( #files.sourcefiles > 0 && separateCompilation != "all" ) {
					listobjects('  SOURCEFILES +=', files.sourcefiles);
				}
				if( #files.objects > 0 && separateCompilation != "none" ) {
					listobjects('  OBJECTS +=', files.objects);
				}
				_p('endif');
			}
		}
		_p('');
	}
