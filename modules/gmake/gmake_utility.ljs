//
// make_utility.ljs
// Generate a C/C++ project makefile.
// Copyright (c) 2002-2014 Jason Perkins and the Premake project
//

	var p = premake;
	p.make.utility = {};

	var make       = p.make;
	var utility    = p.make.utility;
	var project    = p.project;
	var config     = p.config;
	var fileconfig = p.fileconfig;

//-
// Add namespace for element definition lists for p.callarray()
//-
	utility.elements = {};

//
// Generate a GNU make utility project makefile.
//

	utility.elements.makefile = {
		"header",
		"phonyRules",
		"utilityConfigs",
		"utilityTargetRules"
	};

	function make.utility.generate(prj) {
		p.eol("\n");
		p.callarray(make, utility.elements.makefile, prj);
	}


	utility.elements.configuration = {
		"target",
		"preBuildCmds",
		"postBuildCmds",
	};

	function make.utilityConfigs(prj) {
		for( cfg in project.eachconfig(prj) ) {
			// identify the toolset used by this configurations (would be nicer if
			// this were computed and stored with the configuration up front)

			var toolset = p.tools[cfg.toolset || "gcc"];
			if( ! toolset ) {
				error("Invalid toolset '" .. cfg.toolset .. "'");
			}

			_x('ifeq ($(config),%s)', cfg.shortname);
			p.callarray(make, utility.elements.configuration, cfg, toolset);
			_p('endif');
			_p('');
		}
	}

	function make.utilityTargetRules(prj) {
		_p('$(TARGET):');
		_p('\t$(PREBUILDCMDS)');
		_p('\t$(POSTBUILDCMDS)');
		_p('');
	}

