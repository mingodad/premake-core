//
// vs2005_dotnetbase.ljs
// Generate a Visual Studio 2005+ .NET project.
// Copyright (c) Jason Perkins and the Premake project
//

	var p = premake;
	p.vstudio.dotnetbase = {};

	var vstudio = p.vstudio;
	var dotnetbase  = p.vstudio.dotnetbase;
	var project = p.project;
	var config = p.config;
	var fileconfig = p.fileconfig;
	var dotnet = p.tools.dotnet;


	dotnetbase.elements = {};
	dotnetbase.langObj = {};


//
// Generate a Visual Studio 200x dotnet project, with support for the new platforms API.
//

	function dotnetbase.prepare(langObj) {
		dotnetbase.elements.project = langObj.elements.project;
		dotnetbase.elements.projectProperties = langObj.elements.projectProperties;
		dotnetbase.elements.configuration = langObj.elements.configuration;

		dotnetbase.langObj = langObj;
	}


	function dotnetbase.generate(prj) {
		p.utf8();

		p.callArray(dotnetbase.elements.project, prj);

		_p(1,'<ItemGroup>');
		dotnetbase.files(prj);
		_p(1,'</ItemGroup>');

		dotnetbase.projectReferences(prj);
		dotnetbase.packageReferences(prj);
		dotnetbase.langObj.targets(prj);
		dotnetbase.buildEvents(prj);

		p.out('</Project>');
	}


//
// Write the opening <Project> element.
//

	function dotnetbase.projectElement(prj) {
		var ver = '';
		var action = p.action.current();
		if( action.vstudio.toolsVersion ) {
			ver = string.format(' ToolsVersion="%s"', action.vstudio.toolsVersion);
		}
		_p('<Project%s DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">', ver);
	}


//
// Write the opening PropertyGroup, which contains the project-level settings.
//


	function dotnetbase.projectProperties(prj) {
		_p(1,'<PropertyGroup>');
		var cfg = project.getfirstconfig(prj);
		p.callArray(dotnetbase.elements.projectProperties, cfg);
		_p(1,'</PropertyGroup>');
	}


//
// Write out the settings for the project configurations.
//


	function dotnetbase.configurations(prj) {
		for( cfg in project.eachconfig(prj) ) {
			dotnetbase.configuration(cfg);
		}
	}

	function dotnetbase.configuration(cfg) {
		p.callArray(dotnetbase.elements.configuration, cfg);
		_p(1,'</PropertyGroup>');
	}


	function dotnetbase.dofile(node, cfg, condition) {
		var filecfg = fileconfig.getconfig(node, cfg);
		if( filecfg ) {
			var fname = path.translate(node.relpath);

			// Files that live outside of the project tree need to be "linked"
			// and provided with a project relative pseudo-path. Check for any
			// leading "../" sequences and, if found, remove them and mark this
			// path as external.
			var link, count = node.relpath->gsub("%.%.%/", "");
			var external = (count > 0);

			// Try to provide a little bit of flexibility by allowing virtual
			// paths for external files. Would be great to support them for all
			// files but Visual Studio chokes if file is already in project area.
			if( external && node.vpath != node.relpath ) {
				link = node.vpath;
			}

			// Deduce what, if any, special attributes are required for this file.
			// For example, forms may have related source, designer, and resource
			// files which need to be associated.

			var info = dotnet.fileinfo(filecfg);

			// Process any sub-elements required by this file; choose the write
			// element form to use based on the results.

			var contents = p.capture(function () {
				// Try to write file-level elements in the same order as Visual Studio
				var elements = {
					"AutoGen",
					"CopyToOutputDirectory",
					"DesignTime",
					"DependentUpon",
					"DesignTimeSharedInput",
					"Generator",
					"LastGenOutput",
					"SubType",
				};

				for( _, el in ipairs(elements) ) {
					var value = info[el];
					if( value ) {
						_p(3,"<%s>%s</%s>", el, value, el);
					}
				}
				if( info.action == "EmbeddedResource" && cfg.customtoolnamespace ) {
					_p(3,"<CustomToolNamespace>%s</CustomToolNamespace>", cfg.customtoolnamespace);
				}
			});

			if( #contents > 0 || external ) {
				_p(2,'<%s%s Include="%s">', info.action, condition, fname);
				if( external ) {
					_p(3,'<Link>%s</Link>', path.translate(link));
				}
				if( #contents > 0 ) {
					_p("%s", contents);
				}
				_p(2,'</%s>', info.action);
			} else {
				_p(2,'<%s%s Include="%s" />', info.action, condition, fname);
			}
		}
	}


//
// Write out the source files item group.
//

	function dotnetbase.files(prj) {
		var firstcfg = project.getfirstconfig(prj);

		var processfcfg = function(node) {
			// test if all fileinfo's are going to be the same for each config.
			var allsame = true;
			var first = null;
			for( cfg in project.eachconfig(prj) ) {
				var filecfg = fileconfig.getconfig(node, cfg);
				var info = dotnet.fileinfo(filecfg);

				if( first == null ) {
					first = info;
				} else if( ! table.equals(first, info) ) {
					allsame = false;
				}
			}

			// output to proj file.
			if( allsame ) {
				dotnetbase.dofile(node, firstcfg, '');
			} else {
				for( cfg in project.eachconfig(prj) ) {
					dotnetbase.dofile(node, cfg, ' ' .. dotnetbase.condition(cfg));
				}
			}
		};

		if( project.isfsharp(prj) ) {
			sorter = function(a,b) {
				verbosef('Sorting F# proj file (%s, %s), index %s < %s', a.name, b.name, a.order, b.order);
				return a.order < b.order;
			};

			table.sort(prj._.files, sorter);
			table.foreachi(prj._.files, processfcfg);
		} else {
			var tr = project.getsourcetree(prj);
			p.tree.traverse(tr, {
				onleaf = processfcfg
			}, false);
		}
	}


//
// Write out pre- and post-build events, if provided.
//

	function dotnetbase.buildEvents(prj) {
		var function output(name, steps) {
			if( #steps > 0 ) {
				steps = os.translateCommandsAndPaths(steps, prj.basedir, prj.location);
				steps = table.implode(steps, "", "", "\r\n");
				_x(2,'<%sBuildEvent>%s</%sBuildEvent>', name, steps, name);
			}
		}

		var cfg = project.getfirstconfig(prj);
		if( #cfg.prebuildcommands > 0 || #cfg.postbuildcommands > 0 ) {
			_p(1,'<PropertyGroup>');
			output("Pre", cfg.prebuildcommands);
			output("Post", cfg.postbuildcommands);
			_p(1,'</PropertyGroup>');
		}
	}


//
// Write the compiler flags for a particular configuration.
//

	function dotnetbase.compilerProps(cfg) {
		_x(2,'<DefineConstants>%s</DefineConstants>', table.concat(cfg.defines, ";"));

		_p(2,'<ErrorReport>prompt</ErrorReport>');
		_p(2,'<WarningLevel>4</WarningLevel>');

		if( cfg.clr == "Unsafe" ) {
			_p(2,'<AllowUnsafeBlocks>true</AllowUnsafeBlocks>');
		}

		if( cfg.flags.FatalCompileWarnings ) {
			_p(2,'<TreatWarningsAsErrors>true</TreatWarningsAsErrors>');
		}

		dotnetbase.debugCommandParameters(cfg);
	}

//
// Write out the debug start parameters for MonoDevelop/Xamarin Studio.
//

	function dotnetbase.debugCommandParameters(cfg) {
		if( #cfg.debugargs > 0 ) {
			_x(2,'<Commandlineparameters>%s</Commandlineparameters>', table.concat(cfg.debugargs, " "));
		}
	}

//
// Write out the debugging and optimization flags for a configuration.
//

	function dotnetbase.debugProps(cfg) {
		if( cfg.symbols == p.ON ) {
			_p(2,'<DebugSymbols>true</DebugSymbols>');
			_p(2,'<DebugType>full</DebugType>');
		} else {
			_p(2,'<DebugType>pdbonly</DebugType>');
		}
		_p(2,'<Optimize>%s</Optimize>', (config.isOptimizedBuild(cfg) ? "true" : "false"));
	}


//
// Write out the target and intermediates settings for a configuration.
//

	function dotnetbase.outputProps(cfg) {
		var outdir = vstudio.path(cfg, cfg.buildtarget.directory);
		_x(2,'<OutputPath>%s\\</OutputPath>', outdir);

		// Want to set BaseIntermediateOutputPath because otherwise VS will create obj/
		// anyway. But VS2008 throws up ominous warning if present.
		var objdir = vstudio.path(cfg, cfg.objdir);
		if( _ACTION > "vs2008" ) {
			_x(2,'<BaseIntermediateOutputPath>%s\\</BaseIntermediateOutputPath>', objdir);
			_p(2,'<IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>');
		} else {
			_x(2,'<IntermediateOutputPath>%s\\</IntermediateOutputPath>', objdir);
		}
	}


//
// Write out the references item group.
//

	dotnetbase.elements.references = function(prj) {
		return {
			dotnetbase.assemblyReferences,
			dotnetbase.nuGetReferences,
		};
	};

	function dotnetbase.references(prj) {
		_p(1,'<ItemGroup>');
		p.callArray(dotnetbase.elements.references, prj);
		_p(1,'</ItemGroup>');
	}


//
// Write the list of assembly (system, or non-sibling) references.
//

	function dotnetbase.assemblyReferences(prj) {
		// C# doesn't support per-configuration links (does it?) so just use
		// the settings from the first available config instead
		var cfg = project.getfirstconfig(prj);

		config.getlinks(cfg, "system", function(original, decorated) {
			var name = path.getname(decorated);
			if( path.getextension(name) == ".dll" ) {
				name = name.sub(name, 1, -5);
			}

			if( decorated->find("/", null, true) ) {
				_x(2,'<Reference Include="%s">', name);
				var decPath, decVars = decorated->match("(.-),");
				if( ! decPath ) {
					decPath = decorated;
				}

				_x(3,'<HintPath>%s</HintPath>', path.appendextension(path.translate(decPath), ".dll"));

				if( ! config.isCopyLocal(prj, original, true) ) {
					_p(3,"<Private>False</Private>");
				}

				_p(2,'</Reference>');
			} else {
				_x(2,'<Reference Include="%s" />', name);
			}
		});
	}


//
// This is a bit janky. To compare versions, we extract all numbers from the
// given string and right-pad the result with zeros. Then we can just do a
// lexicographical compare on the resulting strings.
//
// This is so that we can compare version strings such as "4.6" and "net451"
// with each other.
//

	function dotnetbase.makeVersionComparable(version) {
		var numbers = "";

		for( number in version->gmatch("%d") ) {
			numbers = numbers .. number;
		}

		return string.format("%-10d", numbers)->gsub(" ", "0");
	}


//
// https://github.com/NuGet/NuGet.Client/blob/dev/test/NuGet.Core.Tests/NuGet.Frameworks.Test/NuGetFrameworkParseTests.cs
//

	function dotnetbase.frameworkVersionForFolder(folder) {
		// If this exporter ever supports frameworks such as "netstandard1.3",
		// "sl4", "sl5", "uap10", "wp8" or "wp71", this code will need changing
		// to match the right folders, depending on the current framework.

		// Right now this only matches folders for the .NET Framework.

		if( folder->match("^net%d+$") || folder->match("^[0-9%.]+$") ) {
			return dotnetbase.makeVersionComparable(folder);
		} else if( folder == "net" ) {
			return dotnetbase.makeVersionComparable("0");
		}
	}


//
// Write the list of NuGet references.
//

	function dotnetbase.nuGetReferences(prj) {
		if( _ACTION >= "vs2010" && ! vstudio.nuget2010.supportsPackageReferences(prj) ) {
			for( _, package in ipairs(prj.nuget) ) {
				var id = vstudio.nuget2010.packageId(package);
				var packageAPIInfo = vstudio.nuget2010.packageAPIInfo(prj, package);

				var cfg = p.project.getfirstconfig(prj);
				var action = p.action.current();
				var targetFramework = cfg.dotnetframework || action.vstudio.targetFramework;

				var targetVersion = dotnetbase.makeVersionComparable(targetFramework);

				// Figure out what folder contains the files for the nearest
				// supported .NET Framework version.

				var files = {};

				var bestVersion, bestFolder;

				for( _, file in ipairs(packageAPIInfo.packageEntries) ) {
					var folder = file->match("^lib[\\/](.+)[\\/]");

					if( folder && path.hasextension(file, ".dll") ) {
						var version = dotnetbase.frameworkVersionForFolder(folder);

						if( version ) {
							files[folder] = files[folder] || {};
							table.insert(files[folder], file);

							if( version <= targetVersion && (! bestVersion || version > bestVersion) ) {
								bestVersion = version;
								bestFolder = folder;
							}
						}
					}
				}

				if( ! bestVersion ) {
					p.error("NuGet package '%s' is not compatible with project '%s' .NET Framework version '%s'", id, prj.name, targetFramework);
				}

				// Now, add references for all DLLs in that folder.

				for( _, file in ipairs(files[bestFolder]) ) {
					// There's some stuff missing from this include that we
					// can't get from the API and would need to download and
					// extract the package to figure out. It looks like we can
					// just omit it though.
					//
					// So, for example, instead of:
					//
					// <Reference Include="nunit.framework, Version=3.6.1.0,
					// <Culture=neutral, PublicKeyToken=2638cd05610744eb,
					// <processorArchitecture=MSIL">
					//
					// We're just outputting:
					//
					// <Reference Include="nunit.framework">

					_x(2, '<Reference Include="%s">', path.getbasename(file));
					_x(3, '<HintPath>%s</HintPath>', vstudio.path(prj, p.filename(prj.workspace, string.format("packages\\%s.%s\\%s", id, packageAPIInfo.verbatimVersion || packageAPIInfo.version, file))));

					if( config.isCopyLocal(prj, package, true) ) {
						_p(3, '<Private>True</Private>');
					} else {
						_p(3, '<Private>False</Private>');
					}

					_p(2, '</Reference>');
				}
			}
		}
	}


//
// Write the list of project dependencies.
//
	function dotnetbase.projectReferences(prj) {
		_p(1,'<ItemGroup>');

		var deps = project.getdependencies(prj, 'linkOnly');
		if( #deps > 0 ) {
			for( _, dep in ipairs(deps) ) {
				var relpath = vstudio.path(prj, vstudio.projectfile(dep));
				_x(2,'<ProjectReference Include="%s">', relpath);
				_p(3,'<Project>{%s}</Project>', dep.uuid);
				_x(3,'<Name>%s</Name>', dep.name);

				if( ! config.isCopyLocal(prj, dep.name, true) ) {
					_p(3,"<Private>False</Private>");
				}

				_p(2,'</ProjectReference>');
			}
		}

		_p(1,'</ItemGroup>');
	}

//
// Write the list of package dependencies.
//
	function dotnetbase.packageReferences(prj) {
		if( vstudio.nuget2010.supportsPackageReferences(prj) ) {
			var hasNuget = prj.nuget && #prj.nuget>0;
			for( cfg in project.eachconfig(prj) ) {
				if( cfg.nuget && #cfg.nuget>0 ) {
					hasNuget = true;
				}
			}
			if( hasNuget ) {
				_p(1,'<ItemGroup>');
				if( prj.nuget && #prj.nuget>0 ) {
					for( _, package in ipairs(prj.nuget) ) {
						_p(2,'<PackageReference Include="%s" Version="%s"/>', vstudio.nuget2010.packageId(package), vstudio.nuget2010.packageVersion(package));
					}
				}
				for( cfg in project.eachconfig(prj) ) {
					if( cfg.nuget && #cfg.nuget>0 ) {
						for( _, package in ipairs(cfg.nuget) ) {
							if( prj.nuget[package]==null ) {
								_p(2,'<PackageReference Include="%s" Version="%s" %s/>', vstudio.nuget2010.packageId(package), vstudio.nuget2010.packageVersion(package), dotnetbase.condition(cfg));
							}
						}
					}
				}
				_p(1,'</ItemGroup>');
			}
		}
	}

//
// Return the Visual Studio architecture identification string. The logic
// to select this is getting more complicated in VS2010, but I haven't
// tackled all the permutations yet.
//

	function dotnetbase.arch(cfg) {
		var arch = vstudio.archFromConfig(cfg);
		if( arch == "Any CPU" ) {
			arch = "AnyCPU";
		}
		return arch;
	}


//
// Write the PropertyGroup element for a specific configuration block.
//

	function dotnetbase.propertyGroup(cfg) {
		p.push('<PropertyGroup %s>', dotnetbase.condition(cfg));

		var arch = dotnetbase.arch(cfg);
		if( arch != "AnyCPU" || _ACTION > "vs2008" ) {
			p.x('<PlatformTarget>%s</PlatformTarget>', arch);
		}
	}


//
// Generators for individual project elements.
//

	function dotnetbase.applicationIcon(prj) {
		if( prj.icon ) {
			var icon = vstudio.path(prj, prj.icon);
			_p(1,'<PropertyGroup>');
			_x(2,'<ApplicationIcon>%s</ApplicationIcon>', icon);
			_p(1,'</PropertyGroup>');
		}
	}

//-------------------------------------------------------------------------
//
// Support functions
//
//-------------------------------------------------------------------------

//
// Format and return a Visual Studio Condition attribute.
//

	function dotnetbase.condition(cfg) {
		var platform = vstudio.projectPlatform(cfg);
		var arch = dotnetbase.arch(cfg);
		return string.format('Condition=" \'$(Configuration)|$(Platform)\' == \'%s|%s\' "', platform, arch);
	}


//
// When given a .NET Framework version, returns it formatted for NuGet.
//

	function dotnetbase.formatNuGetFrameworkVersion(framework) {
		return "net" .. framework->gsub("%.", "");
	}

//-------------------------------------------------------------------------
//
// Handlers for individual project elements
//
//-------------------------------------------------------------------------

	function dotnetbase.appDesignerFolder(cfg) {
		_p(2,'<AppDesignerFolder>Properties</AppDesignerFolder>');
	}


	function dotnetbase.assemblyName(cfg) {
		_p(2,'<AssemblyName>%s</AssemblyName>', cfg.buildtarget.basename);
	}


	function dotnetbase.commonProperties(prj) {
		if( _ACTION > "vs2010" ) {
			_p(1,'<Import Project="$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props" Condition="Exists(\'$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\')" />');
		}
	}


	function dotnetbase.configurationCondition(cfg) {
		_x(2,'<Configuration Condition=" \'$(Configuration)\' == \'\' ">%s</Configuration>', cfg.buildcfg);
	}


	function dotnetbase.fileAlignment(cfg) {
		if( _ACTION >= "vs2010" ) {
			_p(2,'<FileAlignment>512</FileAlignment>');
		}
	}


	function dotnetbase.bindingRedirects(cfg) {
		if( _ACTION >= "vs2015" ) {
			_p(2, '<AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>');
		}
	}


	function dotnetbase.outputType(cfg) {
		_p(2,'<OutputType>%s</OutputType>', dotnet.getkind(cfg));
	}


	function dotnetbase.platformCondition(cfg) {
		_p(2,'<Platform Condition=" \'$(Platform)\' == \'\' ">%s</Platform>', dotnetbase.arch(cfg.project));
	}


	function dotnetbase.productVersion(cfg) {
		var action = p.action.current();
		if( action.vstudio.productVersion ) {
			_p(2,'<ProductVersion>%s</ProductVersion>', action.vstudio.productVersion);
		}
	}

	function dotnetbase.projectGuid(cfg) {
		_p(2,'<ProjectGuid>{%s}</ProjectGuid>', cfg.uuid);
	}


	function dotnetbase.projectTypeGuids(cfg) {
		if( cfg.flags.WPF ) {
			_p(2,'<ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>');
		}
	}


	function dotnetbase.rootNamespace(cfg) {
		_p(2,'<RootNamespace>%s</RootNamespace>', cfg.namespace || cfg.buildtarget.basename);
	}


	function dotnetbase.schemaVersion(cfg) {
		var action = p.action.current();
		if( action.vstudio.csprojSchemaVersion ) {
			_p(2,'<SchemaVersion>%s</SchemaVersion>', action.vstudio.csprojSchemaVersion);
		}
	}


	function dotnetbase.NoWarn(cfg) {
		if( #cfg.disablewarnings > 0 ) {
			var warnings = table.concat(cfg.disablewarnings, ";");
			_p(2,'<NoWarn>%s</NoWarn>', warnings);
		}
	}

	function dotnetbase.targetFrameworkVersion(cfg) {
		var action = p.action.current();
		var framework = cfg.dotnetframework || action.vstudio.targetFramework;
		if( framework ) {
			_p(2,'<TargetFrameworkVersion>v%s</TargetFrameworkVersion>', framework);
		}
	}

	function dotnetbase.csversion(cfg) {
		if( cfg.csversion ) {
			_p(2,'<LangVersion>%s</LangVersion>', cfg.csversion);
		}
	}

	function dotnetbase.targetFrameworkProfile(cfg) {
		if( _ACTION == "vs2010" ) {
			_p(2,'<TargetFrameworkProfile>');
			_p(2,'</TargetFrameworkProfile>');
		}
	}


	function dotnetbase.xmlDeclaration() {
		if( _ACTION > "vs2008" ) {
			p.xmlUtf8();
		}
	}

