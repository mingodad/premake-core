//-
// action.ljs
// Work with the list of registered actions.
// Copyright (c) 2002-2015 Jason Perkins and the Premake project
//-

	var p = premake;
	p.action = {};

	var action = p.action;



//
// Process the raw command line arguments from _ARGV to populate
// the _ACTION global and _ARGS table.
//

	_ACTION = null;
	_ARGS = {};

	for( i, arg in ipairs(_ARGV) ) {
		if( ! arg->startswith("/") && ! arg->startswith("--") ) {
			if( ! _ACTION ) {
				_ACTION = arg;
			} else {
				table.insert(_ARGS, arg);
				_ARGS[arg] = arg;
			}
		}
	}



//
// The list of registered actions. Calls to newaction() will add
// new entries here.
//

	action._list = {};


//-
// Register a new action.
//
// @param act
//    The new action object.
//-

	function action.add(act) {
		// validate the action object, at least a little bit
		var missing;
		for( _, field in ipairs({"description", "trigger"}) ) {
			if( ! act[field] ) {
				missing = field;
			}
		}

		if( missing ) {
			var name = act.trigger || "";
			error(string.format('action "%s" needs a  %s', name, missing), 3);
		}

		if( act.os != null ) {
			p.warnOnce(act.trigger, "action '" .. act.trigger .. "' sets 'os' field, which is deprecated, use 'targetos' instead.");
			act.targetos = act.os;
			act.os = null;
		}

		action._list[act.trigger] = act;
	}



//-
// Initialize an action.
//
// @param name
//    The name of the action to be initialized.
//-

	function action.initialize(name) {
		var a = action._list[name];
		if( (a.onInitialize) ) {
			a.onInitialize();
		}
	}



//-
// Trigger an action.
//
// @param name
//    The name of the action to be triggered.
//-

	function action.call(name) {
		var a = action._list[name];

		if( a.onStart ) {
			a.onStart();
		}

		for( wks in p.global.eachWorkspace() ) {
			var onWorkspace = a.onWorkspace || a.onSolution || a.onsolution;
			if( onWorkspace && ! wks.external ) {
				onWorkspace(wks);
			}

			for( prj in p.workspace.eachproject(wks) ) {
				var onProject = a.onProject || a.onproject;
				if( onProject && ! prj.external ) {
					onProject(prj);
				}
			}
		}

		for( rule in p.global.eachRule() ) {
			var onRule = a.onRule || a.onrule;
			if( onRule && ! rule.external ) {
				onRule(rule);
			}
		}

		if( a.execute ) {
			a.execute();
		}

		if( a.onEnd ) {
			a.onEnd();
		}
	}


//-
// Retrieve the current action, as determined by _ACTION.
//
// @return
//    The current action, or nil if _ACTION is nil or does not match any action.
//-

	function action.current() {
		return action.get(_ACTION);
	}


//-
// Retrieve an action by name.
//
// @param name
//    The name of the action to retrieve.
// @returns
//    The requested action, or nil if the action does not exist.
//-

	function action.get(name) {
		// "Next-gen" actions are deprecated
		if( name && name->endswith("ng") ) {
			name = name->sub(1, -3);
		}
		return action._list[name];
	}


//-
// Iterator for the list of actions.
//-

	function action.each() {
		// sort the list by trigger
		var keys = { };
		for( _, act in pairs(action._list) ) {
			table.insert(keys, act.trigger);
		}
		table.sort(keys);

		var i = 0;
		return function() {
			++i    ;
			return action._list[keys[i]];
		};
	}


//-
// Determines if an action makes use of the configuration information
// provided by the project scripts (i.e. it is an exporter) or if it
// simply performs an action irregardless of configuration, in which
// case the baking and validation phases can be skipped.
//-

	function action.isConfigurable(this) {
		if( ! this ) {
			this = action.current() || {};
		}
		if( this.onWorkspace || this.onSolution || this.onsolution ) {
			return true;
		}
		if( this.onProject || this.onproject ) {
			return true;
		}
		return false;
	}



//-
// Activates a particular action.
//
// @param name
//    The name of the action to activate.
//-

	function action.set(name) {
		_ACTION = name;

		// Some actions imply a particular operating system
		var act = action.get(name);
		if( act ) {
			_TARGET_OS = act.targetos || _TARGET_OS;
		}

		// Some are implemented in standalone modules
		if( act && act.module ) {
			require(act.module);
		}
	}


//-
// Determines if an action supports a particular language or target type.
//
// @param feature
//    The feature to check, either a programming language or a target type.
// @returns
//    True if the feature is supported, false otherwise.
//-

	function action.supports(feature) {
		if( ! feature ) {
			return true;
		}
		var this = action.current();
		if( ! this ) {
			return false;
		}

		if( ! this.valid_languages && ! this.valid_kinds ) {
			return true;
		}

		if( this.valid_languages && table.contains(this.valid_languages, feature) ) {
			return true;
		}

		if( this.valid_kinds && table.contains(this.valid_kinds, feature) ) {
			return true;
		}

		return false;
	}


//
// Determines if an action supports a particular configuration.
// @return
// True if the configuration is supported, false otherwise.
//
	function p.action.supportsconfig(action, cfg) {
		if( ! action ) {
			return false;
		}
		if( action.supportsconfig ) {
			return action.supportsconfig(cfg);
		}
		return true;
	}
