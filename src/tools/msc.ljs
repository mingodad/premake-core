//-
// msc.ljs
// Interface for the MS C/C++ compiler.
// Author Jason Perkins
// Modified by Manu Evans
// Copyright (c) 2009-2015 Jason Perkins and the Premake project
//-


	var p = premake;

	p.tools.msc = {};
	var msc = p.tools.msc;
	var project = p.project;
	var config = p.config;


//
// Returns list of C preprocessor flags for a configuration.
//

	function msc.getcppflags(cfg) {
		return {};
	}


//
// Returns list of C compiler flags for a configuration.
//

	msc.shared = {
		clr = {
			On = "/clr",
			Unsafe = "/clr",
			Pure = "/clr:pure",
			Safe = "/clr:safe",
		},
		flags = {
			FatalCompileWarnings = "/WX",
			MultiProcessorCompile = "/MP",
			NoMinimalRebuild = "/Gm-",
			OmitDefaultLibrary = "/Zl"
		},
		floatingpoint = {
			Fast = "/fp:fast",
			Strict = "/fp:strict",
		},
		floatingpointexceptions = {
			On  = "/fp:except",
			Off = "/fp:except-",
		},
		functionlevellinking = {
			On = "/Gy",
			Off = "/Gy-",
		},
		callingconvention = {
			Cdecl = "/Gd",
			FastCall = "/Gr",
			StdCall = "/Gz",
			VectorCall = "/Gv",
		},
		intrinsics = {
			On = "/Oi",
		},
		optimize = {
			Off = "/Od",
			On = "/Ot",
			Debug = "/Od",
			Full = "/Ox",
			Size = "/O1",
			Speed = "/O2",
		},
		vectorextensions = {
			AVX = "/arch:AVX",
			AVX2 = "/arch:AVX2",
			SSE = "/arch:SSE",
			SSE2 = "/arch:SSE2",
			SSE3 = "/arch:SSE2",
			SSSE3 = "/arch:SSE2",
			["SSE4.1"] = "/arch:SSE2",
		},
		warnings = {
			Extra = "/W4",
			High = "/W4",
			Off = "/W0",
		},
		staticruntime = {
			// this option must always be emit (does it??)
			_ = function(cfg) { return (config.isDebugBuild(cfg) ? "/MDd" : "/MD"); },
			// runtime defaults to dynamic in VS
			Default = function(cfg) { return (config.isDebugBuild(cfg) ? "/MDd" : "/MD"); },
			On = function(cfg) { return (config.isDebugBuild(cfg) ? "/MTd" : "/MT"); },
			Off = function(cfg) { return (config.isDebugBuild(cfg) ? "/MDd" : "/MD"); },
		},
		stringpooling = {
			On = "/GF",
			Off = "/GF-",
		},
		symbols = {
			On = "/Z7"
		},
		unsignedchar = {
			On = "/J",
		},
		omitframepointer = {
			On = "/Oy"
		}

	};

	msc.cflags = {
	};

	function msc.getcflags(cfg) {
		var shared = config.mapFlags(cfg, msc.shared);
		var cflags = config.mapFlags(cfg, msc.cflags);
		var flags = table.join(shared, cflags, msc.getwarnings(cfg));
		return flags;
	}


//
// Returns list of C++ compiler flags for a configuration.
//

	msc.cxxflags = {
		exceptionhandling = {
			Default = "/EHsc",
			On = "/EHsc",
			SEH = "/EHa",
		},
		rtti = {
			Off = "/GR-"
		}
	};

	function msc.getcxxflags(cfg) {
		var shared = config.mapFlags(cfg, msc.shared);
		var cxxflags = config.mapFlags(cfg, msc.cxxflags);
		var flags = table.join(shared, cxxflags, msc.getwarnings(cfg));
		return flags;
	}


//
// Decorate defines for the MSVC command line.
//

	msc.defines = {
		characterset = {
			Default = { '/D"_UNICODE"', '/D"UNICODE"' },
			MBCS = '/D"_MBCS"',
			Unicode = { '/D"_UNICODE"', '/D"UNICODE"' },
			ASCII = { },
		}
	};

	function msc.getdefines(defines, cfg) {
		var result;

		// HACK: I need the cfg to tell what the character set defines should be. But
		// there's lots of legacy code using the old getdefines(defines) signature.
		// For now, detect one or two arguments and apply the right behavior; will fix
		// it properly when the I roll out the adapter overhaul
		if( cfg && defines ) {
			result = config.mapFlags(cfg, msc.defines);
		} else {
			result = {};
		}

		for( _, define in ipairs(defines) ) {
			table.insert(result, '/D"' .. define .. '"');
		}

		if( cfg && cfg.exceptionhandling == p.OFF ) {
			table.insert(result, "/D_HAS_EXCEPTIONS=0");
		}

		return result;
	}

	function msc.getundefines(undefines) {
		var result = {};
		for( _, undefine in ipairs(undefines) ) {
			table.insert(result, '/U"' .. undefine .. '"');
		}
		return result;
	}


//
// Returns a list of forced include files, decorated for the compiler
// command line.
//
// @param cfg
//    The project configuration.
// @return
//    An array of force include files with the appropriate flags.
//

	function msc.getforceincludes(cfg) {
		var result = {};

		table.foreachi(cfg.forceincludes, function(value) {
			var fn = project.getrelative(cfg.project, value);
			table.insert(result, "/FI" .. p.quoted(fn));
		});

		return result;
	}

	function msc.getrunpathdirs() {
		return {};
	}

//
// Decorate include file search paths for the MSVC command line.
//

	function msc.getincludedirs(cfg, dirs, sysdirs) {
		var result = {};
		dirs = table.join(dirs, sysdirs);
		for( _, dir in ipairs(dirs) ) {
			dir = project.getrelative(cfg.project, dir);
			table.insert(result, '-I' ..  p.quoted(dir));
		}
		return result;
	}


//
// Return a list of linker flags for a specific configuration.
//

	msc.linkerFlags = {
		flags = {
			FatalLinkWarnings = "/WX",
			LinkTimeOptimization = "/GL",
			NoIncrementalLink = "/INCREMENTAL:NO",
			NoManifest = "/MANIFEST:NO",
			OmitDefaultLibrary = "/NODEFAULTLIB",
		},
		kind = {
			SharedLib = "/DLL",
		},
		symbols = {
			On = "/DEBUG"
		}
	};

	msc.librarianFlags = {
		flags = {
			FatalLinkWarnings = "/WX",
		}
	};

	function msc.getldflags(cfg) {
		var map = cfg.kind != p.STATICLIB ? msc.linkerFlags : msc.librarianFlags;
		var flags = config.mapFlags(cfg, map);
		table.insert(flags, 1, "/NOLOGO");

		// Ignore default libraries
		for( i, ignore in ipairs(cfg.ignoredefaultlibraries) ) {
			// Add extension if required
			if( ! msc.getLibraryExtensions()[ignore->match("[^.]+$")] ) {
				ignore = path.appendextension(ignore, ".lib");
			}
			table.insert(flags, '/NODEFAULTLIB:' .. ignore);
		}

		return flags;
	}


//
// Build a list of additional library directories for a particular
// project configuration, decorated for the tool command line.
//
// @param cfg
//    The project configuration.
// @return
//    An array of decorated additional library directories.
//

	function msc.getLibraryDirectories(cfg) {
		var flags = {};
		var dirs = table.join(cfg.libdirs, cfg.syslibdirs);
		for( i, dir in ipairs(dirs) ) {
			dir = project.getrelative(cfg.project, dir);
			table.insert(flags, '/LIBPATH:"' .. dir .. '"');
		}
		return flags;
	}


//
// Return a list of valid library extensions
//

	function msc.getLibraryExtensions() {
		return {
			["lib"] = true,
			["obj"] = true,
		};
	}

//
// Return the list of libraries to link, decorated with flags as needed.
//

	function msc.getlinks(cfg, systemonly, nogroups) {
		var links = {};

		// If we need sibling projects to be listed explicitly, grab them first
		if( ! systemonly ) {
			links = config.getlinks(cfg, "siblings", "fullpath");
		}

		// Then the system libraries, which come undecorated
		var system = config.getlinks(cfg, "system", "fullpath");
		for( i = 1, #system ) {
			// Add extension if required
			var link = system[i];
			if( ! p.tools.msc.getLibraryExtensions()[link->match("[^.]+$")] ) {
				link = path.appendextension(link, ".lib");
			}

			table.insert(links, link);
		}

		return links;
	}

//
// Returns makefile-specific configuration rules.
//

	function msc.getmakesettings(cfg) {
		return null;
	}


//
// Retrieves the executable command name for a tool, based on the
// provided configuration and the operating environment.
//
// @param cfg
//    The configuration to query.
// @param tool
//    The tool to fetch, one of "cc" for the C compiler, "cxx" for
//    the C++ compiler, or "ar" for the static linker.
// @return
//    The executable command name for a tool, or nil if the system's
//    default value should be used.
//

	function msc.gettoolname(cfg, tool) {
		return null;
	}



	function msc.getwarnings(cfg) {
		var result = {};

		// NOTE: VStudio can't enable specific warnings (workaround?)
		for( _, disable in ipairs(cfg.disablewarnings) ) {
			table.insert(result, '/wd"' .. disable .. '"');
		}
		for( _, fatal in ipairs(cfg.fatalwarnings) ) {
			table.insert(result, '/we"' .. fatal .. '"');
		}

		return result;
	}
