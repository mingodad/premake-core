//---------------------------------------------------------------------------
// A hacked dispatcher module
// LuaSocket sample files
// Author: Diego Nehab
//---------------------------------------------------------------------------
var base = _G;
var table = require("table");
var string = require("string");
var socket = require("socket");
var coroutine = require("coroutine");
module("dispatch");

// if too much time goes by without any activity in one of our sockets, we
// just kill it
TIMEOUT = 60;

//---------------------------------------------------------------------------
// We implement 3 types of dispatchers:
//     sequential
//     coroutine
//     threaded
// The user can choose whatever one is needed
//---------------------------------------------------------------------------
var handlert = {};

// default handler is coroutine
function newhandler(mode) {
    mode = mode || "coroutine";
    return handlert[mode]();
}

var function seqstart(this, func) {
    return func();
}

// sequential handler simply calls the functions and doesn't wrap I/O
function handlert.sequential() {
    return {
        tcp = socket.tcp,
        start = seqstart
    };
}

//---------------------------------------------------------------------------
// Mega hack. Don't try to do this at home.
//---------------------------------------------------------------------------
// we can't yield across calls to protect on Lua 5.1, so we rewrite it with
// coroutines
// make sure you don't require any module that uses socket.protect before
// loading our hack
if( string.sub(base._VERSION, -3) == "5.1" ) {
  var function _protect(co, status, ...) {
    if( ! status ) {
      var msg = ...;
      if( base.type(msg) == 'table' ) {
        return null, msg[1];
      } else {
        base.error(msg, 0);
      }
    }
    if( coroutine.status(co) == "suspended" ) {
      return _protect(co, coroutine.resume(co, coroutine.yield(...)));
    } else {
      return ...;
    }
  }

  function socket.protect(f) {
    return function(...) {
      var co = coroutine.create(f);
      return _protect(co, coroutine.resume(co, ...));
    };
  }
}

//---------------------------------------------------------------------------
// Simple set data structure. O(1) everything.
//---------------------------------------------------------------------------
var function newset() {
    var reverse = {};
    var set = {};
    return base.setmetatable(set, {__index = {
        insert = function(set, value) {
            if( ! reverse[value] ) {
                table.insert(set, value);
                reverse[value] = #set;
            }
        },
        remove = function(set, value) {
            var index = reverse[value];
            if( index ) {
                reverse[value] = null;
                var top = table.remove(set);
                if( top != value ) {
                    reverse[top] = index;
                    set[index] = top;
                }
            }
        }
    }});
}

//---------------------------------------------------------------------------
// socket.tcp() wrapper for the coroutine dispatcher
//---------------------------------------------------------------------------
var function cowrap(dispatcher, tcp, error) {
    if( ! tcp ) { return null, error; }
    // put it in non-blocking mode right away
    tcp->settimeout(0);
    // metatable for wrap produces new methods on demand for those that we
    // don't override explicitly.
    var metat = { __index = function(table, key) {
        table[key] = function(...) {
            return tcp[key](tcp,select(2,...));
        };
        return table[key];
    }};
    // does our user want to do his own non-blocking I/O?
    var zero = false;
    // create a wrap object that will behave just like a real socket object
    var wrap = {  };
    // we ignore settimeout to preserve our 0 timeout, but record whether
    // the user wants to do his own non-blocking I/O
    function wrap::settimeout(value, mode) {
        if( value == 0 ) { zero = true;
        } else { zero = false; }
        return 1;
    }
    // send in non-blocking mode and yield on timeout
    function wrap::send(data, first, last) {
        first = (first || 1) - 1;
        var result, error;
        while( true ) {
            // return control to dispatcher and tell it we want to send
            // if upon return the dispatcher tells us we timed out,
            // return an error to whoever called us
            if( coroutine.yield(dispatcher.sending, tcp) == "timeout" ) {
                return null, "timeout";
            }
            // try sending
            result, error, first = tcp->send(data, first+1, last);
            // if we are done, or there was an unexpected error,
            // break away from loop
            if( error != "timeout" ) { return result, error, first; }
        }
    }
    // receive in non-blocking mode and yield on timeout
    // or simply return partial read, if user requested timeout = 0
    function wrap::receive(pattern, partial) {
        var error = "timeout";
        var value;
        while( true ) {
            // return control to dispatcher and tell it we want to receive
            // if upon return the dispatcher tells us we timed out,
            // return an error to whoever called us
            if( coroutine.yield(dispatcher.receiving, tcp) == "timeout" ) {
                return null, "timeout";
            }
            // try receiving
            value, error, partial = tcp->receive(pattern, partial);
            // if we are done, or there was an unexpected error,
            // break away from loop. also, if the user requested
            // zero timeout, return all we got
            if( (error != "timeout") || zero ) {
                return value, error, partial;
            }
        }
    }
    // connect in non-blocking mode and yield on timeout
    function wrap::connect(host, port) {
        var result, error = tcp->connect(host, port);
        if( error == "timeout" ) {
            // return control to dispatcher. we will be writable when
            // connection succeeds.
            // if upon return the dispatcher tells us we have a
            // timeout, just abort
            if( coroutine.yield(dispatcher.sending, tcp) == "timeout" ) {
                return null, "timeout";
            }
            // when we come back, check if connection was successful
            result, error = tcp->connect(host, port);
            if( result || error == "already connected" ) { return 1;
            } else { return null, "non-blocking connect failed"; }
        } else { return result, error; }
    }
    // accept in non-blocking mode and yield on timeout
    function wrap::accept() {
        while( 1 ) {
            // return control to dispatcher. we will be readable when a
            // connection arrives.
            // if upon return the dispatcher tells us we have a
            // timeout, just abort
            if( coroutine.yield(dispatcher.receiving, tcp) == "timeout" ) {
                return null, "timeout";
            }
            var client, error = tcp->accept();
            if( error != "timeout" ) {
                return cowrap(dispatcher, client, error);
            }
        }
    }
    // remove cortn from context
    function wrap::close() {
        dispatcher.stamp[tcp] = null;
        dispatcher.sending.set->remove(tcp);
        dispatcher.sending.cortn[tcp] = null;
        dispatcher.receiving.set->remove(tcp);
        dispatcher.receiving.cortn[tcp] = null;
        return tcp->close();
    }
    return base.setmetatable(wrap, metat);
}


//---------------------------------------------------------------------------
// Our coroutine dispatcher
//---------------------------------------------------------------------------
var cometat = { __index = {} };

function schedule(cortn, status, operation, tcp) {
    if( status ) {
        if( cortn && operation ) {
            operation.set->insert(tcp);
            operation.cortn[tcp] = cortn;
            operation.stamp[tcp] = socket.gettime();
        }
    } else { base.error(operation); }
}

function kick(operation, tcp) {
    operation.cortn[tcp] = null;
    operation.set->remove(tcp);
}

function wakeup(operation, tcp) {
    var cortn = operation.cortn[tcp];
    // if cortn is still valid, wake it up
    if( cortn ) {
        kick(operation, tcp);
        return cortn, coroutine.resume(cortn);
    // othrewise, just get scheduler not to do anything
    } else {
        return null, true;
    }
}

function abort(operation, tcp) {
    var cortn = operation.cortn[tcp];
    if( cortn ) {
        kick(operation, tcp);
        coroutine.resume(cortn, "timeout");
    }
}

// step through all active cortns
function cometat.__index::step() {
    // check which sockets are interesting and act on them
    var readable, writable = socket.select(this.receiving.set,
        this.sending.set, 1);
    // for all readable connections, resume their cortns and reschedule
    // when they yield back to us
    for( _, tcp in base.ipairs(readable) ) {
        schedule(wakeup(this.receiving, tcp));
    }
    // for all writable connections, do the same
    for( _, tcp in base.ipairs(writable) ) {
        schedule(wakeup(this.sending, tcp));
    }
    // politely ask replacement I/O functions in idle cortns to
    // return reporting a timeout
    var now = socket.gettime();
    for( tcp, stamp in base.pairs(this.stamp) ) {
        if( tcp.class == "tcp{client}" && now - stamp > TIMEOUT ) {
            abort(this.sending, tcp);
            abort(this.receiving, tcp);
        }
    }
}

function cometat.__index::start(func) {
    var cortn = coroutine.create(func);
    schedule(cortn, coroutine.resume(cortn));
}

function handlert.coroutine() {
    var stamp = {};
    var dispatcher = {
        stamp = stamp,
        sending  = {
            name = "sending",
            set = newset(),
            cortn = {},
            stamp = stamp
        },
        receiving = {
            name = "receiving",
            set = newset(),
            cortn = {},
            stamp = stamp
        },
    };
    function dispatcher.tcp() {
        return cowrap(dispatcher, socket.tcp());
    }
    return base.setmetatable(dispatcher, cometat);
}

