//
// android/vsandroid_vcxproj.ljs
// vs-android integration for vstudio.
// Copyright (c) 2012-2015 Manu Evans and the Premake project
//

	var p = premake;

	p.modules.vsandroid = { };

	var android = p.modules.android;
	var vsandroid = p.modules.vsandroid;
	var vc2010 = p.vstudio.vc2010;
	var vstudio = p.vstudio;
	var project = p.project;
	var config = p.config;


//
// Add android tools to vstudio actions.
//

	if( vstudio.vs2010_architectures != null ) {
		if( _ACTION >= "vs2015" ) {
			vstudio.vs2010_architectures.arm = "ARM";
		} else {
			vstudio.vs2010_architectures.android = "Android";
		}
	}

//
// Extend global properties
//
	premake.override(vc2010.elements, "globals", function (oldfn, prj) {
		var elements = oldfn(prj);

		if( prj.system == premake.ANDROID && prj.kind != premake.ANDROIDPROJ ) {
			// Remove "IgnoreWarnCompileDuplicatedFilename".
			var pos = table.indexof(elements, vc2010.ignoreWarnDuplicateFilename);
			table.remove(elements, pos);
			elements = table.join(elements, {
				android.androidApplicationType
			});
		}

		return elements;
	});
	
	premake.override(vc2010.elements, "globalsCondition", function (oldfn, prj, cfg) {
		var elements = oldfn(prj, cfg);
		
		if( cfg.system == premake.ANDROID && cfg.system != prj.system && cfg.kind != premake.ANDROIDPROJ ) {
			elements = table.join(elements, {
				android.androidApplicationType
			});
		}

		return elements;
	});

	function android.androidApplicationType(cfg) {
		_p(2, "<Keyword>Android</Keyword>");
		_p(2, "<RootNamespace>%s</RootNamespace>", cfg.project.name);
		_p(2, "<MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>");
		_p(2, "<ApplicationType>Android</ApplicationType>");
		if( _ACTION >= "vs2017" ) {
			_p(2, "<ApplicationTypeRevision>3.0</ApplicationTypeRevision>");
		} else if( _ACTION >= "vs2015" ) {
			_p(2, "<ApplicationTypeRevision>2.0</ApplicationTypeRevision>");
		} else {
			_p(2, "<ApplicationTypeRevision>1.0</ApplicationTypeRevision>");
		}
	}

//
// Extend configurationProperties.
//

	premake.override(vc2010.elements, "configurationProperties", function(oldfn, cfg) {
		var elements = oldfn(cfg);
		if( cfg.kind != p.UTILITY && cfg.kind != p.ANDROIDPROJ && cfg.system == premake.ANDROID ) {
			elements = table.join(elements, {
				android.androidAPILevel,
				android.androidStlType,
			});

			if( _ACTION >= "vs2015" ) {
				elements = table.join(elements, {
					android.thumbMode,
				});
			}
		}
		return elements;
	});

	function android.androidAPILevel(cfg) {
		if( cfg.androidapilevel != null ) {
			_p(2,'<AndroidAPILevel>android-%d</AndroidAPILevel>', cfg.androidapilevel);
		}
	}

	function android.androidStlType(cfg) {
		if( cfg.stl != null ) {
			var stlType = {
				["none"] = "none",
				["minimal c++ (system)"] = "system",
				["c++ static"] = "gabi++_static",
				["c++ shared"] = "gabi++_shared",
				["stlport static"] = "stlport_static",
				["stlport shared"] = "stlport_shared",
				["gnu stl static"] = "gnustl_static",
				["gnu stl shared"] = "gnustl_shared",
				["llvm libc++ static"] = "c++_static",
				["llvm libc++ shared"] = "c++_shared",
			};

			if( _ACTION >= "vs2015" ) {
				_p(2,'<UseOfStl>%s</UseOfStl>', stlType[cfg.stl]);
			} else {
				_p(2,'<AndroidStlType>%s</AndroidStlType>', stlType[cfg.stl]);
			}
		}
	}

	function android.thumbMode(cfg) {
		if( cfg.thumbmode ) {
			var thumbMode =
			{
				thumb = "Thumb",
				arm = "ARM",
				disabled = "Disabled",
			};
			_p(2,"<ThumbMode>%s</ThumbMode>", thumbMode[cfg.thumbmode]);
		}
	}

	// Note: this function is already patched in by vs2012...
	premake.override(vc2010, "platformToolset", function(oldfn, cfg) {
		if( cfg.system != premake.ANDROID ) {
			return oldfn(cfg);
		}

		if( _ACTION >= "vs2015" ) {
			var gcc_map = {
				["_"]   = "GCC_4_9", // default
				["4.6"] = "GCC_4_6",
				["4.8"] = "GCC_4_8",
				["4.9"] = "GCC_4_9",
			};
			var clang_map = {
				["_"]   = "Clang_3_8", // default
				["3.4"] = "Clang_3_4",
				["3.5"] = "Clang_3_5",
				["3.6"] = "Clang_3_6",
				["3.8"] = "Clang_3_8",
			};

			var map = cfg.toolset == "gcc" ? gcc_map : clang_map;
			var ts  = map[cfg.toolchainversion || "_"];
			if( ts == null ) {
				p.error('Invalid toolchainversion for the selected toolset (%s).', cfg.toolset || "clang");
			}

			_p(2, "<PlatformToolset>%s</PlatformToolset>", ts);
		} else {
			var archMap = {
				arm = "armv5te", // should arm5 be default? vs-android thinks so...
				arm5 = "armv5te",
				arm7 = "armv7-a",
				mips = "mips",
				x86 = "x86",
			};
			var arch = cfg.architecture || "arm";

			if( (cfg.architecture != null || cfg.toolchainversion != null) && archMap[arch] != null ) {
				var defaultToolsetMap = {
					arm = "arm-linux-androideabi-",
					armv5 = "arm-linux-androideabi-",
					armv7 = "arm-linux-androideabi-",
					aarch64 = "aarch64-linux-android-",
					mips = "mipsel-linux-android-",
					mips64 = "mips64el-linux-android-",
					x86 = "x86-",
					x86_64 = "x86_64-",
				};
				var toolset = defaultToolsetMap[arch];

				if( cfg.toolset == "clang" ) {
					error("The clang toolset is not yet supported by vs-android", 2);
					toolset = toolset .. "clang";
				} else if( cfg.toolset && cfg.toolset != "gcc" ) {
					error("Toolset not supported by the android NDK: " .. cfg.toolset, 2);
				}

				var version = cfg.toolchainversion || (cfg.toolset == "clang" ? "3.5" : "4.9");

				_p(2,'<PlatformToolset>%s</PlatformToolset>', toolset .. version);
				_p(2,'<AndroidArch>%s</AndroidArch>', archMap[arch]);
			}
		}
	});


//
// Extend clCompile.
//

	premake.override(vc2010.elements, "clCompile", function(oldfn, cfg) {
		var elements = oldfn(cfg);
		if( cfg.system == premake.ANDROID ) {
			elements = table.join(elements, {
				android.debugInformation,
				android.strictAliasing,
				android.thumbMode,
				android.fpu,
				android.pic,
//				android.ShortEnums,
			});
			if( _ACTION >= "vs2015" ) {
				table.remove(elements, table.indexof(elements, vc2010.debugInformationFormat));
				table.remove(elements, table.indexof(elements, android.thumbMode));
			}
		}
		return elements;
	});

	function android.debugInformation(cfg) {
		if( cfg.flags.Symbols ) {
			_p(3,'<GenerateDebugInformation>true</GenerateDebugInformation>');
		}
	}

	function android.strictAliasing(cfg) {
		if( cfg.strictaliasing != null ) {
			_p(3,'<StrictAliasing>%s</StrictAliasing>', (cfg.strictaliasing == "Off" ? "false" : "true"));
		}
	}

	function android.thumbMode(cfg) {
		if( cfg.flags.Thumb ) {
			_p(3,'<ThumbMode>true</ThumbMode>');
		}
	}

	function android.fpu(cfg) {
		if( cfg.fpu != null ) {
			_p(3,'<SoftFloat>true</SoftFloat>', (cfg.fpu == "Software" ? "true" : "false"));
		}
	}

	function android.pic(cfg) {
		// TODO: We only have a flag to turn it on, but android is on by default
		//       it seems we would rather have a flag to turn it off...
//		if cfg.pic ~= nil then
//			_p(3,'<PositionIndependentCode>%s</PositionIndependentCode>', (cfg.pic == "On" ? "true" : "false"))
//		end
	}

	p.override(vc2010, "languageStandard", function(oldfn, cfg) {
		if( cfg.system == p.ANDROID ) {
			var cpp_langmap = {
				["C++98"]   = "c++98",
				["C++11"]   = "c++11",
				["C++14"]   = "c++1y",
				["gnu++98"] = "gnu++98",
				["gnu++11"] = "gnu++11",
				["gnu++14"] = "gnu++1y",
			};
			if( cpp_langmap[cfg.cppdialect] != null ) {
				vc2010.element("CppLanguageStandard", null, cpp_langmap[cfg.cppdialect]);
			}
		} else {
			oldfn(cfg);
		}
	});

	p.override(vc2010, "additionalCompileOptions", function(oldfn, cfg, condition) {
		if( cfg.system == p.ANDROID ) {
			var opts = cfg.buildoptions;

			var cpp_langmap = {
				["C++17"]   = "-std=c++1z",
				["gnu++17"] = "-std=gnu++1z",
			};
			if( cpp_langmap[cfg.cppdialect] != null ) {
				table.insert(opts, cpp_langmap[cfg.cppdialect]);
			}

			if( #opts > 0 ) {
				opts = table.concat(opts, " ");
				vc2010.element("AdditionalOptions", condition, '%s %%(AdditionalOptions)', opts);
			}
		} else {
			oldfn(cfg, condition);
		}
	});

	p.override(p.vstudio.vc2010, "warningLevel", function(oldfn, cfg) {
		if( _ACTION >= "vs2015" && cfg.system == p.ANDROID && cfg.warnings && cfg.warnings != "Off" ) {
			p.vstudio.vc2010.element("WarningLevel", null, "EnableAllWarnings");
		} else if( (_ACTION >= "vs2015" && cfg.system == p.ANDROID && cfg.warnings) || ! (_ACTION >= "vs2015" && cfg.system == p.ANDROID) ) {
			oldfn(cfg);
		}
	});

	premake.override(vc2010, "clCompilePreprocessorDefinitions", function(oldfn, cfg, condition) {
		if( cfg.system == p.ANDROID ) {
			vc2010.preprocessorDefinitions(cfg, cfg.defines, false, condition);
		} else {
			oldfn(cfg, condition);
		}
	});

	premake.override(vc2010, "exceptionHandling", function(oldfn, cfg, condition) {
		if( cfg.system == p.ANDROID ) {
			// Note: Android defaults to 'off'
			if( cfg.exceptionhandling ) {
				if( _ACTION >= "vs2015" ) {
					vc2010.element("ExceptionHandling", condition, "Enabled");
				} else {
					vc2010.element("GccExceptionHandling", condition, "true");
				}
			}
		} else {
			oldfn(cfg, condition);
		}
	});

	premake.override(vc2010, "runtimeTypeInfo", function(oldfn, cfg, condition) {
		if( cfg.system == premake.ANDROID ) {
			// Note: Android defaults to 'off'
			if( cfg.rtti ) {
				vc2010.element("RuntimeTypeInfo", condition, "true");
			}
		} else {
			oldfn(cfg, condition);
		}
	});


//
// Extend Link.
//

	premake.override(vc2010, "generateDebugInformation", function(oldfn, cfg) {
		// Note: Android specifies the debug info in the clCompile section
		if( cfg.system != premake.ANDROID ) {
			oldfn(cfg);
		}
	});


//
// Add android tools to vstudio actions.
//

	premake.override(vc2010.elements, "itemDefinitionGroup", function(oldfn, cfg) {
		var elements = oldfn(cfg);
		if( cfg.system == premake.ANDROID && _ACTION < "vs2015" ) {
			elements = table.join(elements, {
				android.antBuild,
			});
		}
		return elements;
	});

	function android.antPackage(cfg) {
		p.push('<AntPackage>');
		if( cfg.androidapplibname != null ) {
			vc2010.element("AndroidAppLibName", null, cfg.androidapplibname);
		} else {
			vc2010.element("AndroidAppLibName", null, "$(RootNamespace)");
		}
		p.pop('</AntPackage>');
	}

	function android.antBuild(cfg) {
		if( cfg.kind == premake.STATICLIB || cfg.kind == premake.SHAREDLIB ) {
			return;
		}

		_p(2,'<AntBuild>');
		_p(3,'<AntBuildType>%s</AntBuildType>', (premake.config.isDebugBuild(cfg) ? "Debug" : "Release"));
		_p(2,'</AntBuild>');
	}

	premake.override(vc2010, "additionalCompileOptions", function(oldfn, cfg, condition) {
		if( cfg.system == premake.ANDROID ) {
			vsandroid.additionalOptions(cfg, condition);
		}
		return oldfn(cfg, condition);
	});

	premake.override(vc2010.elements, "user", function(oldfn, cfg) {
		if( cfg.system == p.ANDROID ) {
			return {};
		} else {
			return oldfn(cfg);
		}
	});

//
// Add options unsupported by vs-android UI to <AdvancedOptions>.
//
	function vsandroid.additionalOptions(cfg) {
		if( _ACTION >= "vs2015" ) {

		} else {
			var function alreadyHas(t, key) {
				for( _, k in ipairs(t) ) {
					if( string.find(k, key) ) {
						return true;
					}
				}
				return false;
			}

			if( ! cfg.architecture || string.startswith(cfg.architecture, "arm") ) {
				// we might want to define the arch to generate better code
//				if not alreadyHas(cfg.buildoptions, "-march=") then
//					if cfg.architecture == "armv6" then
//						table.insert(cfg.buildoptions, "-march=armv6")
//					elseif cfg.architecture == "armv7" then
//						table.insert(cfg.buildoptions, "-march=armv7")
//					end
//				end

				// ARM has a comprehensive set of floating point options
				if( cfg.fpu != "Software" && cfg.floatabi != "soft" ) {

					if( cfg.architecture == "armv7" ) {

						// armv7 always has VFP, may not have NEON

						if( ! alreadyHas(cfg.buildoptions, "-mfpu=") ) {
							if( cfg.vectorextensions == "NEON" ) {
								table.insert(cfg.buildoptions, "-mfpu=neon");
							} else if( cfg.fpu == "Hardware" || cfg.floatabi == "softfp" || cfg.floatabi == "hard" ) {
								table.insert(cfg.buildoptions, "-mfpu=vfpv3-d16"); // d16 is the lowest common denominator
							}
						}

						if( ! alreadyHas(cfg.buildoptions, "-mfloat-abi=") ) {
							if( cfg.floatabi == "hard" ) {
								table.insert(cfg.buildoptions, "-mfloat-abi=hard");
							} else {
								// Android should probably use softfp by default for compatibility
								table.insert(cfg.buildoptions, "-mfloat-abi=softfp");
							}
						}

					} else {

						// armv5/6 may not have VFP

						if( ! alreadyHas(cfg.buildoptions, "-mfpu=") ) {
							if( cfg.fpu == "Hardware" || cfg.floatabi == "softfp" || cfg.floatabi == "hard" ) {
								table.insert(cfg.buildoptions, "-mfpu=vfp");
							}
						}

						if( ! alreadyHas(cfg.buildoptions, "-mfloat-abi=") ) {
							if( cfg.floatabi == "softfp" ) {
								table.insert(cfg.buildoptions, "-mfloat-abi=softfp");
							} else if( cfg.floatabi == "hard" ) {
								table.insert(cfg.buildoptions, "-mfloat-abi=hard");
							}
						}

					}

				} else if( cfg.floatabi == "soft" ) {

					table.insert(cfg.buildoptions, "-mfloat-abi=soft");

				}

				if( cfg.endian == "Little" ) {
					table.insert(cfg.buildoptions, "-mlittle-endian");
				} else if( cfg.endian == "Big" ) {
					table.insert(cfg.buildoptions, "-mbig-endian");
				}

			} else if( cfg.architecture == "mips" ) {

				// TODO...

				if( cfg.vectorextensions == "MXU" ) {
					table.insert(cfg.buildoptions, "-mmxu");
				}

			} else if( cfg.architecture == "x86" ) {

				// TODO...

			}
		}
	}

//
// Disable subsystem.
//

	p.override(vc2010, "subSystem", function(oldfn, cfg) {
		if( cfg.system != p.ANDROID ) {
			return oldfn(cfg);
		}
	});

//
// Remove .lib and list in LibraryDependencies instead of AdditionalDependencies.
//

	p.override(vc2010, "additionalDependencies", function(oldfn, cfg, explicit) {
		if( cfg.system == p.ANDROID ) {
			var links = {};

			// If we need sibling projects to be listed explicitly, grab them first
			if( explicit ) {
				links = config.getlinks(cfg, "siblings", "fullpath");
			}

			// Then the system libraries, which come undecorated
			var system = config.getlinks(cfg, "system", "name");
			for( i = 1, #system ) {
				var link = system[i];
				table.insert(links, link);
			}

			// TODO: When to use LibraryDependencies vs AdditionalDependencies

			if( #links > 0 ) {
				links = path.translate(table.concat(links, ";"));
				vc2010.element("LibraryDependencies", null, "%%(LibraryDependencies);%s", links);
			}
		} else {
			return oldfn(cfg, explicit);
		}
	});

//
// Disable override of OutDir.  This is breaking deployment.
//

	p.override(vc2010, "outDir", function(oldfn, cfg) {
		if( cfg.system != p.ANDROID ) {
			return oldfn(cfg);
		}
	});
