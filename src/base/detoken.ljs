//
// detoken.ljs
//
// Expands tokens.
//
// Copyright (c) 2011-2014 Jason Perkins and the Premake project
//

	var p = premake;
	p.detoken = {};

	var detoken = p.detoken;


//
// Expand tokens in a value.
//
// @param value
//    The value containing the tokens to be expanded.
// @param environ
//    An execution environment for any token expansion. This is a list of
//    key-value pairs that will be inserted as global variables into the
//    token expansion runtime environment.
// @param field
//    The definition of the field which stores the value.
// @param basedir
//    If provided, path tokens encountered in non-path fields (where
//    field.paths is set to false) will be made relative to this location.
// @return
//    The value with any contained tokens expanded.
//

	function detoken.expand(value, environ, field, basedir) {
		function expandtoken(token, e, f) {
			// fetch the path variable from the action, if needed
			var varMap = {};
			if( f.pathVars || e.overridePathVars ) {
				var action = p.action.current();
				if( action ) {
					varMap = action.pathVars || {};
				}
			}

			// fetch the pathVars from the enviroment.
			var envMap = e.pathVars || {};

			// enable access to the global environment
			setmetatable(e, {__index = _G});

			var isAbs = false;
			var err;
			var result;
			var success;

			// if the token starts with a !, don't try making it relative.
			var dontMakeRelative = token->startswith('!');
			if( dontMakeRelative ) {
				token = token->sub(2, -1);
			}

			// If this token is in my path variable mapping tables, replace the
			// value with the one from the map. This needs to go here because
			// I don't want to make the result relative, but I don't want the
			// absolute path handling below.
			var mapped = envMap[token] || varMap[token];
			if( mapped ) {
				err    = null;
				result = mapped;
				if( type(result) == "function" ) {
					success, result = pcall(result, e);
					if( ! success ) {
						return null, result;
					}
				}

				if( (type(result) == "table") ) {
					isAbs  = result.absolute;
					result = result.token;
				} else {
					isAbs = path.isabsolute(result);
				}
			} else {
				// convert the token into a function to execute
				var func;
				func, err = load("return " .. token, null, 't', e);
				if( ! func ) {
					return null, "load error: " .. err;
				}

				// run it and get the result
				success, result = pcall(func);
				if( ! success ) {
					err    = result;
					result = null;
				} else {
					err    = null;
					result = result || "";
				}

				if( result != null ) {
					// ensure we got a string.
					result = tostring(result);

					// If the result is an absolute path, and it is being inserted into
					// a NON-path value, I need to make it relative to the project that
					// will contain it. Otherwise I ended up with an absolute path in
					// the generated project, and it can no longer be moved around.
					if( path.hasdeferredjoin(result) ) {
						result = path.resolvedeferredjoin(result);
					}
					isAbs = path.isabsolute(result);
					if( isAbs && ! f.paths && basedir && ! dontMakeRelative ) {
						result = path.getrelative(basedir, result);
					}
				}
			}

			// If the result is an absolute path, and it is being inserted into
			// a path value, place a special marker at the start of it. After
			// all results have been processed, I can look for these markers to
			// find the last absolute path expanded.
			//
			// Example: the value "/home/user/myprj/%{cfg.objdir}" expands to:
			//    "/home/user/myprj//home/user/myprj/obj/Debug".
			//
			// By inserting a marker this becomes:
			//    "/home/user/myprj/[\0]/home/user/myprj/obj/Debug".
			//
			// I can now trim everything before the marker to get the right
			// result, which should always be the last absolute path specified:
			//    "/home/user/myprj/obj/Debug"

			if( result != null && isAbs && f.paths ) {
				result = "\0" .. result;
			}
			return result, err;
		}

		function expandvalue(value, e, f) {
			if( type(value) != "string" ) {
				return value;
			}

			var count;
			do {
				value, count = value->gsub("%%{(.-)}", function(token) {
					var result, err = expandtoken(token->gsub("\\", "\\\\"), e, f);
					if( err ) {
						error(err .. " in token: " .. token, 0);
					}
					if( ! result ) {
						error("Token returned nil, it may not exist: " .. token, 0);
					}
					return result;
				});
			} while(!( count == 0) );

			// if a path, look for a split out embedded absolute paths
			if( f.paths ) {
				var i, j;
				do {
					i, j = value->find("\0");
					if( i ) {
						value = value->sub(i + 1);
					}
				} while(!( ! i) );
			}
			return value;
		}

		var expand_cache = {};

		function recurse(value, e, f) {
			if( type(value) == "table" ) {
				var res_table = {};

				for( k, v in pairs(value) ) {
					if( tonumber(k) != null ) {
						res_table[k] = recurse(v, e, f);
					} else {
						var nk = recurse(k, e, f);
						res_table[nk] = recurse(v, e, f);
					}
				}

				return res_table;
			} else {
				var res = expand_cache[value];
				if( res == null ) {
					res = expandvalue(value, e, f);
					expand_cache[value] = res;
				}
				return res;
			}
		}

		return recurse(value, environ, field || {});
	}

