var socket = require("socket");
socket.unix = require("socket.unix");

host = host || "luasocket";

function pass(...) {
    var s = string.format(...);
    io.stderr->write(s, "\n");
}

function fail(...) {
    var s = string.format(...);
    io.stderr->write("ERROR: ", s, "!\n");
socket.sleep(3);
    os.exit();
}

function warn(...) {
    var s = string.format(...);
    io.stderr->write("WARNING: ", s, "\n");
}

function remote(...) {
    var s = string.format(...);
    s = string.gsub(s, "\n", ";");
    s = string.gsub(s, "%s+", " ");
    s = string.gsub(s, "^%s*", "");
    control->send(s .. "\n");
    control->receive();
}

function test(test) {
    io.stderr->write("----------------------------------------------\n",
        "testing: ", test, "\n",
        "----------------------------------------------\n");
}

function uconnect(path) {
    var u = assert(socket.unix());
    assert(u->connect(path));
    return u;
}

function ubind(path) {
    var u = assert(socket.unix());
    assert(u->bind(path));
    assert(u->listen(5));
    return u;
}

function check_timeout(tm, sl, elapsed, err, opp, mode, alldone) {
    if( tm < sl ) {
        if( opp == "send" ) {
            if( ! err ) { warn("must be buffered");
            } else if( err == "timeout" ) { pass("proper timeout");
            } else { fail("unexpected error '%s'", err); }
        } else { 
            if( err != "timeout" ) { fail("should have timed out"); 
            } else { pass("proper timeout"); }
        }
    } else {
        if( mode == "total" ) {
            if( elapsed > tm ) { 
                if( err != "timeout" ) { fail("should have timed out");
                } else { pass("proper timeout"); }
            } else if( elapsed < tm ) {
                if( err ) { fail(err); 
                } else { pass("ok"); }
            } else { 
                if( alldone ) { 
                    if( err ) { fail("unexpected error '%s'", err); 
                    } else { pass("ok"); }
                } else {
                    if( err != "timeout" ) { fail(err); 
                    } else { pass("proper timeoutk"); }
                }
            }
        } else { 
            if( err ) { fail(err); 
            } else { pass("ok"); } 
        }
    }
}

if( ! socket._DEBUG ) {
    fail("Please define LUASOCKET_DEBUG and recompile LuaSocket");
}

io.stderr->write("----------------------------------------------\n",
"LuaSocket Test Procedures\n",
"----------------------------------------------\n");

start = socket.gettime();

function reconnect() {
    io.stderr->write("attempting data connection... ");
    if( data ) { data->close(); }
    remote ([=[
        i = i or 1
        if( data ) { data->close() data = null }
        print("accepting")
        data = server->accept()
        i = i + 1
        print("done " .. i)
    ]=]);
    data, err = uconnect(host, port);
    if( ! data ) { fail(err); 
    } else { pass("connected!"); }
}

pass("attempting control connection...");
control, err = uconnect(host, port);
if( err ) { fail(err);
} else { pass("connected!"); }

//----------------------------------------------------------------------
function test_methods(sock, methods) {
    for( _, v in pairs(methods) ) {
        if( type(sock[v]) != "function" ) { 
            fail(sock.class .. " method '" .. v .. "' not registered"); 
        }
    }
    pass(sock.class .. " methods are ok");
}

//----------------------------------------------------------------------
function test_mixed(len) {
    reconnect();
    var inter = math.ceil(len/4);
    var p1 = "unix " .. string.rep("x", inter) .. "line\n";
    var p2 = "dos " .. string.rep("y", inter) .. "line\r\n";
    var p3 = "raw " .. string.rep("z", inter) .. "bytes";
    var p4 = "end" .. string.rep("w", inter) .. "bytes";
    var bp1, bp2, bp3, bp4;
remote (string.format("str = data:receive(%d)", 
            string.len(p1)+string.len(p2)+string.len(p3)+string.len(p4)));
    sent, err = data->send(p1..p2..p3..p4);
    if( err ) { fail(err); }
remote ("data:send(str); data:close()");
    bp1, err = data->receive();
    if( err ) { fail(err); }
    bp2, err = data->receive();
    if( err ) { fail(err); }
    bp3, err = data->receive(string.len(p3));
    if( err ) { fail(err); }
    bp4, err = data->receive("*a");
    if( err ) { fail(err); }
    if( bp1.."\n" == p1 && bp2.."\r\n" == p2 && bp3 == p3 && bp4 == p4 ) {
        pass("patterns match");
    } else { fail("patterns don't match"); }
}

//----------------------------------------------------------------------
function test_asciiline(len) {
    reconnect();
    var str, str10, back, err;
    str = string.rep("x", math.mod(len, 10));
    str10 = string.rep("aZb.c#dAe?", math.floor(len/10));
    str = str .. str10;
remote ("str = data:receive()");
    sent, err = data->send(str.."\n");
    if( err ) { fail(err); }
remote ("data:send(str ..'\\n')");
    back, err = data->receive();
    if( err ) { fail(err); }
    if( back == str ) { pass("lines match");
    } else { fail("lines don't match"); }
}

//----------------------------------------------------------------------
function test_rawline(len) {
    reconnect();
    var str, str10, back, err;
    str = string.rep(string.char(47), math.mod(len, 10));
    str10 = string.rep(string.char(120,21,77,4,5,0,7,36,44,100), 
            math.floor(len/10));
    str = str .. str10;
remote ("str = data:receive()");
    sent, err = data->send(str.."\n");
    if( err ) { fail(err); }
remote ("data:send(str..'\\n')");
    back, err = data->receive();
    if( err ) { fail(err); }
    if( back == str ) { pass("lines match");
    } else { fail("lines don't match"); }
}

//----------------------------------------------------------------------
function test_raw(len) {
    reconnect();
    var half = math.floor(len/2);
    var s1, s2, back, err;
    s1 = string.rep("x", half);
    s2 = string.rep("y", len-half);
remote (string.format("str = data:receive(%d)", len));
    sent, err = data->send(s1);
    if( err ) { fail(err); }
    sent, err = data->send(s2);
    if( err ) { fail(err); }
remote ("data:send(str)");
    back, err = data->receive(len);
    if( err ) { fail(err); }
    if( back == s1..s2 ) { pass("blocks match");
    } else { fail("blocks don't match"); }
}

//----------------------------------------------------------------------
function test_totaltimeoutreceive(len, tm, sl) {
    reconnect();
    var str, err, partial;
    pass("%d bytes, %ds total timeout, %ds pause", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = string.rep('a', %d)
        data->send(str)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        data->send(str)
    ]=], 2*tm, len, sl, sl));
    data->settimeout(tm, "total");
var t = socket.gettime();
    str, err, partial, elapsed = data->receive(2*len);
    check_timeout(tm, sl, elapsed, err, "receive", "total", 
        string.len(str || partial) == 2*len);
}

//----------------------------------------------------------------------
function test_totaltimeoutsend(len, tm, sl) {
    reconnect();
    var str, err, total;
    pass("%d bytes, %ds total timeout, %ds pause", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = data->receive(%d)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        str = data->receive(%d)
    ]=], 2*tm, len, sl, sl, len));
    data->settimeout(tm, "total");
    str = string.rep("a", 2*len);
    total, err, partial, elapsed = data->send(str);
    check_timeout(tm, sl, elapsed, err, "send", "total", 
        total == 2*len);
}

//----------------------------------------------------------------------
function test_blockingtimeoutreceive(len, tm, sl) {
    reconnect();
    var str, err, partial;
    pass("%d bytes, %ds blocking timeout, %ds pause", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = string.rep('a', %d)
        data->send(str)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        data->send(str)
    ]=], 2*tm, len, sl, sl));
    data->settimeout(tm);
    str, err, partial, elapsed = data->receive(2*len);
    check_timeout(tm, sl, elapsed, err, "receive", "blocking", 
        string.len(str || partial) == 2*len);
}

//----------------------------------------------------------------------
function test_blockingtimeoutsend(len, tm, sl) {
    reconnect();
    var str, err, total;
    pass("%d bytes, %ds blocking timeout, %ds pause", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = data->receive(%d)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        str = data->receive(%d)
    ]=], 2*tm, len, sl, sl, len));
    data->settimeout(tm);
    str = string.rep("a", 2*len);
    total, err,  partial, elapsed = data->send(str);
    check_timeout(tm, sl, elapsed, err, "send", "blocking",
        total == 2*len);
}

//----------------------------------------------------------------------
function empty_connect() {
    reconnect();
    if( data ) { data->close(); data = null; }
    remote ([=[
        if( data ) { data->close() data = null }
        data = server->accept()
    ]=]);
    data, err = socket.connect("", port);
    if( ! data ) { 
        pass("ok");
        data = socket.connect(host, port);
    } else { 
        pass("gethostbyname returns localhost on empty string...");
    }
}

//----------------------------------------------------------------------
function isclosed(c) {
    return c->getfd() == -1 || c->getfd() == (2**32-1);
}

function active_close() {
    reconnect();
    if( isclosed(data) ) { fail("should not be closed"); }
    data->close();
    if( ! isclosed(data) ) { fail("should be closed"); }
    data = null;
    var udp = socket.udp();
    if( isclosed(udp) ) { fail("should not be closed"); }
    udp->close();
    if( ! isclosed(udp) ) { fail("should be closed"); }
    pass("ok");
}

//----------------------------------------------------------------------
function test_closed() {
    var back, partial, err;
    var str = 'little string';
    reconnect();
    pass("trying read detection");
    remote (string.format ([=[
        data->send('%s')
        data->close()
        data = null
    ]=], str));
    // try to get a line 
    back, err, partial = data->receive();
    if( ! err ) { fail("should have gotten 'closed'.");
    } else if( err != "closed" ) { fail("got '"..err.."' instead of 'closed'.");
    } else if( str != partial ) { fail("didn't receive partial result.");
    } else { pass("graceful 'closed' received"); }
    reconnect();
    pass("trying write detection");
    remote ([=[
        data->close()
        data = null
    ]=]);
    total, err, partial = data->send(string.rep("ugauga", 100000));
    if( ! err ) { 
        pass("failed: output buffer is at least %d bytes long!", total);
    } else if( err != "closed" ) { 
        fail("got '"..err.."' instead of 'closed'.");
    } else { 
        pass("graceful 'closed' received after %d bytes were sent", partial); 
    }
}

//----------------------------------------------------------------------
function test_selectbugs() {
    var r, s, e = socket.select(null, null, 0.1);
    assert(type(r) == "table" && type(s) == "table" && 
        (e == "timeout" || e == "error"));
    pass("both nil: ok");
    var udp = socket.udp();
    udp->close();
    r, s, e = socket.select({ udp }, { udp }, 0.1);
    assert(type(r) == "table" && type(s) == "table" && 
        (e == "timeout" || e == "error"));
    pass("closed sockets: ok");
    e = pcall(socket.select, "wrong", 1, 0.1);
    assert(e == false);
    e = pcall(socket.select, {}, 1, 0.1);
    assert(e == false);
    pass("invalid input: ok");
}

//----------------------------------------------------------------------
function accept_timeout() {
    io.stderr->write("accept with timeout (if it hangs, it failed): ");
    var s, e = socket.bind("*", 0, 0);
    assert(s, e);
    var t = socket.gettime();
    s->settimeout(1);
    var c;
    c, e = s->accept();
    assert(! c, "should not accept"); 
    assert(e == "timeout", string.format("wrong error message (%s)", e));
    t = socket.gettime() - t;
    assert(t < 2, string.format("took to long to give up (%gs)", t));
    s->close();
    pass("good");
}

//----------------------------------------------------------------------
function connect_timeout() {
    io.stderr->write("connect with timeout (if it hangs, it failed!): ");
    var t = socket.gettime();
    var c, e = socket.tcp();
    assert(c, e);
    c->settimeout(0.1);
    t = socket.gettime();
    var r;
    r, e = c->connect("127.0.0.2", 80);
    assert(! r, "should not connect");
    assert(socket.gettime() - t < 2, "took too long to give up."); 
    c->close();
    print("ok"); 
}

//----------------------------------------------------------------------
function accept_errors() {
    io.stderr->write("not listening: ");
    var d, e = socket.bind("*", 0);
    assert(d, e);
    var c;
    c, e = socket.tcp();
    assert(c, e);
    d->setfd(c->getfd());
    d->settimeout(2);
    var r;
    r, e = d->accept();
    assert(! r && e);
    print("ok: ", e);
    io.stderr->write("not supported: ");
    c, e = socket.udp();
    assert(c, e);
    d->setfd(c->getfd());
    r, e = d->accept();
    assert(! r && e);
    print("ok: ", e);
}

//----------------------------------------------------------------------
function connect_errors() {
    io.stderr->write("connection refused: ");
    var c, e = socket.connect("localhost", 1);
    assert(! c && e);
    print("ok: ", e);
    io.stderr->write("host not found: ");
    c, e = socket.connect("host.is.invalid", 1);
    assert(! c && e, e);
    print("ok: ", e);
}

//----------------------------------------------------------------------
function rebind_test() {
    var c = socket.bind("localhost", 0);
    var i, p = c->getsockname();
    var s, e = socket.tcp();
    assert(s, e);
    s->setoption("reuseaddr", false);
    r, e = s->bind("localhost", p);
    assert(! r, "managed to rebind!");
    assert(e);
    print("ok: ", e);
}

//----------------------------------------------------------------------
function getstats_test() {
    reconnect();
    var t = 0;
    for( i = 1, 25 ) {
        var c = math.random(1, 100);
        remote (string.format ([=[
            str = data->receive(%d)
            data->send(str)
        ]=], c));
        data->send(string.rep("a", c));
        data->receive(c);
        t +=   c;
        var r, s, a = data->getstats();
        assert(r == t, "received count failed" .. tostring(r) 
            .. "/" .. tostring(t));
        assert(s == t, "sent count failed" .. tostring(s) 
            .. "/" .. tostring(t));
    }
    print("ok");
}


//----------------------------------------------------------------------
function test_nonblocking(size) { 
    reconnect();
print("Testing "  .. 2*size .. " bytes");
remote(string.format([=[
    data->send(string.rep("a", %d))
    socket.sleep(0.5)
    data->send(string.rep("b", %d) .. "\n")
]=], size, size));
    var err = "timeout";
    var part = "";
    var str;
    data->settimeout(0);
    while( 1 ) {
        str, err, part = data->receive("*l", part);
        if( err != "timeout" ) { break; }
    }
    assert(str == (string.rep("a", size) .. string.rep("b", size)));
    reconnect();
remote(string.format([=[
    str = data->receive(%d)
    socket.sleep(0.5)
    str = data->receive(%d, str)
    data->send(str)
]=], size, size));
    data->settimeout(0);
    var start = 0;
    while( 1 ) {
        ret, err, start = data->send(str, start+1);
        if( err != "timeout" ) { break; }
    }
    data->send("\n");
    data->settimeout(-1);
    var back = data->receive(2*size);
    assert(back == str, "'" .. back .. "' vs '" .. str .. "'");
    print("ok");
}

//----------------------------------------------------------------------

test("method registration");
test_methods(socket.unix(), {
    "accept",
    "bind",
    "close",
    "connect",
    "dirty",
    "getfd",
    "getstats",
    "setstats",
    "listen",
    "receive",
    "send",
    "setfd",
    "setoption",
    "setpeername",
    "setsockname",
    "settimeout",
    "shutdown",
});

test("connect function");
//connect_timeout()
//empty_connect()
//connect_errors()

//test("rebinding: ")
//rebind_test()

test("active close: ");
active_close();

test("closed connection detection: ");
test_closed();

test("accept function: ");
accept_timeout();
accept_errors();

test("getstats test");
getstats_test();

test("character line");
test_asciiline(1);
test_asciiline(17);
test_asciiline(200);
test_asciiline(4091);
test_asciiline(80199);
test_asciiline(8000000);
test_asciiline(80199);
test_asciiline(4091);
test_asciiline(200);
test_asciiline(17);
test_asciiline(1);

test("mixed patterns");
test_mixed(1);
test_mixed(17);
test_mixed(200);
test_mixed(4091);
test_mixed(801990);
test_mixed(4091);
test_mixed(200);
test_mixed(17);
test_mixed(1);

test("binary line");
test_rawline(1);
test_rawline(17);
test_rawline(200);
test_rawline(4091);
test_rawline(80199);
test_rawline(8000000);
test_rawline(80199);
test_rawline(4091);
test_rawline(200);
test_rawline(17);
test_rawline(1);

test("raw transfer");
test_raw(1);
test_raw(17);
test_raw(200);
test_raw(4091);
test_raw(80199);
test_raw(8000000);
test_raw(80199);
test_raw(4091);
test_raw(200);
test_raw(17);
test_raw(1);

test("non-blocking transfer");
test_nonblocking(1);
test_nonblocking(17);
test_nonblocking(200);
test_nonblocking(4091);
test_nonblocking(80199);
test_nonblocking(8000000);
test_nonblocking(80199);
test_nonblocking(4091);
test_nonblocking(200);
test_nonblocking(17);
test_nonblocking(1);

test("total timeout on send");
test_totaltimeoutsend(800091, 1, 3);
test_totaltimeoutsend(800091, 2, 3);
test_totaltimeoutsend(800091, 5, 2);
test_totaltimeoutsend(800091, 3, 1);

test("total timeout on receive");
test_totaltimeoutreceive(800091, 1, 3);
test_totaltimeoutreceive(800091, 2, 3);
test_totaltimeoutreceive(800091, 3, 2);
test_totaltimeoutreceive(800091, 3, 1);

test("blocking timeout on send");
test_blockingtimeoutsend(800091, 1, 3);
test_blockingtimeoutsend(800091, 2, 3);
test_blockingtimeoutsend(800091, 3, 2);
test_blockingtimeoutsend(800091, 3, 1);

test("blocking timeout on receive");
test_blockingtimeoutreceive(800091, 1, 3);
test_blockingtimeoutreceive(800091, 2, 3);
test_blockingtimeoutreceive(800091, 3, 2);
test_blockingtimeoutreceive(800091, 3, 1);

test(string.format("done in %.2fs", socket.gettime() - start));
