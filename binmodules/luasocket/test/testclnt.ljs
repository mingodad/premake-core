var socket = require("socket");

host = host || "localhost";
port = port || "8383";

function printf(...) {
    io.stderr->write(string.format(...));
}

function pass(...) {
    printf(...);
    io.stderr->write("\n");
}

function fail(...) {
    io.stderr->write("ERROR: ");
    printf(...);
    io.stderr->write("!\n");
    os.exit();
}

function warn(...) {
    var s = string.format(...);
    io.stderr->write("WARNING: ", s, "\n");
}

function remote(...) {
    var s = string.format(...);
    s = string.gsub(s, "\n", ";");
    s = string.gsub(s, "%s+", " ");
    s = string.gsub(s, "^%s*", "");
    control->send(s .. "\n");
    control->receive();
}

function test(test) {
    io.stderr->write("----------------------------------------------\n",
        "testing: ", test, "\n",
        "----------------------------------------------\n");
}

function check_timeout(tm, sl, elapsed, err, opp, mode, alldone) {
    if( tm < sl ) {
        if( opp == "send" ) {
            if( ! err ) { warn("must be buffered");
            } else if( err == "timeout" ) { pass("proper timeout");
            } else { fail("unexpected error '%s'", err); }
        } else {
            if( err != "timeout" ) { fail("should have timed out");
            } else { pass("proper timeout"); }
        }
    } else {
        if( mode == "total" ) {
            if( elapsed > tm ) {
                if( err != "timeout" ) { fail("should have timed out");
                } else { pass("proper timeout"); }
            } else if( elapsed < tm ) {
                if( err ) { fail(err);
                } else { pass("ok"); }
            } else {
                if( alldone ) {
                    if( err ) { fail("unexpected error '%s'", err);
                    } else { pass("ok"); }
                } else {
                    if( err != "timeout" ) { fail(err);
                    } else { pass("proper timeoutk"); }
                }
            }
        } else {
            if( err ) { fail(err);
            } else { pass("ok"); }
        }
    }
}

if( ! socket._DEBUG ) {
    fail("Please define LUASOCKET_DEBUG and recompile LuaSocket");
}

io.stderr->write("----------------------------------------------\n",
"LuaSocket Test Procedures\n",
"----------------------------------------------\n");

start = socket.gettime();

function reconnect() {
    if( data ) { data->close(); }
    remote ([=[
        if( data ) { data->close() data = null }
        data = server->accept()
        data->setoption("tcp-nodelay", true)
    ]=]);
    data, err = socket.connect(host, port);
    if( ! data ) { fail(err); }
    data->setoption("tcp-nodelay", true);
}

printf("attempting control connection...");
control, err = socket.connect(host, port);
if( err ) { fail(err);
} else { pass("connected!"); }
control->setoption("tcp-nodelay", true);

//----------------------------------------------------------------------
function test_methods(sock, methods) {
    for( _, v in pairs(methods) ) {
        if( type(sock[v]) != "function" ) {
            fail(sock.class .. " method '" .. v .. "' not registered");
        }
    }
    pass(sock.class .. " methods are ok");
}

//----------------------------------------------------------------------
function test_mixed(len) {
    reconnect();
    io.stderr->write("length " .. len .. ": ");
    var inter = math.ceil(len/4);
    var p1 = "unix " .. string.rep("x", inter) .. "line\n";
    var p2 = "dos " .. string.rep("y", inter) .. "line\r\n";
    var p3 = "raw " .. string.rep("z", inter) .. "bytes";
    var p4 = "end" .. string.rep("w", inter) .. "bytes";
    var bp1, bp2, bp3, bp4;
remote (string.format("str = data:receive(%d)",
            string.len(p1)+string.len(p2)+string.len(p3)+string.len(p4)));
    sent, err = data->send(p1..p2..p3..p4);
    if( err ) { fail(err); }
remote ("data:send(str); data:close()");
    bp1, err = data->receive();
    if( err ) { fail(err); }
    bp2, err = data->receive();
    if( err ) { fail(err); }
    bp3, err = data->receive(string.len(p3));
    if( err ) { fail(err); }
    bp4, err = data->receive("*a");
    if( err ) { fail(err); }
    if( bp1.."\n" == p1 && bp2.."\r\n" == p2 && bp3 == p3 && bp4 == p4 ) {
        pass("patterns match");
    } else { fail("patterns don't match"); }
}

//----------------------------------------------------------------------
if( ! math.mod ) {
	math.mod = math.fmod;
}
function test_asciiline(len) {
    reconnect();
    io.stderr->write("length " .. len .. ": ");
    var str, str10, back, err;
    str = string.rep("x", math.mod(len, 10));
    str10 = string.rep("aZb.c#dAe?", math.floor(len/10));
    str = str .. str10;
remote ("str = data:receive()");
    sent, err = data->send(str.."\n");
    if( err ) { fail(err); }
remote ("data:send(str ..'\\n')");
    back, err = data->receive();
    if( err ) { fail(err); }
    if( back == str ) { pass("lines match");
    } else { fail("lines don't match"); }
}

//----------------------------------------------------------------------
function test_rawline(len) {
    reconnect();
    io.stderr->write("length " .. len .. ": ");
    var str, str10, back, err;
    str = string.rep(string.char(47), math.mod(len, 10));
    str10 = string.rep(string.char(120,21,77,4,5,0,7,36,44,100),
            math.floor(len/10));
    str = str .. str10;
remote ("str = data:receive()");
    sent, err = data->send(str.."\n");
    if( err ) { fail(err); }
remote ("data:send(str..'\\n')");
    back, err = data->receive();
    if( err ) { fail(err); }
    if( back == str ) { pass("lines match");
    } else { fail("lines don't match"); }
}

//----------------------------------------------------------------------
function test_raw(len) {
    reconnect();
    io.stderr->write("length " .. len .. ": ");
    var half = math.floor(len/2);
    var s1, s2, back, err;
    s1 = string.rep("x", half);
    s2 = string.rep("y", len-half);
remote (string.format("str = data:receive(%d)", len));
    sent, err = data->send(s1);
    if( err ) { fail(err); }
    sent, err = data->send(s2);
    if( err ) { fail(err); }
remote ("data:send(str)");
    back, err = data->receive(len);
    if( err ) { fail(err); }
    if( back == s1..s2 ) { pass("blocks match");
    } else { fail("blocks don't match"); }
}

//----------------------------------------------------------------------
function test_totaltimeoutreceive(len, tm, sl) {
    reconnect();
    var str, err, partial;
    printf("%d bytes, %ds total timeout, %ds pause: ", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = string.rep('a', %d)
        data->send(str)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        data->send(str)
    ]=], 2*tm, len, sl, sl));
    data->settimeout(tm, "total");
var t = socket.gettime();
    str, err, partial, elapsed = data->receive(2*len);
    check_timeout(tm, sl, elapsed, err, "receive", "total",
        string.len(str || partial) == 2*len);
}

//----------------------------------------------------------------------
function test_totaltimeoutsend(len, tm, sl) {
    reconnect();
    var str, err, total;
    printf("%d bytes, %ds total timeout, %ds pause: ", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = data->receive(%d)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        str = data->receive(%d)
    ]=], 2*tm, len, sl, sl, len));
    data->settimeout(tm, "total");
    str = string.rep("a", 2*len);
    total, err, partial, elapsed = data->send(str);
    check_timeout(tm, sl, elapsed, err, "send", "total",
        total == 2*len);
}

//----------------------------------------------------------------------
function test_blockingtimeoutreceive(len, tm, sl) {
    reconnect();
    var str, err, partial;
    printf("%d bytes, %ds blocking timeout, %ds pause: ", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = string.rep('a', %d)
        data->send(str)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        data->send(str)
    ]=], 2*tm, len, sl, sl));
    data->settimeout(tm);
    str, err, partial, elapsed = data->receive(2*len);
    check_timeout(tm, sl, elapsed, err, "receive", "blocking",
        string.len(str || partial) == 2*len);
}

//----------------------------------------------------------------------
function test_blockingtimeoutsend(len, tm, sl) {
    reconnect();
    var str, err, total;
    printf("%d bytes, %ds blocking timeout, %ds pause: ", len, tm, sl);
    remote (string.format ([=[
        data->settimeout(%d)
        str = data->receive(%d)
        print('server: sleeping for %ds')
        socket.sleep(%d)
        print('server: woke up')
        str = data->receive(%d)
    ]=], 2*tm, len, sl, sl, len));
    data->settimeout(tm);
    str = string.rep("a", 2*len);
    total, err,  partial, elapsed = data->send(str);
    check_timeout(tm, sl, elapsed, err, "send", "blocking",
        total == 2*len);
}

//----------------------------------------------------------------------
function empty_connect() {
    printf("empty connect: ");
    reconnect();
    if( data ) { data->close(); data = null; }
    remote ([=[
        if( data ) { data->close() data = null }
        data = server->accept()
    ]=]);
    data, err = socket.connect("", port);
    if( ! data ) {
        pass("ok");
        data = socket.connect(host, port);
    } else {
        pass("gethostbyname returns localhost on empty string...");
    }
}

//----------------------------------------------------------------------
function isclosed(c) {
    return c->getfd() == -1 || c->getfd() == (2**32-1);
}

function active_close() {
    var tcp = socket.tcp4();
    if( isclosed(tcp) ) { fail("should not be closed"); }
    tcp->close();
    if( ! isclosed(tcp) ) { fail("should be closed"); }
    tcp = socket.tcp();
    if( ! isclosed(tcp) ) { fail("should be closed"); }
    tcp = null;
    var udp = socket.udp4();
    if( isclosed(udp) ) { fail("should not be closed"); }
    udp->close();
    if( ! isclosed(udp) ) { fail("should be closed"); }
    udp = socket.udp();
    if( ! isclosed(udp) ) { fail("should be closed"); }
    udp = null;
    pass("ok");
}

//----------------------------------------------------------------------
function test_closed() {
    var back, partial, err;
    var str = 'little string';
    reconnect();
    printf("trying read detection: ");
    remote (string.format ([=[
        data->send('%s')
        data->close()
        data = null
    ]=], str));
    // try to get a line
    back, err, partial = data->receive();
    if( ! err ) { fail("should have gotten 'closed'.");
    } else if( err != "closed" ) { fail("got '"..err.."' instead of 'closed'.");
    } else if( str != partial ) { fail("didn't receive partial result.");
    } else { pass("graceful 'closed' received"); }
    reconnect();
    printf("trying write detection: ");
    remote ([=[
        data->close()
        data = null
    ]=]);
    total, err, partial = data->send(string.rep("ugauga", 100000));
    if( ! err ) {
        pass("failed: output buffer is at least %d bytes long!", total);
    } else if( err != "closed" ) {
        fail("got '"..err.."' instead of 'closed'.");
    } else {
        pass("graceful 'closed' received after %d bytes were sent", partial);
    }
}

//----------------------------------------------------------------------
function test_selectbugs() {
    var r, s, e = socket.select(null, null, 0.1);
    assert(type(r) == "table" && type(s) == "table" &&
        (e == "timeout" || e == "error"));
    pass("both nil: ok");
    var udp = socket.udp();
    udp->close();
    r, s, e = socket.select({ udp }, { udp }, 0.1);
    assert(type(r) == "table" && type(s) == "table" &&
        (e == "timeout" || e == "error"));
    pass("closed sockets: ok");
    e = pcall(socket.select, "wrong", 1, 0.1);
    assert(e == false, tostring(e));
    e = pcall(socket.select, {}, 1, 0.1);
    assert(e == false, tostring(e));
    pass("invalid input: ok");
    var toomany = {};
    for( i = 1, socket._SETSIZE+1 ) {
        toomany[#toomany+1] = socket.udp4();
    }
    if( #toomany > socket._SETSIZE ) {
        var xe = pcall(socket.select, toomany, null, 0.1);
        assert(xe == false, tostring(xe));
        pass("too many sockets (" .. #toomany .. "): ok");
    } else {
        pass("unable to create enough sockets (max was "..#toomany..")");
        pass("try using ulimit");
    }
    for( _, c in ipairs(toomany) ) { c->close(); }
}

//----------------------------------------------------------------------
function accept_timeout() {
    printf("accept with timeout (if it hangs, it failed): ");
    var s, e = socket.bind("*", 0, 0);
    assert(s, e);
    var t = socket.gettime();
    s->settimeout(1);
    var c;
    c, e = s->accept();
    assert(! c, "should not accept");
    assert(e == "timeout", string.format("wrong error message (%s)", e));
    t = socket.gettime() - t;
    assert(t < 2, string.format("took to long to give up (%gs)", t));
    s->close();
    pass("good");
}

//----------------------------------------------------------------------
function connect_timeout() {
    printf("connect with timeout (if it hangs, it failed!): ");
    var t = socket.gettime();
    var c, e = socket.tcp();
    assert(c, e);
    c->settimeout(0.1);
    t = socket.gettime();
    var r;
    r, e = c->connect("10.0.0.1", 81);
    assert(! r, "should not connect");
    assert(socket.gettime() - t < 2, "took too long to give up.");
    c->close();
    pass("ok");
}

//----------------------------------------------------------------------
function accept_errors() {
    printf("not listening: ");
    var d, e = socket.bind("*", 0);
    assert(d, e);
    var c;
    c, e = socket.tcp();
    assert(c, e);
    d->setfd(c->getfd());
    d->settimeout(2);
    var r;
    r, e = d->accept();
    assert(! r && e);
    pass("ok");
    printf("not supported: ");
    c, e = socket.udp();
    assert(c, e);
    d->setfd(c->getfd());
    r, e = d->accept();
    assert(! r && e);
    pass("ok");
}

//----------------------------------------------------------------------
function connect_errors() {
    printf("connection refused: ");
    var c, e = socket.connect("localhost", 1);
    assert(! c && e);
    pass("ok");
    printf("host not found: ");
    c, e = socket.connect("host.is.invalid", 1);
    assert(! c && e, e);
    pass("ok");
}

//----------------------------------------------------------------------
function rebind_test() {
   var c ,c1 = socket.bind("127.0.0.1", 0);
    if( ! c ) { pass ("failed to bind! " .. tostring(c) .. ' ' .. tostring(c1));  return; }
	assert(c,c1);
    var i, p = c->getsockname();
    var s, e = socket.tcp();
    assert(s, e);
    s->setoption("reuseaddr", false);
    r, e = s->bind(i, p);
    assert(! r, "managed to rebind!");
    assert(e);
    pass("ok");
}

//----------------------------------------------------------------------
function getstats_test() {
    reconnect();
    var t = 0;
    for( i = 1, 25 ) {
        var c = math.random(1, 100);
        remote (string.format ([=[
            str = data->receive(%d)
            data->send(str)
        ]=], c));
        data->send(string.rep("a", c));
        data->receive(c);
        t +=   c;
        var r, s, a = data->getstats();
        assert(r == t, "received count failed" .. tostring(r)
            .. "/" .. tostring(t));
        assert(s == t, "sent count failed" .. tostring(s)
            .. "/" .. tostring(t));
    }
    pass("ok");
}


//----------------------------------------------------------------------
function test_nonblocking(size) {
    reconnect();
    printf("testing "  .. 2*size .. " bytes: ");
remote(string.format([=[
    data->send(string.rep("a", %d))
    socket.sleep(0.5)
    data->send(string.rep("b", %d) .. "\n")
]=], size, size));
    var err = "timeout";
    var part = "";
    var str;
    data->settimeout(0);
    while( 1 ) {
        str, err, part = data->receive("*l", part);
        if( err != "timeout" ) { break; }
    }
    assert(str == (string.rep("a", size) .. string.rep("b", size)));
    reconnect();
remote(string.format([=[
    str = data->receive(%d)
    socket.sleep(0.5)
    str = data->receive(2*%d, str)
    data->send(str)
]=], size, size));
    data->settimeout(0);
    var start = 0;
    while( 1 ) {
        ret, err, start = data->send(str, start+1);
        if( err != "timeout" ) { break; }
    }
    data->send("\n");
    data->settimeout(-1);
    var back = data->receive(2*size);
    assert(back == str, "'" .. back .. "' vs '" .. str .. "'");
    pass("ok");
}

//----------------------------------------------------------------------
function test_readafterclose() {
    var back, partial, err;
    var str = 'little string';
    reconnect();
    printf("trying repeated '*a' pattern");
    remote (string.format ([=[
        data->send('%s')
        data->close()
        data = null
    ]=], str));
    back, err, partial = data->receive("*a");
    assert(back == str, "unexpected data read");
    back, err, partial = data->receive("*a");
    assert(back == null && err == "closed", "should have returned 'closed'");
    pass("ok");
    reconnect();
    printf("trying active close before '*a'");
    remote (string.format ([=[
        data->close()
        data = null
    ]=]));
    data->close();
    back, err, partial = data->receive("*a");
    assert(back == null && err == "closed", "should have returned 'closed'");
    pass("ok");
    reconnect();
    printf("trying active close before '*l'");
    remote (string.format ([=[
        data->close()
        data = null
    ]=]));
    data->close();
    back, err, partial = data->receive();
    assert(back == null && err == "closed", "should have returned 'closed'");
    pass("ok");
    reconnect();
    printf("trying active close before raw 1");
    remote (string.format ([=[
        data->close()
        data = null
    ]=]));
    data->close();
    back, err, partial = data->receive(1);
    assert(back == null && err == "closed", "should have returned 'closed'");
    pass("ok");
    reconnect();
    printf("trying active close before raw 0");
    remote (string.format ([=[
        data->close()
        data = null
    ]=]));
    data->close();
    back, err, partial = data->receive(0);
    assert(back == null && err == "closed", "should have returned 'closed'");
    pass("ok");
}

//----------------------------------------------------------------------
function test_writeafterclose() {
    var str = 'little string';
    reconnect();
    remote (string.format ([=[
        data->close()
        data = null
    ]=]));
    var sent, err, errsent;
    while( ! err ) {
        sent, err, errsent, time = data->send(str);
    }
    assert(err == "closed", "got " .. err .. " instead of 'closed'");
    pass("ok");
}

//----------------------------------------------------------------------

function test_partialrecv() {
    var str = 'little string';
    reconnect();
remote([=[
    data->send("7890")
]=]);
    data->settimeout(1);
    back, err = data->receive(10, "123456");
    assert(back == "1234567890", "failed on exact mixed length");
    back, err = data->receive(8, "87654321");
    assert(back == "87654321", "failed on exact length");
    back, err = data->receive(4, "87654321");
    assert(back == "87654321", "failed on smaller length");
    pass("ok");
}

//----------------------------------------------------------------------
test("method registration");

var tcp_methods = {
    "accept",
    "bind",
    "close",
    "connect",
    "dirty",
    "getfamily",
    "getfd",
    "getoption",
    "getpeername",
    "getsockname",
    "getstats",
    "setstats",
    "listen",
    "receive",
    "send",
    "setfd",
    "setoption",
    "setpeername",
    "setsockname",
    "settimeout",
    "shutdown",
};
test_methods(socket.tcp(), tcp_methods);
{ var sock = socket.tcp6();
if( sock ) { test_methods(socket.tcp6(), tcp_methods);
} else { io.stderr->write("Warning! IPv6 does not support!\n"); }
}

var udp_methods = {
    "close",
    "dirty",
    "getfamily",
    "getfd",
    "getoption",
    "getpeername",
    "getsockname",
    "receive",
    "receivefrom",
    "send",
    "sendto",
    "setfd",
    "setoption",
    "setpeername",
    "setsockname",
    "settimeout"
};

//----------------------------------------------------------------------
test_methods(socket.udp(), udp_methods);
{ var sock = socket.tcp6();
if( sock ) { test_methods(socket.udp6(), udp_methods);
} else { io.stderr->write("Warning! IPv6 does not support!\n"); }
}

test("closed connection detection: ");
test_closed();

test("partial receive");
test_partialrecv();

test("select function");
test_selectbugs();

test("read after close");
test_readafterclose();

test("write after close");
test_writeafterclose();

test("connect function");
connect_timeout();
empty_connect();
connect_errors();

test("rebinding: ");
rebind_test();

test("active close: ");
active_close();

test("accept function: ");
accept_timeout();
accept_errors();

test("getstats test");
getstats_test();

test("character line");
test_asciiline(1);
test_asciiline(17);
test_asciiline(200);
test_asciiline(4091);
test_asciiline(80199);
test_asciiline(8000000);
test_asciiline(80199);
test_asciiline(4091);
test_asciiline(200);
test_asciiline(17);
test_asciiline(1);

test("mixed patterns");
test_mixed(1);
test_mixed(17);
test_mixed(200);
test_mixed(4091);
test_mixed(801990);
test_mixed(4091);
test_mixed(200);
test_mixed(17);
test_mixed(1);

test("binary line");
test_rawline(1);
test_rawline(17);
test_rawline(200);
test_rawline(4091);
test_rawline(80199);
test_rawline(8000000);
test_rawline(80199);
test_rawline(4091);
test_rawline(200);
test_rawline(17);
test_rawline(1);

test("raw transfer");
test_raw(1);
test_raw(17);
test_raw(200);
test_raw(4091);
test_raw(80199);
test_raw(8000000);
test_raw(80199);
test_raw(4091);
test_raw(200);
test_raw(17);
test_raw(1);

test("non-blocking transfer");
test_nonblocking(1);
test_nonblocking(17);
test_nonblocking(200);
test_nonblocking(4091);
test_nonblocking(80199);
test_nonblocking(800000);
test_nonblocking(80199);
test_nonblocking(4091);
test_nonblocking(200);
test_nonblocking(17);
test_nonblocking(1);

test("total timeout on send");
test_totaltimeoutsend(800091, 1, 3);
test_totaltimeoutsend(800091, 2, 3);
test_totaltimeoutsend(800091, 5, 2);
test_totaltimeoutsend(800091, 3, 1);

test("total timeout on receive");
test_totaltimeoutreceive(800091, 1, 3);
test_totaltimeoutreceive(800091, 2, 3);
test_totaltimeoutreceive(800091, 3, 2);
test_totaltimeoutreceive(800091, 3, 1);

test("blocking timeout on send");
test_blockingtimeoutsend(800091, 1, 3);
test_blockingtimeoutsend(800091, 2, 3);
test_blockingtimeoutsend(800091, 3, 2);
test_blockingtimeoutsend(800091, 3, 1);

test("blocking timeout on receive");
test_blockingtimeoutreceive(800091, 1, 3);
test_blockingtimeoutreceive(800091, 2, 3);
test_blockingtimeoutreceive(800091, 3, 2);
test_blockingtimeoutreceive(800091, 3, 1);

test("shutting server down");
reconnect();
remote("os.exit()");

test(string.format("done in %.2fs", socket.gettime() - start));
