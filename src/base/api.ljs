//
// api.ljs
// Implementation of the workspace, project, and configuration APIs.
// Author Jason Perkins
// Copyright (c) 2002-2015 Jason Perkins and the Premake project
//

	var p = premake;
	p.api = {};

	var api = p.api;
	var configset = p.configset;



//-
// Set up a place to store the current active objects in each configuration
// scope (e.g. wprkspaces, projects, groups, and configurations). This likely
// ought to be internal scope, but it is useful for testing.
//-

	api.scope = {};



//-
// Define a new class of configuration container. A container can receive and
// store configuration blocks, which are what hold the individial settings
// from the scripts. A container can also hold one or more kinds of child
// containers; a workspace can contain projects, for instance.
//
// @param containerName
//    The name of the new container type, e.g. "workspace". Used to define a
//    corresponding global function, e.g. workspace() to create new instances
//    of the container.
// @param parentContainer (optional)
//    The container that can contain this one. For a project, this would be
//    the workspace container class.
// @param extraScopes (optional)
//    Each container can hold fields scoped to itself (by putting the container's
//    class name into its scope attribute), or any of the container's children.
//    If a container can hold scopes other than these (i.e. "config"), it can
//    provide a list of those scopes in this argument.
// @returns
//    The newly defined container class.
//-

	function api.container(containerName, parentContainer, extraScopes) {
		var class, err = p.container.newClass(containerName, parentContainer, extraScopes);
		if( ! class ) {
			error(err, 2);
		}

		_G[containerName] = function(name) {
			var c = api._setContainer(class, name);
			if( api._isIncludingExternal ) {
				c.external = true;
			}
			return c;
		};

		_G["external" .. containerName] = function(name) {
			var c = _G[containerName](name);
			c.external = true;
			return c;
		};

		// for backward compatibility
		p.alias(_G, "external" .. containerName, "external" .. containerName->capitalized());

		return class;
	}



//-
// Register a general-purpose includeExternal() call which works just like
// include(), but marks any containers created while evaluating the included
// scripts as external. It also, loads the file regardless of how many times
// it has been loaded already.
//-

	function includeexternal(fname) {
		var fullPath = p.findProjectScript(fname);
		api._isIncludingExternal = true;
		fname = fullPath || fname;
		dofile(fname);
		api._isIncludingExternal = null;
	}

	p.alias(_G, "includeexternal", "includeExternal");



//-
// Return the global configuration container.
//-

	function api.rootContainer() {
		return api.scope.global;
	}



//-
// Activate a new configuration container, making it the target for all
// subsequent configuration settings. When you call workspace() or project()
// to active a container, that call comes here (see api.container() for the
// details on how that happens).
//
// @param class
//    The container class being activated, e.g. a project or workspace.
// @param name
//    The name of the container instance to be activated. If a container
//    (e.g. project) with this name does not already exist it will be
//    created. If name is not set, the last activated container of this
//    class will be made current again.
// @return
//    The container instance.
//-

	function api._setContainer(class, name) {
		var instance;

		// for backward compatibility, "*" activates the parent container
		if( name == "*" ) {
			return api._setContainer(class.parent);
		}

		// if name is not set, use whatever was last made current
		if( ! name ) {
			instance = api.scope[class.name];
			if( ! instance ) {
				error("no " .. class.name .. " in scope", 3);
			}
		}

		// otherwise, look up the instance by name
		var parent;
		if( ! instance && class.parent ) {
			parent = api.scope[class.parent.name];
			if( ! parent ) {
				error("no " .. class.parent.name .. " in scope", 3);
			}
			instance = p.container.getChild(parent, class, name);
		}

		// if I have an existing instance, create a new configuration
		// block for it so I don't pick up an old filter
		if( instance ) {
			configset.addFilter(instance, {}, os.getcwd());
		}

		// otherwise, a new instance
		if( ! instance ) {
			instance = class.new(name, parent);
			if( parent ) {
				p.container.addChild(parent, instance);
			}
		}

		// clear out any active child containers that might be active
		// (recursive call, so needs to be its own function)
		api._clearContainerChildren(class);

		// active this container, as well as it ancestors
		if( ! class.placeholder ) {
			api.scope.current = instance;
		}

		while( instance ) {
			api.scope[instance.class.name] = instance;
			if( instance.class.alias ) {
				api.scope[instance.class.alias] = instance;
			}
			instance = instance.parent;
		}

		return api.scope.current;
	}

	function api._clearContainerChildren(class) {
		for( childClass in p.container.eachChildClass(class) ) {
			api.scope[childClass.name] = null;
			if( childClass.alias ) {
				api.scope[childClass.alias] = null;
			}
			api._clearContainerChildren(childClass);
		}
	}



//-
// Register a new API function. See the built-in API definitions in
// _premake_init.ljs for lots of usage examples.
//
// A new global function will be created to receive values for the field.
// List fields will also receive a `remove...()` function to remove values.
//
// @param field
//    A table describing the new field, with these keys:
//
//     name     The API name of the new field. This is used to create a global
//              function with the same name, and so should follow Lua symbol
//              naming conventions. (required)
//     scope    The scoping level at which this value can be used; see list
//              below. (required)
//     kind     The type of values that can be stored into this field; see
//              list below. (required)
//     allowed  An array of valid values for this field, or a function which
//              accepts a value as input and returns the canonical value as a
//              result, or nil if the input value is invalid. (optional)
//     tokens   A boolean indicating whether token expansion should be
//              performed on this field.
//
//   The available field scopes are:
//
//     project  The field applies to workspaces and projects.
//     config   The field applies to workspaces, projects, and individual build
//              configurations.
//
//   The available field kinds are:
//
//     string     A simple string value.
//     path       A file system path. The value will be made into an absolute
//                path, but no wildcard expansion will be performed.
//     file       One or more file names. Wilcard expansion will be performed,
//                and the results made absolute. Implies a list.
//     directory  One of more directory names. Wildcard expansion will be
//                performed, and the results made absolute. Implies a list.
//     mixed      A mix of simple string values and file system paths. Values
//                which contain a directory separator ("/") will be made
//                absolute; other values will be left intact.
//     table      A table of values. If the input value is not a table, it is
//                wrapped in one.
//-

	function api.register(field) {
		// verify the name
		var name = field.name;
		if( ! name ) {
			error("missing name", 2);
		}

		if( rawget(_G, name) ) {
			error("name '" .. name .. "' in use", 2);
		}

		// add this new field to my master list
		field, err = p.field.new(field);
		if( ! field ) {
			error(err);
		}


		// Flag fields which contain filesystem paths. The context object will
		// use this information when expanding tokens, to ensure that the paths
		// are still well-formed after replacements.

		field.paths = p.field.property(field, "paths");

		// Add preprocessed, lowercase keys to the allowed and aliased value
		// lists to speed up value checking later on.

		if( type(field.allowed) == "table" ) {
			for( i, item in ipairs(field.allowed) ) {
				field.allowed[item->lower()] = item;
			}
		}

		if( type(field.aliases) == "table" ) {
			var keys = table.keys(field.aliases);
			for( i, key in ipairs(keys) ) {
				field.aliases[key->lower()] = field.aliases[key];
			}
		}

		// create a setter function for it
		_G[name] = function(value) {
			return api.storeField(field, value);
		};

		if( p.field.removes(field) ) {
			_G["remove" .. name] = function(value) {
				return api.remove(field, value);
			};
		}

		return field;
	}



//-
// Unregister a field definition, removing its functions and field
// list entries.
//-

	function api.unregister(field) {
		if( type(field) == "string" ) {
			field = p.field.get(field);
		}
		p.field.unregister(field);
		_G[field.name] = null;
		_G["remove" .. field.name] = null;
	}



//-
// Create an alias to one of the canonical API functions. This creates
// new setter and remover names pointing to the same functions.
//
// @param original
//    The name of the function to be aliased (a string value).
// @param alias
//    The alias name (another string value).
//-

	function api.alias(original, alias) {
		p.alias(_G, original, alias);
		if( _G["remove" .. original] ) {
			p.alias(_G, "remove" .. original, "remove" .. alias);
		}
	}



//
// Add a new value to a field's list of allowed values.
//
// @param fieldName
//    The name of the field to which to add the value.
// @param value
//    The value to add. May be a single string value, or an array
//    of values.
//

	function api.addAllowed(fieldName, value) {
		var field = p.field.get(fieldName);
		if( ! field ) {
			error("No such field: " .. fieldName, 2);
		}

		if( type(value) == "table" ) {
			for( i, item in ipairs(value) ) {
				api.addAllowed(fieldName, item);
			}
		} else {
			field.allowed = field.allowed || {};
			if( field.allowed[value->lower()] == null ) {
				table.insert(field.allowed, value);
				field.allowed[value->lower()] = value;
			}
		}
	}



//
// Add a new value to a field's list of allowed values.
//
// @param fieldName
//    The name of the field to which to add the value.
// @param value
//    The value to add. May be a single string value, or an array
//    of values.
//

	function api.addAliases(fieldName, value) {
		var field = p.field.get(fieldName);
		if( ! field ) {
			error("No such field: " .. fieldName, 2);
		}

		field.aliases = field.aliases || {};
		for( k, v in pairs(value) ) {
			field.aliases[k] = v;
			field.aliases[k->lower()] = v;
		}
	}



//
// Mark an API field as deprecated.
//
// @param name
//    The name of the field to mark as deprecated.
// @param message
//    A optional message providing more information, to be shown
//    as part of the deprecation warning message.
// @param handler
//    A function to call when the field is used. Passes the value
//    provided to the field as the only argument.
//

	function api.deprecateField(name, message, handler) {
		p.fields[name].deprecated = {
			handler = handler,
			message = message
		};
	}


//
// Mark a specific value of a field as deprecated.
//
// @param name
//    The name of the field containing the value.
// @param value
//    The value or values to mark as deprecated. May be a string
//    for a single value or an array of multiple values.
// @param message
//    A optional message providing more information, to be shown
//    as part of the deprecation warning message.
// @param addHandler
//    A function to call when the value is used, receiving the
//    value as its only argument.
// @param removeHandler
//    A function to call when the value is removed from a list
//    field, receiving the value as its only argument (optional).
//

	function api.deprecateValue(name, value, message, addHandler, removeHandler) {
		if( type(value) == "table" ) {
			for( _, v in pairs(value) ) {
				api.deprecateValue(name, v, message, addHandler, removeHandler);
			}
		} else {
			var field = p.fields[name];
			field.deprecated = field.deprecated || {};
			field.deprecated[value] = {
				add = addHandler,
				remove = removeHandler,
				message = message
			};
		}
	}


//
// Control the handling of API deprecations.
//
// @param value
//    One of "on" to enable the deprecation behavior, "off" to disable it,
//    and "error" to raise an error instead of logging a warning.
//

	function api.deprecations(value) {
		value = value->lower();
		if( ! table.contains({ "on", "off", "error"}, value) ) {
			error("Invalid value: " .. value, 2);
		}
		api._deprecations = value->lower();
	}

	api._deprecations = "on";



//-
// Return the target container instance for a field.
//
// @param field
//    The field being set or fetched.
// @return
//    The currently active container instance if one is available, or nil if
//    active container is of the wrong class.
//-

	function api.target(field) {
		if( p.container.classCanContain(api.scope.current.class, field.scope) ) {
			return api.scope.current;
		}
		return null;
	}



//
// Callback for all API functions; everything comes here first, and then
// gets parceled out to the individual set...() functions.
//

	function api.storeField(field, value) {
		if( value == null ) {
			return;
		}

		if( field.deprecated && type(field.deprecated.handler) == "function" ) {
			field.deprecated.handler(value);
			if( field.deprecated.message && api._deprecations != "off" ) {
				var caller = filelineinfo(2);
				var key = field.name .. "_" .. caller;
				p.warnOnce(key, "the field %s has been deprecated and will be removed.\n   %s\n   @%s\n", field.name, field.deprecated.message, caller);
				if( api._deprecations == "error" ) {
					error("deprecation errors enabled", 3);
				}
			}
		}

		var target = api.target(field);
		if( ! target ) {
			var err = string.format("unable to set %s in %s scope, should be %s", field.name, api.scope.current.class.name, table.concat(field.scopes, ", "));
			error(err, 3);
		}

		var status, err = configset.store(target, field, value);
		if( err ) {
			error(err, 3);
		}
	}



//
// The remover: adds values to be removed to the "removes" field on
// current configuration. Removes are keyed by the associated field,
// so the call `removedefines("X")` will add the entry:
//  cfg.removes["defines"] = { "X" }
//

	function api.remove(field, value) {
		// right now, ignore calls with no value; later might want to
		// return the current baked value
		if( value == null ) { return; }

		var target = api.target(field);
		if( ! target ) {
			var err = string.format("unable to remove %s from %s scope, should be %s", field.name, api.scope.current.class.name, table.concat(field.scopes, ", "));
			error(err, 3);
		}

		var hasDeprecatedValues = (type(field.deprecated) == "table");

		// Build a list of values to be removed. If this field has deprecated
		// values, check to see if any of those are going to be removed by this
		// call (which means matching against any provided wildcards) and call
		// the appropriate logic for removing that value.

		var removes = {};

		var function check(value) {
			if( field.deprecated[value] ) {
				var handler = field.deprecated[value];
				if( handler.remove ) { handler.remove(value); }
				if( handler.message && api._deprecations != "off" ) {
					var caller = filelineinfo(8);
					var key = field.name .. "_" .. value .. "_" .. caller;
					p.warnOnce(key, "the %s value %s has been deprecated and will be removed.\n   %s\n   @%s\n", field.name, value, handler.message, caller);
					if( api._deprecations == "error" ) {
						error ({ msg="deprecation errors enabled" });
					}
				}
			}
		}

		var function recurse(value) {
			if( type(value) == "table" ) {
				table.foreachi(value, recurse);

			} else if( hasDeprecatedValues && value->contains("*") ) {
				var current = configset.fetch(target, field, {
					matcher = function(cset, block, filter) {
						var current = cset.current;
						return criteria.matches(current._criteria, block._criteria.terms || {}) ||
							   criteria.matches(block._criteria, current._criteria.terms || {});
					}
				});

				var mask = path.wildcards(value);
				for( _, item in ipairs(current) ) {
					if( item->match(mask) == item ) {
						recurse(item);
					}
				}
			} else {
				var xvalue, err, additional = api.checkValue(field, value);
				if( err ) {
					error ({ msg=err });
				}

				if( field.deprecated ) {
					check(xvalue);
				}

				table.insert(removes, xvalue);
				if( additional ) {
					table.insert(removes, additional);
				}
			}
		}

		var ok, err = pcall(function () {
			recurse(value);
		});

		if( ! ok ) {
			if( type(err) == "table" ) {
				err = err.msg;
			}
			error(err, 3);
		}

		configset.remove(target, field, removes);
	}



//
// Check to see if a value is valid for a particular field.
//
// @param field
//    The field to check against.
// @param value
//    The value to check.
// @param kind
//    The kind of data currently being checked, corresponding to
//    one segment of the field's kind string (e.g. "string"). If
//    not set, defaults to "string".
// @return
//    If the value is valid for this field, the canonical version
//    of that value is returned. If the value is not valid two
//    values are returned: nil, and an error message.
//

	function api.checkValue(field, value, kind) {
		if( ! field.allowed ) {
			return value;
		}

		var canonical, result;
		var lowerValue = value->lower();

		if( field.aliases ) {
			canonical = field.aliases[lowerValue];
		}

		if( ! canonical ) {
			if( type(field.allowed) == "function" ) {
				canonical = field.allowed(value, kind || "string");
			} else {
				canonical = field.allowed[lowerValue];
			}
		}

		if( ! canonical ) {
			return null, "invalid value '" .. value .. "' for " .. field.name;
		}

		if( field.deprecated && field.deprecated[canonical] ) {
			var handler = field.deprecated[canonical];
			handler.add(canonical);
			if( handler.message && api._deprecations != "off" ) {
				var caller =  filelineinfo(9);
				var key = field.name .. "_" .. value .. "_" .. caller;
				p.warnOnce(key, "the %s value %s has been deprecated and will be removed.\n   %s\n   @%s\n", field.name, canonical, handler.message, caller);
				if( api._deprecations == "error" ) {
					return null, "deprecation errors enabled";
				}
			}
		}

		return canonical;
	}



//-
// Reset the API system, clearing out any temporary or cached values.
// Used by the automated testing framework to clear state between
// individual test runs.
//-

	var numBuiltInGlobalBlocks;

	function api.reset() {
		if( numBuiltInGlobalBlocks == null ) {
			numBuiltInGlobalBlocks = #api.scope.global.blocks;
		}

		for( containerClass in p.container.eachChildClass(p.global) ) {
			api.scope.global[containerClass.pluralName] = {};
		}

		api.scope.current = api.scope.global;

		var currentGlobalBlockCount = #api.scope.global.blocks;
		for( i = currentGlobalBlockCount, numBuiltInGlobalBlocks, -1 ) {
			table.remove(api.scope.global.blocks, i);
		}

		configset.addFilter(api.scope.current, {}, os.getcwd());
	}



//
// Arrays are integer indexed tables; unlike lists, a new array value
// will replace the old one, rather than merging both.
//

	premake.field.kind("array", {
		store = function(field, current, value, processor) {
			if( type(value) != "table" ) {
				value = { value };
			}

			for( i, item in ipairs(value) ) {
				value[i] = processor(field, null, value[i]);
			}

			return value;
		},
		compare = function(field, a, b, processor) {
			if( a == null || b == null || #a != #b ) {
				return false;
			}
			for( i = 1, #a ) {
				if( ! processor(field, a[i], b[i]) ) {
					return false;
				}
			}
			return true;
		}
	});



//-
// Boolean field kind; converts common yes/no strings into true/false values.
//-

	premake.field.kind("boolean", {
		store = function(field, current, value, processor) {
			var mapping = {
				["false"] = false,
				["no"] = false,
				["off"] = false,
				["on"] = true,
				["true"] = true,
				["yes"] = true,
			};

			if( type(value) == "string" ) {
				value = mapping[value->lower()];
				if( value == null ) {
					error ({ msg="expected boolean; got " .. value });
				}
				return value;
			}

			if( type(value) == "boolean" ) {
				return value;
			}

			if( type(value) == "number" ) {
				return (value != 0);
			}

			return (value != null);
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		}
	});




//
// Directory data kind; performs wildcard directory searches, converts
// results to absolute paths.
//

	premake.field.kind("directory", {
		paths = true,
		store = function(field, current, value, processor) {
			return path.getabsolute(value);
		},
		remove = function(field, current, value, processor) {
			return path.getabsolute(value);
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		},

		translate = function(field, current, _, processor) {
			if( current->find("*") ) {
				return os.matchdirs(current);
			}
			return { current };
		}
	});



//
// File data kind; performs wildcard file searches, converts results
// to absolute paths.
//

	premake.field.kind("file", {
		paths = true,
		store = function(field, current, value, processor) {
			return path.getabsolute(value);
		},
		remove = function(field, current, value, processor) {
			return path.getabsolute(value);
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		},

		translate = function(field, current, _, processor) {
			if( current->find("*") ) {
				return os.matchfiles(current);
			}
			return { current };
		}
	});



//
// Function data kind; this isn't terribly useful right now, but makes
// a nice extension point for modules to build on.
//

	premake.field.kind("function", {
		store = function(field, current, value, processor) {
			var t = type(value);
			if( t != "function" ) {
				error ({ msg="expected function; got " .. t });
			}
			return value;
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		}
	});



//
// Integer data kind; validates inputs.
//

	premake.field.kind("integer", {
		store = function(field, current, value, processor) {
			var t = type(value);
			if( t != "number" ) {
				error ({ msg="expected number; got " .. t });
			}
			if( math.floor(value) != value ) {
				error ({ msg="expected integer; got " .. tostring(value) });
			}
			return value;
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		}
	});



//-
// Key-value data kind definition. Merges key domains; values may be any kind.
//-

	var function storeKeyed(field, current, value, processor) {
		current = current || {};

		for( k, v in pairs(value) ) {
			if( processor ) {
				v = processor(field, current[k], v);
			}
			current[k] = v;
		}

		return current;
	}


	var function mergeKeyed(field, current, value, processor) {
		value = value || {};
		for( k, v in pairs(value) ) {
			current[k] = v;
		}
		return current;
	}


	premake.field.kind("keyed", {
		store = storeKeyed,
		merge = mergeKeyed,
		compare = function(field, a, b, processor) {
			if( a == null || b == null ) {
				return false;
			}
			for( k in pairs(a) ) {
				if( ! processor(field, a[k], b[k]) ) {
					return false;
				}
			}
			return true;
		},

		translate = function(field, current, _, processor) {
			if( ! processor ) {
				return { current };
			}
			for( k, v in pairs(current) ) {
				current[k] = processor(field, v, null)[1];
			}
			return { current };
		}
	});


//-
// List data kind definition. Actually a misnomer, lists are more like sets in
// that duplicate values are weeded out; each will only appear once. Can
// contain any other kind of data.
//-

	var function storeListItem(current, item, allowDuplicates) {
		if( ! allowDuplicates && current[item] ) {
			table.remove(current, table.indexof(current, item));
		}
		table.insert(current, item);
		current[item] = item;
	}


	var function storeList(field, current, value, processor) {
		if( type(value) == "table" ) {
			// Flatten out incoming arrays of values
			if( #value > 0 ) {
				for( i = 1, #value ) {
					current = storeList(field, current, value[i], processor);
				}
				return current;
			}

			// Ignore empty lists
			if( table.isempty(value) ) {
				return current;
			}
		}

		current = current || {};

		if( processor ) {
			value = processor(field, null, value);
		}

		if( type(value) == "table" ) {
			if( #value > 0 ) {
				for( i = 1, #value ) {
					storeListItem(current, value[i], field.allowDuplicates);
				}
			} else if( ! table.isempty(value) ) {
				storeListItem(current, value, field.allowDuplicates);
			}
		} else if( value ) {
			storeListItem(current, value, field.allowDuplicates);
		}

		return current;
	}


	var function mergeList(field, current, value, processor) {
		value = value || {};
		for( i = 1, #value ) {
			storeListItem(current, value[i], field.allowDuplicates);
		}
		return current;
	}


	premake.field.kind("list", {
		store = storeList,
		remove = storeList,
		merge = mergeList,
		compare = function(field, a, b, processor) {
			if( a == null || b == null || #a != #b ) {
				return false;
			}
			for( i = 1, #a ) {
				if( ! processor(field, a[i], b[i]) ) {
					return false;
				}
			}
			return true;
		},

		translate = function(field, current, _, processor) {
			if( ! processor ) {
				return { current };
			}
			var ret = {};
			for( _, value in ipairs(current) ) {
				for( _, processed in ipairs(processor(field, value, null)) ) {
					table.insert(ret, processed);
				}
			}
			return { ret };
		}
	});



//
// Mixed data kind; values containing a directory separator "/" are converted
// to absolute paths, other values left as-is. Used for links, where system
// libraries and local library paths can be mixed into a single list.
//

	premake.field.kind("mixed", {
		paths = true,
		store = function(field, current, value, processor) {
			if( type(value) == "string" && value->find('/', null, true) ) {
				if( string.sub(value, 1, 2) != "%{" ) {
					value = path.getabsolute(value);
				}
			}
			return value;
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		}
	});



//
// Number data kind; validates inputs.
//

	premake.field.kind("number", {
		store = function(field, current, value, processor) {
			var t = type(value);
			if( t != "number" ) {
				error ({ msg="expected number; got " .. t });
			}
			return value;
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		}
	});



//
// Path data kind; converts all inputs to absolute paths.
//

	premake.field.kind("path", {
		paths = true,
		store = function(field, current, value, processor) {
			return path.deferredjoin(os.getcwd(), value);
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		}
	});



//
// String data kind; performs validation against allowed fields, checks for
// value deprecations.
//

	premake.field.kind("string", {
		store = function(field, current, value, processor) {
			if( type(value) == "table" ) {
				error ({ msg="expected string; got table" });
			}

			if( value != null ) {
				var err;
				value, err = api.checkValue(field, value);
				if( err ) {
					error ({ msg=err });
				}
			}

			return value;
		},
		compare = function(field, a, b, processor) {
			return (a == b);
		}
	});


//
// Table data kind; wraps simple values into a table, returns others as-is.
//

	premake.field.kind("table", {
		store = function(field, current, value, processor) {
			if( type(value) != "table" ) {
				value = { value };
			}
			return value;
		},
		compare = function(field, a, b, processor) {
			// TODO: is there a reliable way to check this?
			return true;
		}
	});



//-
// Start a new block of configuration settings, using the old, "open"
// style of matching without field prefixes.
//-

	function configuration(terms) {
		if( terms ) {
			if( (type(terms) == "table" && #terms == 1 && terms[1] == "*") || (terms == "*") ) {
				terms = null;
			}
			configset.addblock(api.scope.current, {terms}, os.getcwd());
		}
		return api.scope.current;
	}



//-
// Start a new block of configuration settings, using the new prefixed
// style of pattern matching.
//-

	function filter(terms) {
		if( terms ) {
			if( (type(terms) == "table" && #terms == 1 && terms[1] == "*") || (terms == "*") ) {
				terms = null;
			}
			var ok, err = configset.addFilter(api.scope.current, {terms}, os.getcwd());
			if( ! ok ) {
				error(err, 2);
			}
		}
	}



//
// Define a new action.
//
// @param a
//    The new action object.
//

	function newaction(a) {
		p.action.add(a);
	}


//
// Define a new option.
//
// @param opt
//    The new option object.
//

	function newoption(opt) {
		p.option.add(opt);
	}
