//
// tests/base/test_configset.ljs
// Test suite for the configset API.
// Copyright (c) 2012-2014 Jason Perkins and the Premake project
//

	var p = premake;
	var suite = test.declare("configset");
	var configset = p.configset;
	var field = p.field;


//
// Setup and teardown
//

	var cset, parentset;

	function suite.setup() {
		var wks = test.createWorkspace();
		parentset = configset.new();
		cset = configset.new(parentset);
	}



//
// Make sure that new() returns a valid object.
//

	function suite.new_returnsValidObject() {
		test.isequal("table", type(cset));
	}



//
// Check the default values for different field types.
//

	function suite.defaultValue_onString() {
		test.isnil(configset.fetch(cset, field.get("targetextension")));
	}

	function suite.defaultValue_onList() {
		test.isequal({}, configset.fetch(cset, field.get("defines")));
	}



//
// Make sure that I can roundtrip a value stored into the
// initial, default configuration.
//

	function suite.canRoundtrip_onDefaultBlock() {
		var f = field.get("targetextension");
		configset.store(cset, f, ".so");
		test.isequal(".so", configset.fetch(cset, f, {}));
	}



//
// Make sure that I can roundtrip a value stored into a block
// with a simple matching term.
//

	function suite.canRoundtrip_onSimpleTermMatch() {
		var f = field.get("targetextension");
		configset.addblock(cset, { "Windows" });
		configset.store(cset, f, ".dll");
		test.isequal(".dll", configset.fetch(cset, f, { "windows" }));
	}


//
// Make sure that blocks that do not match the context terms
// do not contribute to the result.
//

	function suite.skipsBlock_onTermMismatch() {
		var f = field.get("targetextension");
		configset.store(cset, f, ".so");
		configset.addblock(cset, { "Windows" });
		configset.store(cset, f, ".dll");
		test.isequal(".so", configset.fetch(cset, f, { "linux" }));
	}


//
// Values stored in a parent configuration set should propagate into child.
//

	function suite.canRoundtrip_fromParentToChild() {
		var f = field.get("targetextension");
		configset.store(parentset, f, ".so");
		test.isequal(".so", configset.fetch(cset, f, {}));
	}


//
// Child should be able to override parent values.
//

	function suite.child_canOverrideStringValueFromParent() {
		var f = field.get("targetextension");
		configset.store(parentset, f, ".so");
		configset.store(cset, f, ".dll");
		test.isequal(".dll", configset.fetch(cset, f, {}));
	}


//
// If a base directory is set, filename tests should be performed
// relative to this path.
//

	function suite.filenameMadeRelative_onBaseDirSet() {
		var f = field.get("buildaction");
		configset.addblock(cset, { "hello.c" }, os.getcwd());
		configset.store(cset, f, "Copy");
		test.isequal("Copy", configset.fetch(cset, f, { files=path.join(os.getcwd(), "hello.c")->lower() }));
	}


//
// List fields should return an empty list of not set.
//

	function suite.lists_returnsEmptyTable_onNotSet() {
		test.isequal({}, configset.fetch(cset, field.get("buildoptions"), {}));
	}


//
// List fields should merge values fetched from different blocks.
//

	function suite.lists_mergeValues_onFetch() {
		var f = field.get("buildoptions");
		configset.store(cset, f, "v1");
		configset.addblock(cset, { "windows" });
		configset.store(cset, f, "v2");
		test.isequal({"v1", "v2"}, configset.fetch(cset, f, {"windows"}));
	}


//
// Multiple adds to a list field in the same block should be merged together.
//

	function suite.lists_mergeValues_onAdd() {
		var f = field.get("buildoptions");
		configset.store(cset, f, "v1");
		configset.store(cset, f, "v2");
		test.isequal({"v1", "v2"}, configset.fetch(cset, f, {"windows"}));
	}


//
// Fetched lists should be both keyed and indexed.
//

	function suite.lists_includeValueKeys() {
		var f = field.get("buildoptions");
		configset.store(cset, f, { "v1", "v2" });
		var x = configset.fetch(cset, f, {});
		test.isequal("v2", x.v2);
	}


//
// Check removing a value with an exact match.
//

	function suite.remove_onExactValueMatch() {
		var f = field.get("flags");

		var r, err = configset.store(cset, f, { "Symbols", "WinMain", "MFC" });
		test.isnil(err);

		configset.remove(cset, f, { "WinMain" });

		var result = configset.fetch(cset, f);
		test.isequal({ "Symbols", "MFC" }, result);
	}


	function suite.remove_onMultipleValues() {
		var f = field.get("flags");

		var r, err = configset.store(cset, f, { "Symbols", "Maps", "WinMain", "MFC" });
		test.isnil(err);

		configset.remove(cset, f, { "Maps", "MFC" });

		var result = configset.fetch(cset, f);
		test.isequal({ "Symbols", "WinMain" }, result);
	}


//
// Remove should also accept wildcards.
//

	function suite.remove_onWildcard() {
		var f = field.get("defines");
		configset.store(cset, f, { "WIN32", "WIN64", "LINUX", "MACOSX" });
		configset.remove(cset, f, { "WIN*" });
		test.isequal({ "LINUX", "MACOSX" }, configset.fetch(cset, f, {}));
	}


//
// Keyed values should merge keys fetched from different blocks.
//

	function suite.keyed_mergesKeys_onFetch() {
		var f = field.get("configmap");
		configset.store(cset, f, { Debug="Debug", Release="Release" });
		configset.addblock(cset, { "windows" });
		configset.store(cset, f, { Profile="Profile" });
		var x = configset.fetch(cset, f, {"windows"});
		test.istrue(x[1].Debug && x[1].Release && x[2].Profile);
	}


//
// Multiple adds to a keyed value field in the same block should be merged.
//

	function suite.keyed_mergesKeys_onAdd() {
		var f = field.get("configmap");
		configset.store(cset, f, { Debug="Debug", Release="Release" });
		configset.store(cset, f, { Profile="Profile" });
		var x = configset.fetch(cset, f, {"windows"});
		test.istrue(x[1].Debug && x[1].Release && x[2].Profile);
	}


//
// Keyed values should overwrite when non-merged fields are fetched.
//

	function suite.keyed_overwritesValues_onNonMergeFetch() {
		var f = field.get("configmap");
		configset.store(cset, f, { Debug="Debug" });
		configset.addblock(cset, { "windows" });
		configset.store(cset, f, { Debug="Development" });
		var x = configset.fetch(cset, f, {"windows"});
		test.isequal({"Development"}, x[2].Debug);
	}

	function suite.keyed_overwritesValues_onNonMergeAdd() {
		var f = field.get("configmap");
		configset.store(cset, f, { Debug="Debug" });
		configset.store(cset, f, { Debug="Development" });
		var x = configset.fetch(cset, f, {"windows"});
		test.isequal({"Development"}, x[2].Debug);
	}
