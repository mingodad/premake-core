// -*- coding: utf-8 -*-
//
// Simple JSON encoding and decoding in pure Lua.
//
// Copyright 2010-2016 Jeffrey Friedl
// http://regex.info/blog/
// Latest version: http://regex.info/blog/lua/json
//
// This code is released under a Creative Commons CC-BY "Attribution" License:
// http://creativecommons.org/licenses/by/3.0/deed.en_US
//
// It can be used for any purpose so long as:
//    1) the copyright notice above is maintained
//    2) the web-page links above are maintained
//    3) the 'AUTHOR_NOTE' string below is maintained
//
var VERSION = '20161109.21'; // version history at end of file
var AUTHOR_NOTE = "-[ JSON.ljs package by Jeffrey Friedl (http://regex.info/blog/lua/json) version 20161109.21 ]-";

//
// The 'AUTHOR_NOTE' variable exists so that information about the source
// of the package is maintained even in compiled versions. It's also
// included in OBJDEF below mostly to quiet warnings about unused variables.
//
var OBJDEF = {
   VERSION      = VERSION,
   AUTHOR_NOTE  = AUTHOR_NOTE,
};


//
// Simple JSON encoding and decoding in pure Lua.
// JSON definition: http://www.json.org/
//
//
//   JSON = assert(loadfile "JSON.ljs")() -- one-time load of the routines
//
//   local lua_value = JSON:decode(raw_json_text)
//
//   local raw_json_text    = JSON:encode(lua_table_or_value)
//   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
//
//
//
// DECODING (from a JSON string to a Lua table)
//
//
//   JSON = assert(loadfile "JSON.ljs")() -- one-time load of the routines
//
//   local lua_value = JSON:decode(raw_json_text)
//
//   If the JSON text is for an object or an array, e.g.
//     { "what": "books", "count": 3 }
//   or
//     [ "Larry", "Curly", "Moe" ]
//
//   the result is a Lua table, e.g.
//     { what = "books", count = 3 }
//   or
//     { "Larry", "Curly", "Moe" }
//
//
//   The encode and decode routines accept an optional second argument,
//   "etc", which is not used during encoding or decoding, but upon error
//   is passed along to error handlers. It can be of any type (including nil).
//
//
//
// ERROR HANDLING
//
//   With most errors during decoding, this code calls
//
//      JSON:onDecodeError(message, text, location, etc)
//
//   with a message about the error, and if known, the JSON text being
//   parsed and the byte count where the problem was discovered. You can
//   replace the default JSON:onDecodeError() with your own function.
//
//   The default onDecodeError() merely augments the message with data
//   about the text and the location if known (and if a second 'etc'
//   argument had been provided to decode(), its value is tacked onto the
//   message as well), and then calls JSON.assert(), which itself defaults
//   to Lua's built-in assert(), and can also be overridden.
//
//   For example, in an Adobe Lightroom plugin, you might use something like
//
//          function JSON:onDecodeError(message, text, location, etc)
//             LrErrors.throwUserError("Internal Error: invalid JSON data")
//          end
//
//   or even just
//
//          function JSON.assert(message)
//             LrErrors.throwUserError("Internal Error: " .. message)
//          end
//
//   If JSON:decode() is passed a nil, this is called instead:
//
//      JSON:onDecodeOfNilError(message, nil, nil, etc)
//
//   and if JSON:decode() is passed HTML instead of JSON, this is called:
//
//      JSON:onDecodeOfHTMLError(message, text, nil, etc)
//
//   The use of the fourth 'etc' argument allows stronger coordination
//   between decoding and error reporting, especially when you provide your
//   own error-handling routines. Continuing with the the Adobe Lightroom
//   plugin example:
//
//          function JSON:onDecodeError(message, text, location, etc)
//             local note = "Internal Error: invalid JSON data"
//             if type(etc) = 'table' and etc.photo then
//                note = note .. " while processing for " .. etc.photo:getFormattedMetadata('fileName')
//             end
//             LrErrors.throwUserError(note)
//          end
//
//            :
//            :
//
//          for i, photo in ipairs(photosToProcess) do
//               :             
//               :             
//               local data = JSON:decode(someJsonText, { photo = photo })
//               :             
//               :             
//          end
//
//
//
//   If the JSON text passed to decode() has trailing garbage (e.g. as with the JSON "[123]xyzzy"),
//   the method
//
//       JSON:onTrailingGarbage(json_text, location, parsed_value, etc)
//
//   is invoked, where:
//
//       json_text is the original JSON text being parsed,
//       location is the count of bytes into json_text where the garbage starts (6 in the example),
//       parsed_value is the Lua result of what was successfully parsed ({123} in the example),
//       etc is as above.
//
//   If JSON:onTrailingGarbage() does not abort, it should return the value decode() should return,
//   or nil + an error message.
//
//     local new_value, error_message = JSON:onTrailingGarbage()
//
//   The default handler just invokes JSON:onDecodeError("trailing garbage"...), but you can have
//   this package ignore trailing garbage via
//
//      function JSON:onTrailingGarbage(json_text, location, parsed_value, etc)
//         return parsed_value
//      end
//
//
// DECODING AND STRICT TYPES
//
//   Because both JSON objects and JSON arrays are converted to Lua tables,
//   it's not normally possible to tell which original JSON type a
//   particular Lua table was derived from, or guarantee decode-encode
//   round-trip equivalency.
//
//   However, if you enable strictTypes, e.g.
//
//      JSON = assert(loadfile "JSON.ljs")() --load the routines
//      JSON.strictTypes = true
//
//   then the Lua table resulting from the decoding of a JSON object or
//   JSON array is marked via Lua metatable, so that when re-encoded with
//   JSON:encode() it ends up as the appropriate JSON type.
//
//   (This is not the default because other routines may not work well with
//   tables that have a metatable set, for example, Lightroom API calls.)
//
//
// ENCODING (from a lua table to a JSON string)
//
//   JSON = assert(loadfile "JSON.ljs")() -- one-time load of the routines
//
//   local raw_json_text    = JSON:encode(lua_table_or_value)
//   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
//   local custom_pretty    = JSON:encode(lua_table_or_value, etc, { pretty = true, indent = "|  ", align_keys = false })
//
//   On error during encoding, this code calls:
//
//     JSON:onEncodeError(message, etc)
//
//   which you can override in your local JSON object.
//
//   The 'etc' in the error call is the second argument to encode()
//   and encode_pretty(), or nil if it wasn't provided.
//
//
// ENCODING OPTIONS
//
//   An optional third argument, a table of options, can be provided to encode().
//
//       encode_options =  {
//           -- options for making "pretty" human-readable JSON (see "PRETTY-PRINTING" below)
//           pretty         = true,
//           indent         = "   ",
//           align_keys     = false,
//  
//           -- other output-related options
//           null           = "\0",   -- see "ENCODING JSON NULL VALUES" below
//           stringsAreUtf8 = false,  -- see "HANDLING UNICODE LINE AND PARAGRAPH SEPARATORS FOR JAVA" below
//       }
//  
//       json_string = JSON:encode(mytable, etc, encode_options)
//
//
//
// For reference, the defaults are:
//
//           pretty         = false
//           null           = nil,
//           stringsAreUtf8 = false,
//
//
//
// PRETTY-PRINTING
//
//   Enabling the 'pretty' encode option helps generate human-readable JSON.
//
//     pretty = JSON:encode(val, etc, {
//                                       pretty = true,
//                                       indent = "   ",
//                                       align_keys = false,
//                                     })
//
//   encode_pretty() is also provided: it's identical to encode() except
//   that encode_pretty() provides a default options table if none given in the call:
//
//       { pretty = true, align_keys = false, indent = "  " }
//
//   For example, if
//
//      JSON:encode(data)
//
//   produces:
//
//      {"city":"Kyoto","climate":{"avg_temp":16,"humidity":"high","snowfall":"minimal"},"country":"Japan","wards":11}
//
//   then
//
//      JSON:encode_pretty(data)
//
//   produces:
//
//      {
//        "city": "Kyoto",
//        "climate": {
//          "avg_temp": 16,
//          "humidity": "high",
//          "snowfall": "minimal"
//        },
//        "country": "Japan",
//        "wards": 11
//      }
//
//   The following three lines return identical results:
//       JSON:encode_pretty(data)
//       JSON:encode_pretty(data, nil, { pretty = true, align_keys = false, indent = "  " })
//       JSON:encode       (data, nil, { pretty = true, align_keys = false, indent = "  " })
//
//   An example of setting your own indent string:
//
//     JSON:encode_pretty(data, nil, { pretty = true, indent = "|    " })
//
//   produces:
//
//      {
//      |    "city": "Kyoto",
//      |    "climate": {
//      |    |    "avg_temp": 16,
//      |    |    "humidity": "high",
//      |    |    "snowfall": "minimal"
//      |    },
//      |    "country": "Japan",
//      |    "wards": 11
//      }
//
//   An example of setting align_keys to true:
//
//     JSON:encode_pretty(data, nil, { pretty = true, indent = "  ", align_keys = true })
//  
//   produces:
//   
//      {
//           "city": "Kyoto",
//        "climate": {
//                     "avg_temp": 16,
//                     "humidity": "high",
//                     "snowfall": "minimal"
//                   },
//        "country": "Japan",
//          "wards": 11
//      }
//
//   which I must admit is kinda ugly, sorry. This was the default for
//   encode_pretty() prior to version 20141223.14.
//
//
//  HANDLING UNICODE LINE AND PARAGRAPH SEPARATORS FOR JAVA
//
//    If the 'stringsAreUtf8' encode option is set to true, consider Lua strings not as a sequence of bytes,
//    but as a sequence of UTF-8 characters.
//
//    Currently, the only practical effect of setting this option is that Unicode LINE and PARAGRAPH
//    separators, if found in a string, are encoded with a JSON escape instead of being dumped as is.
//    The JSON is valid either way, but encoding this way, apparently, allows the resulting JSON
//    to also be valid Java.
//
//  AMBIGUOUS SITUATIONS DURING THE ENCODING
//
//   During the encode, if a Lua table being encoded contains both string
//   and numeric keys, it fits neither JSON's idea of an object, nor its
//   idea of an array. To get around this, when any string key exists (or
//   when non-positive numeric keys exist), numeric keys are converted to
//   strings.
//
//   For example, 
//     JSON:encode({ "one", "two", "three", SOMESTRING = "some string" }))
//   produces the JSON object
//     {"1":"one","2":"two","3":"three","SOMESTRING":"some string"}
//
//   To prohibit this conversion and instead make it an error condition, set
//      JSON.noKeyConversion = true
//
//
// ENCODING JSON NULL VALUES
//
//   Lua tables completely omit keys whose value is nil, so without special handling there's
//   no way to get a field in a JSON object with a null value.  For example
//      JSON:encode({ username = "admin", password = nil })
//   produces
//      {"username":"admin"}
//
//   In order to actually produce
//      {"username":"admin", "password":null}
//   one can include a string value for a "null" field in the options table passed to encode().... 
//   any Lua table entry with that value becomes null in the JSON output:
//      JSON:encode({ username = "admin", password = "xyzzy" }, nil, { null = "xyzzy" })
//   produces
//      {"username":"admin", "password":null}
//
//   Just be sure to use a string that is otherwise unlikely to appear in your data.
//   The string "\0" (a string with one null byte) may well be appropriate for many applications.
//
//   The "null" options also applies to Lua tables that become JSON arrays.
//      JSON:encode({ "one", "two", nil, nil })
//   produces
//      ["one","two"]
//   while
//      NULL = "\0"
//      JSON:encode({ "one", "two", NULL, NULL}, nil, { null = NULL })
//   produces
//      ["one","two",null,null]
//
//
//
//
// HANDLING LARGE AND/OR PRECISE NUMBERS
//
//
//   Without special handling, numbers in JSON can lose precision in Lua.
//   For example:
//   
//      T = JSON:decode('{  "small":12345, "big":12345678901234567890123456789, "precise":9876.67890123456789012345  }')
//
//      print("small:   ",  type(T.small),    T.small)
//      print("big:     ",  type(T.big),      T.big)
//      print("precise: ",  type(T.precise),  T.precise)
//   
//   produces
//   
//      small:          number  12345
//      big:            number  1.2345678901235e+28
//      precise:        number  9876.6789012346
//
//   Precision is lost with both 'big' and 'precise'.
//
//   This package offers ways to try to handle this better (for some definitions of "better")...
//
//   The most precise method is by setting the global:
//   
//      JSON.decodeNumbersAsObjects = true
//   
//   When this is set, numeric JSON data is encoded into Lua in a form that preserves the exact
//   JSON numeric presentation when re-encoded back out to JSON, or accessed in Lua as a string.
//
//   (This is done by encoding the numeric data with a Lua table/metatable that returns
//   the possibly-imprecise numeric form when accessed numerically, but the original precise
//   representation when accessed as a string. You can also explicitly access
//   via JSON:forceString() and JSON:forceNumber())
//
//   Consider the example above, with this option turned on:
//
//      JSON.decodeNumbersAsObjects = true
//      
//      T = JSON:decode('{  "small":12345, "big":12345678901234567890123456789, "precise":9876.67890123456789012345  }')
//
//      print("small:   ",  type(T.small),    T.small)
//      print("big:     ",  type(T.big),      T.big)
//      print("precise: ",  type(T.precise),  T.precise)
//   
//   This now produces:
//   
//      small:          table   12345
//      big:            table   12345678901234567890123456789
//      precise:        table   9876.67890123456789012345
//   
//   However, within Lua you can still use the values (e.g. T.precise in the example above) in numeric
//   contexts. In such cases you'll get the possibly-imprecise numeric version, but in string contexts
//   and when the data finds its way to this package's encode() function, the original full-precision
//   representation is used.
//
//   Even without using the JSON.decodeNumbersAsObjects option, you can encode numbers
//   in your Lua table that retain high precision upon encoding to JSON, by using the JSON:asNumber()
//   function:
//
//      T = {
//         imprecise = 123456789123456789.123456789123456789,
//         precise   = JSON:asNumber("123456789123456789.123456789123456789")
//      }
//
//      print(JSON:encode_pretty(T))
//
//   This produces:
//
//      { 
//         "precise": 123456789123456789.123456789123456789,
//         "imprecise": 1.2345678912346e+17
//      }
//
//
//
//   A different way to handle big/precise JSON numbers is to have decode() merely return
//   the exact string representation of the number instead of the number itself.
//   This approach might be useful when the numbers are merely some kind of opaque
//   object identifier and you want to work with them in Lua as strings anyway.
//   
//   This approach is enabled by setting
//
//      JSON.decodeIntegerStringificationLength = 10
//
//   The value is the number of digits (of the integer part of the number) at which to stringify numbers.
//
//   Consider our previous example with this option set to 10:
//
//      JSON.decodeIntegerStringificationLength = 10
//      
//      T = JSON:decode('{  "small":12345, "big":12345678901234567890123456789, "precise":9876.67890123456789012345  }')
//
//      print("small:   ",  type(T.small),    T.small)
//      print("big:     ",  type(T.big),      T.big)
//      print("precise: ",  type(T.precise),  T.precise)
//
//   This produces:
//
//      small:          number  12345
//      big:            string  12345678901234567890123456789
//      precise:        number  9876.6789012346
//
//   The long integer of the 'big' field is at least JSON.decodeIntegerStringificationLength digits
//   in length, so it's converted not to a Lua integer but to a Lua string. Using a value of 0 or 1 ensures
//   that all JSON numeric data becomes strings in Lua.
//
//   Note that unlike
//      JSON.decodeNumbersAsObjects = true
//   this stringification is simple and unintelligent: the JSON number simply becomes a Lua string, and that's the end of it.
//   If the string is then converted back to JSON, it's still a string. After running the code above, adding
//      print(JSON:encode(T))
//   produces
//      {"big":"12345678901234567890123456789","precise":9876.6789012346,"small":12345}
//   which is unlikely to be desired.
//
//   There's a comparable option for the length of the decimal part of a number:
//
//      JSON.decodeDecimalStringificationLength
//
//   This can be used alone or in conjunction with
//
//      JSON.decodeIntegerStringificationLength
//
//   to trip stringification on precise numbers with at least JSON.decodeIntegerStringificationLength digits after
//   the decimal point.
//
//   This example:
//
//      JSON.decodeIntegerStringificationLength = 10
//      JSON.decodeDecimalStringificationLength =  5
//
//      T = JSON:decode('{  "small":12345, "big":12345678901234567890123456789, "precise":9876.67890123456789012345  }')
//      
//      print("small:   ",  type(T.small),    T.small)
//      print("big:     ",  type(T.big),      T.big)
//      print("precise: ",  type(T.precise),  T.precise)
//
//  produces:
//
//      small:          number  12345
//      big:            string  12345678901234567890123456789
//      precise:        string  9876.67890123456789012345
//
//
//
//
//
// SUMMARY OF METHODS YOU CAN OVERRIDE IN YOUR LOCAL LUA JSON OBJECT
//
//    assert
//    onDecodeError
//    onDecodeOfNilError
//    onDecodeOfHTMLError
//    onTrailingGarbage
//    onEncodeError
//
//  If you want to create a separate Lua JSON object with its own error handlers,
//  you can reload JSON.ljs or use the :new() method.
//
//-------------------------------------------------------------------------

var default_pretty_indent  = "  ";
var default_pretty_options = { pretty = true, align_keys = false, indent = default_pretty_indent  };

var isArray  = { __tostring = function() { return "JSON array";         } };  isArray.__index  = isArray;
var isObject = { __tostring = function() { return "JSON object";        } };  isObject.__index = isObject;

function OBJDEF::newArray(tbl) {
   return setmetatable(tbl || {}, isArray);
}

function OBJDEF::newObject(tbl) {
   return setmetatable(tbl || {}, isObject);
}




var function getnum(op) {
   return type(op) == 'number' && op || op.N;
}

var isNumber = {
   __tostring = function(T) {  return T.S;        },
   __unm      = function(op) { return getnum(op); },

   __concat   = function(op1, op2) { return tostring(op1) .. tostring(op2); },
   __add      = function(op1, op2) { return getnum(op1)   +   getnum(op2);  },
   __sub      = function(op1, op2) { return getnum(op1)   -   getnum(op2);  },
   __mul      = function(op1, op2) { return getnum(op1)   *   getnum(op2);  },
   __div      = function(op1, op2) { return getnum(op1)   /   getnum(op2);  },
   __mod      = function(op1, op2) { return getnum(op1)   %   getnum(op2);  },
   __pow      = function(op1, op2) { return getnum(op1)   **   getnum(op2);  },
   __lt       = function(op1, op2) { return getnum(op1)   <   getnum(op2);  },
   __eq       = function(op1, op2) { return getnum(op1)   ==  getnum(op2);  },
   __le       = function(op1, op2) { return getnum(op1)   <=  getnum(op2);  },
};
isNumber.__index = isNumber;

function OBJDEF::asNumber(item) {

   if( getmetatable(item) == isNumber ) {
      // it's already a JSON number object.
      return item;
   } else if( type(item) == 'table' && type(item.S) == 'string' && type(item.N) == 'number' ) {
      // it's a number-object table that lost its metatable, so give it one
      return setmetatable(item, isNumber);
   } else {
      // the normal situation... given a number or a string representation of a number....
      var holder = {
         S = tostring(item), // S is the representation of the number as a string, which remains precise
         N = tonumber(item), // N is the number as a Lua number.
      };
      return setmetatable(holder, isNumber);
   }
}

//
// Given an item that might be a normal string or number, or might be an 'isNumber' object defined above,
// return the string version. This shouldn't be needed often because the 'isNumber' object should autoconvert
// to a string in most cases, but it's here to allow it to be forced when needed.
//
function OBJDEF::forceString(item) {
   if( type(item) == 'table' && type(item.S) == 'string' ) {
      return item.S;
   } else {
      return tostring(item);
   }
}

//
// Given an item that might be a normal string or number, or might be an 'isNumber' object defined above,
// return the numeric version.
//
function OBJDEF::forceNumber(item) {
   if( type(item) == 'table' && type(item.N) == 'number' ) {
      return item.N;
   } else {
      return tonumber(item);
   }
}
   

var function unicode_codepoint_as_utf8(codepoint) {
   //
   // codepoint is a number
   //
   if( codepoint <= 127 ) {
      return string.char(codepoint);

   } else if( codepoint <= 2047 ) {
      //
      // 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8
      //
      var highpart = math.floor(codepoint / 0x40);
      var lowpart  = codepoint - (0x40 * highpart);
      return string.char(0xC0 + highpart,
                         0x80 + lowpart);

   } else if( codepoint <= 65535 ) {
      //
      // 1110yyyy 10yyyyxx 10xxxxxx
      //
      var highpart  = math.floor(codepoint / 0x1000);
      var remainder = codepoint - 0x1000 * highpart;
      var midpart   = math.floor(remainder / 0x40);
      var lowpart   = remainder - 0x40 * midpart;

      highpart = 0xE0 + highpart;
      midpart  = 0x80 + midpart;
      lowpart  = 0x80 + lowpart;

      //
      // Check for an invalid character (thanks Andy R. at Adobe).
      // See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070
      //
      if( ( highpart == 0xE0 && midpart < 0xA0 ) ||
         ( highpart == 0xED && midpart > 0x9F ) ||
         ( highpart == 0xF0 && midpart < 0x90 ) ||
         ( highpart == 0xF4 && midpart > 0x8F )
      ) {
         return "?";
      } else {
         return string.char(highpart,
                            midpart,
                            lowpart);
      }

   } else {
      //
      // 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
      //
      var highpart  = math.floor(codepoint / 0x40000);
      var remainder = codepoint - 0x40000 * highpart;
      var midA      = math.floor(remainder / 0x1000);
      remainder       = remainder - 0x1000 * midA;
      var midB      = math.floor(remainder / 0x40);
      var lowpart   = remainder - 0x40 * midB;

      return string.char(0xF0 + highpart,
                         0x80 + midA,
                         0x80 + midB,
                         0x80 + lowpart);
   }
}

function OBJDEF::onDecodeError(message, text, location, etc) {
   if( text ) {
      if( location ) {
         message = string.format("%s at byte %d of: %s", message, location, text);
      } else {
         message = string.format("%s: %s", message, text);
      }
   }

   if( etc != null ) {
      message = message .. " (" .. OBJDEF->encode(etc) .. ")";
   }

   if( this.assert ) {
      this.assert(false, message);
   } else {
      assert(false, message);
   }
}

function OBJDEF::onTrailingGarbage(json_text, location, parsed_value, etc) {
   return this->onDecodeError("trailing garbage", json_text, location, etc);
}

OBJDEF.onDecodeOfNilError  = OBJDEF.onDecodeError;
OBJDEF.onDecodeOfHTMLError = OBJDEF.onDecodeError;

function OBJDEF::onEncodeError(message, etc) {
   if( etc != null ) {
      message = message .. " (" .. OBJDEF->encode(etc) .. ")";
   }

   if( this.assert ) {
      this.assert(false, message);
   } else {
      assert(false, message);
   }
}

var function grok_number(this, text, start, options) {
   //
   // Grab the integer part
   //
   var integer_part = text->match('^-?[1-9]%d*', start)
                     || text->match("^-?0",        start);

   if( ! integer_part ) {
      this->onDecodeError("expected number", text, start, options.etc);
      return null, start; // in case the error method doesn't abort, return something sensible
   }

   var i = start + integer_part->len();

   //
   // Grab an optional decimal part
   //
   var decimal_part = text->match('^%.%d+', i) || "";

   i = i + decimal_part->len();

   //
   // Grab an optional exponential part
   //
   var exponent_part = text->match('^[eE][-+]?%d+', i) || "";

   i = i + exponent_part->len();

   var full_number_text = integer_part .. decimal_part .. exponent_part;

   if( options.decodeNumbersAsObjects ) {
      return OBJDEF->asNumber(full_number_text), i;
   }

   //
   // If we're told to stringify under certain conditions, so do.
   // We punt a bit when there's an exponent by just stringifying no matter what.
   // I suppose we should really look to see whether the exponent is actually big enough one
   // way or the other to trip stringification, but I'll be lazy about it until someone asks.
   //
   if( (options.decodeIntegerStringificationLength
       &&
      (integer_part->len() >= options.decodeIntegerStringificationLength || exponent_part->len() > 0))

       ||

      (options.decodeDecimalStringificationLength 
       &&
       (decimal_part->len() >= options.decodeDecimalStringificationLength || exponent_part->len() > 0))
   ) {
      return full_number_text, i; // this returns the exact string representation seen in the original JSON
   }



   var as_number = tonumber(full_number_text);

   if( ! as_number ) {
      this->onDecodeError("bad number", text, start, options.etc);
      return null, start; // in case the error method doesn't abort, return something sensible
   }

   return as_number, i;
}


var function grok_string(this, text, start, options) {

   if( text->sub(start,start) != '"' ) {
      this->onDecodeError("expected string's opening quote", text, start, options.etc);
      return null, start; // in case the error method doesn't abort, return something sensible
   }

   var i = start + 1; // +1 to bypass the initial quote
   var text_len = text->len();
   var VALUE = "";
   while( i <= text_len ) {
      var c = text->sub(i,i);
      if( c == '"' ) {
         return VALUE, i + 1;
      }
      if( c != '\\' ) {
         VALUE = VALUE .. c;
         ++i    ;
      } else if( text->match('^\\b', i) ) {
         VALUE = VALUE .. "\b";
         i +=   2;
      } else if( text->match('^\\f', i) ) {
         VALUE = VALUE .. "\f";
         i +=   2;
      } else if( text->match('^\\n', i) ) {
         VALUE = VALUE .. "\n";
         i +=   2;
      } else if( text->match('^\\r', i) ) {
         VALUE = VALUE .. "\r";
         i +=   2;
      } else if( text->match('^\\t', i) ) {
         VALUE = VALUE .. "\t";
         i +=   2;
      } else {
         var hex = text->match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i);
         if( hex ) {
            i = i + 6; // bypass what we just read

            // We have a Unicode codepoint. It could be standalone, or if in the proper range and
            // followed by another in a specific range, it'll be a two-code surrogate pair.
            var codepoint = tonumber(hex, 16);
            if( codepoint >= 0xD800 && codepoint <= 0xDBFF ) {
               // it's a hi surrogate... see whether we have a following low
               var lo_surrogate = text->match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i);
               if( lo_surrogate ) {
                  i = i + 6; // bypass the low surrogate we just read
                  codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16);
               } else {
                  // not a proper low, so we'll just leave the first codepoint as is and spit it out.
               }
            }
            VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint);

         } else {

            // just pass through what's escaped
            VALUE = VALUE .. text->match('^\\(.)', i);
            i +=   2;
         }
      }
   }

   this->onDecodeError("unclosed string", text, start, options.etc);
   return null, start; // in case the error method doesn't abort, return something sensible
}

var function skip_whitespace(text, start) {

   var _, match_end = text->find("^[ \n\r\t]+", start); // [http://www.ietf.org/rfc/rfc4627.txt] Section 2
   if( match_end ) {
      return match_end + 1;
   } else {
      return start;
   }
}

var grok_one; // assigned later

var function grok_object(this, text, start, options) {

   if( text->sub(start,start) != '{' ) {
      this->onDecodeError("expected '{'", text, start, options.etc);
      return null, start; // in case the error method doesn't abort, return something sensible
   }

   var i = skip_whitespace(text, start + 1); // +1 to skip the '{'

   var VALUE = this.strictTypes && this->newObject ({ }) || { };

   if( text->sub(i,i) == '}' ) {
      return VALUE, i + 1;
   }
   var text_len = text->len();
   while( i <= text_len ) {
      var key, new_i = grok_string(this, text, i, options);

      i = skip_whitespace(text, new_i);

      if( text->sub(i, i) != ':' ) {
         this->onDecodeError("expected colon", text, i, options.etc);
         return null, i; // in case the error method doesn't abort, return something sensible
      }

      i = skip_whitespace(text, i + 1);

      var new_val;
      new_val, new_i = grok_one(this, text, i, options);

      VALUE[key] = new_val;

      //
      // Expect now either '}' to end things, or a ',' to allow us to continue.
      //
      i = skip_whitespace(text, new_i);

      var c = text->sub(i,i);

      if( c == '}' ) {
         return VALUE, i + 1;
      }

      if( text->sub(i, i) != ',' ) {
         this->onDecodeError("expected comma or '}'", text, i, options.etc);
         return null, i; // in case the error method doesn't abort, return something sensible
      }

      i = skip_whitespace(text, i + 1);
   }

   this->onDecodeError("unclosed '{'", text, start, options.etc);
   return null, start; // in case the error method doesn't abort, return something sensible
}

var function grok_array(this, text, start, options) {
   if( text->sub(start,start) != '[' ) {
      this->onDecodeError("expected '['", text, start, options.etc);
      return null, start; // in case the error method doesn't abort, return something sensible
   }

   var i = skip_whitespace(text, start + 1); // +1 to skip the '['
   var VALUE = this.strictTypes && this->newArray ({ }) || { };
   if( text->sub(i,i) == ']' ) {
      return VALUE, i + 1;
   }

   var VALUE_INDEX = 1;

   var text_len = text->len();
   while( i <= text_len ) {
      var val, new_i = grok_one(this, text, i, options);

      // can't table.insert(VALUE, val) here because it's a no-op if val is nil
      VALUE[VALUE_INDEX] = val;
      ++VALUE_INDEX    ;

      i = skip_whitespace(text, new_i);

      //
      // Expect now either ']' to end things, or a ',' to allow us to continue.
      //
      var c = text->sub(i,i);
      if( c == ']' ) {
         return VALUE, i + 1;
      }
      if( text->sub(i, i) != ',' ) {
         this->onDecodeError("expected comma or ']'", text, i, options.etc);
         return null, i; // in case the error method doesn't abort, return something sensible
      }
      i = skip_whitespace(text, i + 1);
   }
   this->onDecodeError("unclosed '['", text, start, options.etc);
   return null, i; // in case the error method doesn't abort, return something sensible
}


grok_one = function(this, text, start, options) {
   // Skip any whitespace
   start = skip_whitespace(text, start);

   if( start > text->len() ) {
      this->onDecodeError("unexpected end of string", text, null, options.etc);
      return null, start; // in case the error method doesn't abort, return something sensible
   }

   if( text->find('^"', start) ) {
      return grok_string(this, text, start, options.etc);

   } else if( text->find('^[-0123456789 ]', start) ) {
      return grok_number(this, text, start, options);

   } else if( text->find('^%{', start) ) {
      return grok_object(this, text, start, options);

   } else if( text->find('^%[', start) ) {
      return grok_array(this, text, start, options);

   } else if( text->find('^true', start) ) {
      return true, start + 4;

   } else if( text->find('^false', start) ) {
      return false, start + 5;

   } else if( text->find('^null', start) ) {
      return null, start + 4;

   } else {
      this->onDecodeError("can't parse JSON", text, start, options.etc);
      return null, 1; // in case the error method doesn't abort, return something sensible
   }
};

function OBJDEF::decode(text, etc, options) {
   //
   // If the user didn't pass in a table of decode options, make an empty one.
   //
   if( type(options) != 'table' ) {
      options = {};
   }

   //
   // If they passed in an 'etc' argument, stuff it into the options.
   // (If not, any 'etc' field in the options they passed in remains to be used)
   //
   if( etc != null ) {
      options.etc = etc;
   }


   if( type(this) != 'table' || this.__index != OBJDEF ) {
      var error_message = "JSON:decode must be called in method format";
      OBJDEF->onDecodeError(error_message, null, null, options.etc);
      return null, error_message; // in case the error method doesn't abort, return something sensible
   }

   if( text == null ) {
      var error_message = "nil passed to JSON:decode()";
      this->onDecodeOfNilError(error_message, null, null, options.etc);
      return null, error_message; // in case the error method doesn't abort, return something sensible

   } else if( type(text) != 'string' ) {
      var error_message = "expected string argument to JSON:decode()";
      this->onDecodeError(string.format("%s, got %s", error_message, type(text)), null, null, options.etc);
      return null, error_message; // in case the error method doesn't abort, return something sensible
   }

   if( text->match('^%s*$') ) {
      // an empty string is nothing, but not an error
      return null;
   }

   if( text->match('^%s*<') ) {
      // Can't be JSON... we'll assume it's HTML
      var error_message = "HTML passed to JSON:decode()";
      this->onDecodeOfHTMLError(error_message, text, null, options.etc);
      return null, error_message; // in case the error method doesn't abort, return something sensible
   }

   //
   // Ensure that it's not UTF-32 or UTF-16.
   // Those are perfectly valid encodings for JSON (as per RFC 4627 section 3),
   // but this package can't handle them.
   //
   if( text->sub(1,1)->byte() == 0 || (text->len() >= 2 && text->sub(2,2)->byte() == 0) ) {
      var error_message = "JSON package groks only UTF-8, sorry";
      this->onDecodeError(error_message, text, null, options.etc);
      return null, error_message; // in case the error method doesn't abort, return something sensible
   }

   //
   // apply global options
   //
   if( options.decodeNumbersAsObjects == null ) {
      options.decodeNumbersAsObjects = this.decodeNumbersAsObjects;
   }
   if( options.decodeIntegerStringificationLength == null ) {
      options.decodeIntegerStringificationLength = this.decodeIntegerStringificationLength;
   }
   if( options.decodeDecimalStringificationLength == null ) {
      options.decodeDecimalStringificationLength = this.decodeDecimalStringificationLength;
   }

   //
   // Finally, go parse it
   //
   var success, value, next_i = pcall(grok_one, this, text, 1, options);

   if( success ) {

      var error_message = null;
      if( next_i != #text + 1 ) {
         // something's left over after we parsed the first thing.... whitespace is allowed.
         next_i = skip_whitespace(text, next_i);

         // if we have something left over now, it's trailing garbage
         if( next_i != #text + 1 ) {
            value, error_message = this->onTrailingGarbage(text, next_i, value, options.etc);
         }
      }
      return value, error_message;

   } else {

      // If JSON:onDecodeError() didn't abort out of the pcall, we'll have received
      // the error message here as "value", so pass it along as an assert.
      var error_message = value;
      if( this.assert ) {
         this.assert(false, error_message);
      } else {
         assert(false, error_message);
      }
      // ...and if we're still here (because the assert didn't throw an error),
      // return a nil and throw the error message on as a second arg
      return null, error_message;

   }
}

var function backslash_replacement_function(c) {
   if( c == "\n" ) {
      return "\\n";
   } else if( c == "\r" ) {
      return "\\r";
   } else if( c == "\t" ) {
      return "\\t";
   } else if( c == "\b" ) {
      return "\\b";
   } else if( c == "\f" ) {
      return "\\f";
   } else if( c == '"' ) {
      return '\\"';
   } else if( c == '\\' ) {
      return '\\\\';
   } else {
      return string.format("\\u%04x", c->byte());
   }
}

var chars_to_be_escaped_in_JSON_string
   = '['
   ..    '"'    // class sub-pattern to match a double quote
   ..    '%\\'  // class sub-pattern to match a backslash
   ..    '%z'   // class sub-pattern to match a null
   ..    '\001' .. '-' .. '\031' // class sub-pattern to match control characters
   .. ']';


var LINE_SEPARATOR_as_utf8      = unicode_codepoint_as_utf8(0x2028);
var PARAGRAPH_SEPARATOR_as_utf8 = unicode_codepoint_as_utf8(0x2029);
var function json_string_literal(value, options) {
   var newval = value->gsub(chars_to_be_escaped_in_JSON_string, backslash_replacement_function);
   if( options.stringsAreUtf8 ) {
      //
      // This feels really ugly to just look into a string for the sequence of bytes that we know to be a particular utf8 character,
      // but utf8 was designed purposefully to make this kind of thing possible. Still, feels dirty.
      // I'd rather decode the byte stream into a character stream, but it's not technically needed so
      // not technically worth it.
      //
      newval = newval->gsub(LINE_SEPARATOR_as_utf8, '\\u2028')->gsub(PARAGRAPH_SEPARATOR_as_utf8,'\\u2029');
   }
   return '"' .. newval .. '"';
}

var function object_or_array(this, T, etc) {
   //
   // We need to inspect all the keys... if there are any strings, we'll convert to a JSON
   // object. If there are only numbers, it's a JSON array.
   //
   // If we'll be converting to a JSON object, we'll want to sort the keys so that the
   // end result is deterministic.
   //
   var string_keys = { };
   var number_keys = { };
   var number_keys_must_be_strings = false;
   var maximum_number_key;

   for( key in pairs(T) ) {
      if( type(key) == 'string' ) {
         table.insert(string_keys, key);
      } else if( type(key) == 'number' ) {
         table.insert(number_keys, key);
         if( key <= 0 || key >= math.huge ) {
            number_keys_must_be_strings = true;
         } else if( ! maximum_number_key || key > maximum_number_key ) {
            maximum_number_key = key;
         }
      } else {
         this->onEncodeError("can't encode table with a key of type " .. type(key), etc);
      }
   }

   if( #string_keys == 0 && ! number_keys_must_be_strings ) {
      //
      // An empty table, or a numeric-only array
      //
      if( #number_keys > 0 ) {
         return null, maximum_number_key; // an array
      } else if( tostring(T) == "JSON array" ) {
         return null;
      } else if( tostring(T) == "JSON object" ) {
         return { };
      } else {
         // have to guess, so we'll pick array, since empty arrays are likely more common than empty objects
         return null;
      }
   }

   table.sort(string_keys);

   var map;
   if( #number_keys > 0 ) {
      //
      // If we're here then we have either mixed string/number keys, or numbers inappropriate for a JSON array
      // It's not ideal, but we'll turn the numbers into strings so that we can at least create a JSON object.
      //

      if( this.noKeyConversion ) {
         this->onEncodeError("a table with both numeric and string keys could be an object or array; aborting", etc);
      }

      //
      // Have to make a shallow copy of the source table so we can remap the numeric keys to be strings
      //
      map = { };
      for( key, val in pairs(T) ) {
         map[key] = val;
      }

      table.sort(number_keys);

      //
      // Throw numeric keys in there as strings
      //
      for( _, number_key in ipairs(number_keys) ) {
         var string_key = tostring(number_key);
         if( map[string_key] == null ) {
            table.insert(string_keys , string_key);
            map[string_key] = T[number_key];
         } else {
            this->onEncodeError("conflict converting table with mixed-type keys into a JSON object: key " .. number_key .. " exists both as a string and a number.", etc);
         }
      }
   }

   return string_keys, null, map;
}

//
// Encode
//
// 'options' is nil, or a table with possible keys:
//
//    pretty         -- If true, return a pretty-printed version.
//
//    indent         -- A string (usually of spaces) used to indent each nested level.
//
//    align_keys     -- If true, align all the keys when formatting a table.
//
//    null           -- If this exists with a string value, table elements with this value are output as JSON null.
//
//    stringsAreUtf8 -- If true, consider Lua strings not as a sequence of bytes, but as a sequence of UTF-8 characters.
//                      (Currently, the only practical effect of setting this option is that Unicode LINE and PARAGRAPH
//                       separators, if found in a string, are encoded with a JSON escape instead of as raw UTF-8.
//                       The JSON is valid either way, but encoding this way, apparently, allows the resulting JSON
//                       to also be valid Java.)
//
//
var encode_value; // must predeclare because it calls itself
function encode_value(this, value, parents, etc, options, indent, for_key) {

   //
   // keys in a JSON object can never be null, so we don't even consider options.null when converting a key value
   //
   if( value == null || (! for_key && options && options["null"] && value == options["null"]) ) {
      return 'null';

   } else if( type(value) == 'string' ) {
      return json_string_literal(value, options);

   } else if( type(value) == 'number' ) {
      if( value != value ) {
         //
         // NaN (Not a Number).
         // JSON has no NaN, so we have to fudge the best we can. This should really be a package option.
         //
         return "null";
      } else if( value >= math.huge ) {
         //
         // Positive infinity. JSON has no INF, so we have to fudge the best we can. This should
         // really be a package option. Note: at least with some implementations, positive infinity
         // is both ">= math.huge" and "<= -math.huge", which makes no sense but that's how it is.
         // Negative infinity is properly "<= -math.huge". So, we must be sure to check the ">="
         // case first.
         //
         return "1e+9999";
      } else if( value <= -math.huge ) {
         //
         // Negative infinity.
         // JSON has no INF, so we have to fudge the best we can. This should really be a package option.
         //
         return "-1e+9999";
      } else {
         return tostring(value);
      }

   } else if( type(value) == 'boolean' ) {
      return tostring(value);

   } else if( type(value) != 'table' ) {
      this->onEncodeError("can't convert " .. type(value) .. " to JSON", etc);

   } else if( getmetatable(value) == isNumber ) {
      return tostring(value);
   } else {
      //
      // A table to be converted to either a JSON object or array.
      //
      var T = value;

      if( type(options) != 'table' ) {
         options = {};
      }
      if( type(indent) != 'string' ) {
         indent = "";
      }

      if( parents[T] ) {
         this->onEncodeError("table " .. tostring(T) .. " is a child of itself", etc);
      } else {
         parents[T] = true;
      }

      var result_value;

      var object_keys, maximum_number_key, map = object_or_array(this, T, etc);
      if( maximum_number_key ) {
         //
         // An array...
         //
         var ITEMS = { };
         for( i = 1, maximum_number_key ) {
            table.insert(ITEMS, encode_value(this, T[i], parents, etc, options, indent));
         }

         if( options.pretty ) {
            result_value = "[ " .. table.concat(ITEMS, ", ") .. " ]";
         } else {
            result_value = "["  .. table.concat(ITEMS, ",")  .. "]";
         }

      } else if( object_keys ) {
         //
         // An object
         //
         var TT = map || T;

         if( options.pretty ) {

            var KEYS = { };
            var max_key_length = 0;
            for( _, key in ipairs(object_keys) ) {
               var encoded = encode_value(this, tostring(key), parents, etc, options, indent, true);
               if( options.align_keys ) {
                  max_key_length = math.max(max_key_length, #encoded);
               }
               table.insert(KEYS, encoded);
            }
            var key_indent = indent .. tostring(options.indent || "");
            var subtable_indent = key_indent .. string.rep(" ", max_key_length) .. (options.align_keys && "  " || "");
            var FORMAT = "%s%" .. string.format("%d", max_key_length) .. "s: %s";

            var COMBINED_PARTS = { };
            for( i, key in ipairs(object_keys) ) {
               var encoded_val = encode_value(this, TT[key], parents, etc, options, subtable_indent);
               table.insert(COMBINED_PARTS, string.format(FORMAT, key_indent, KEYS[i], encoded_val));
            }
            result_value = "{\n" .. table.concat(COMBINED_PARTS, ",\n") .. "\n" .. indent .. "}";

         } else {

            var PARTS = { };
            for( _, key in ipairs(object_keys) ) {
               var encoded_val = encode_value(this, TT[key],       parents, etc, options, indent);
               var encoded_key = encode_value(this, tostring(key), parents, etc, options, indent, true);
               table.insert(PARTS, string.format("%s:%s", encoded_key, encoded_val));
            }
            result_value = "{" .. table.concat(PARTS, ",") .. "}";

         }
      } else {
         //
         // An empty array/object... we'll treat it as an array, though it should really be an option
         //
         result_value = "[]";
      }

      parents[T] = false;
      return result_value;
   }
}

var function top_level_encode(this, value, etc, options) {
   var val = encode_value(this, value, {}, etc, options);
   if( val == null ) {
      //PRIVATE("may need to revert to the previous public verison if I can't figure out what the guy wanted")
      return val;
   } else {
      return val;
   }
}

function OBJDEF::encode(value, etc, options) {
   if( type(this) != 'table' || this.__index != OBJDEF ) {
      OBJDEF->onEncodeError("JSON:encode must be called in method format", etc);
   }

   //
   // If the user didn't pass in a table of decode options, make an empty one.
   //
   if( type(options) != 'table' ) {
      options = {};
   }

   return top_level_encode(this, value, etc, options);
}

function OBJDEF::encode_pretty(value, etc, options) {
   if( type(this) != 'table' || this.__index != OBJDEF ) {
      OBJDEF->onEncodeError("JSON:encode_pretty must be called in method format", etc);
   }

   //
   // If the user didn't pass in a table of decode options, use the default pretty ones
   //
   if( type(options) != 'table' ) {
      options = default_pretty_options;
   }

   return top_level_encode(this, value, etc, options);
}

function OBJDEF.__tostring() {
   return "JSON encode/decode package";
}

OBJDEF.__index = OBJDEF;

function OBJDEF::new(args) {
   var new = { };

   if( args ) {
      for( key, val in pairs(args) ) {
         new[key] = val;
      }
   }

   return setmetatable(new, OBJDEF);
}

return OBJDEF->new();

//
// Version history:
//
//   20161109.21   Oops, had a small boo-boo in the previous update.
//
//   20161103.20   Used to silently ignore trailing garbage when decoding. Now fails via JSON:onTrailingGarbage()
//                 http://seriot.ch/parsing_json.php
//
//                 Built-in error message about "expected comma or ']'" had mistakenly referred to '['
//
//                 Updated the built-in error reporting to refer to bytes rather than characters.
//
//                 The decode() method no longer assumes that error handlers abort.
//
//                 Made the VERSION string a string instead of a number
//

//   20160916.19   Fixed the isNumber.__index assignment (thanks to Jack Taylor)
//   
//   20160730.18   Added JSON:forceString() and JSON:forceNumber()
//
//   20160728.17   Added concatenation to the metatable for JSON:asNumber()
//
//   20160709.16   Could crash if not passed an options table (thanks jarno heikkinen <jarnoh@capturemonkey.com>).
//
//                 Made JSON:asNumber() a bit more resilient to being passed the results of itself.
//
//   20160526.15   Added the ability to easily encode null values in JSON, via the new "null" encoding option.
//                 (Thanks to Adam B for bringing up the issue.)
//
//                 Added some support for very large numbers and precise floats via
//                    JSON.decodeNumbersAsObjects
//                    JSON.decodeIntegerStringificationLength
//                    JSON.decodeDecimalStringificationLength
//
//                 Added the "stringsAreUtf8" encoding option. (Hat tip to http://lua-users.org/wiki/JsonModules )
//
//   20141223.14   The encode_pretty() routine produced fine results for small datasets, but isn't really
//                 appropriate for anything large, so with help from Alex Aulbach I've made the encode routines
//                 more flexible, and changed the default encode_pretty() to be more generally useful.
//
//                 Added a third 'options' argument to the encode() and encode_pretty() routines, to control
//                 how the encoding takes place.
//
//                 Updated docs to add assert() call to the loadfile() line, just as good practice so that
//                 if there is a problem loading JSON.ljs, the appropriate error message will percolate up.
//
//   20140920.13   Put back (in a way that doesn't cause warnings about unused variables) the author string,
//                 so that the source of the package, and its version number, are visible in compiled copies.
//
//   20140911.12   Minor lua cleanup.
//                 Fixed internal reference to 'JSON.noKeyConversion' to reference 'self' instead of 'JSON'.
//                 (Thanks to SmugMug's David Parry for these.)
//
//   20140418.11   JSON nulls embedded within an array were being ignored, such that
//                     ["1",null,null,null,null,null,"seven"],
//                 would return
//                     {1,"seven"}
//                 It's now fixed to properly return
//                     {1, nil, nil, nil, nil, nil, "seven"}
//                 Thanks to "haddock" for catching the error.
//
//   20140116.10   The user's JSON.assert() wasn't always being used. Thanks to "blue" for the heads up.
//
//   20131118.9    Update for Lua 5.3... it seems that tostring(2/1) produces "2.0" instead of "2",
//                 and this caused some problems.
//
//   20131031.8    Unified the code for encode() and encode_pretty(); they had been stupidly separate,
//                 and had of course diverged (encode_pretty didn't get the fixes that encode got, so
//                 sometimes produced incorrect results; thanks to Mattie for the heads up).
//
//                 Handle encoding tables with non-positive numeric keys (unlikely, but possible).
//
//                 If a table has both numeric and string keys, or its numeric keys are inappropriate
//                 (such as being non-positive or infinite), the numeric keys are turned into
//                 string keys appropriate for a JSON object. So, as before,
//                         JSON:encode({ "one", "two", "three" })
//                 produces the array
//                         ["one","two","three"]
//                 but now something with mixed key types like
//                         JSON:encode({ "one", "two", "three", SOMESTRING = "some string" }))
//                 instead of throwing an error produces an object:
//                         {"1":"one","2":"two","3":"three","SOMESTRING":"some string"}
//
//                 To maintain the prior throw-an-error semantics, set
//                      JSON.noKeyConversion = true
//                 
//   20131004.7    Release under a Creative Commons CC-BY license, which I should have done from day one, sorry.
//
//   20130120.6    Comment update: added a link to the specific page on my blog where this code can
//                 be found, so that folks who come across the code outside of my blog can find updates
//                 more easily.
//
//   20111207.5    Added support for the 'etc' arguments, for better error reporting.
//
//   20110731.4    More feedback from David Kolf on how to make the tests for Nan/Infinity system independent.
//
//   20110730.3    Incorporated feedback from David Kolf at http://lua-users.org/wiki/JsonModules:
//
//                   * When encoding lua for JSON, Sparse numeric arrays are now handled by
//                     spitting out full arrays, such that
//                        JSON:encode({"one", "two", [10] = "ten"})
//                     returns
//                        ["one","two",null,null,null,null,null,null,null,"ten"]
//
//                     In 20100810.2 and earlier, only up to the first non-null value would have been retained.
//
//                   * When encoding lua for JSON, numeric value NaN gets spit out as null, and infinity as "1+e9999".
//                     Version 20100810.2 and earlier created invalid JSON in both cases.
//
//                   * Unicode surrogate pairs are now detected when decoding JSON.
//
//   20100810.2    added some checking to ensure that an invalid Unicode character couldn't leak in to the UTF-8 encoding
//
//   20100731.1    initial public release
//
