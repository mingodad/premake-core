//
// Embed the Lua scripts into src/host/scripts.c as static data buffers.
// Embeds minified versions of the actual scripts by default, rather than
// bytecode, as bytecodes are not portable to different architectures. Use
// the `--bytecode` flag to override.
//

	var scriptCount = 0;

	var function loadScript(fname) {
		fname = path.getabsolute(fname);
		var f = io.open(fname, "rb");
		var s = assert(f->read("*all"));
		f->close();
		return s;
	}


	var function stripScript(s) {
		// strip tabs
		var result = s->gsub("[\t]", "");

		// strip any CRs
		result = result->gsub("[\r]", "");

		// strip out block comments
		result = result->gsub("[^\"']/%*.-%*/", "");

		// strip out inline comments
		result = result->gsub("\n//[^\n]*", "\n");

		// strip duplicate line feeds
		result = result->gsub("\n+", "\n");

		return result;
	}


	var function outputScript(result, script) {
		var data   = script.data;
		var length = #data;

		if( length > 0 ) {
			script.table = string.format("builtin_script_%d", scriptCount);
			++scriptCount    ;

			buffered.writeln(result, "// ".. script.name);
			buffered.writeln(result, "static const unsigned char " .. script.table .. "[] = {");

			for( i = 1, length ) {
				buffered.write(result, string.format("%3d, ", data->byte(i)));
				if( (i % 32 == 0) ) {
					buffered.writeln(result);
				}
			}

			buffered.writeln(result, "};");
			buffered.writeln(result);
		}
	}


	var function addScript(result, filename, name, data) {
		if( ! data ) {
			if( ! path.hasextension(filename, ".ljs") ) {
				data = loadScript(filename);
			} else if( _OPTIONS["bytecode"] ) {
				verbosef("Compiling... " .. filename);
				var output = path.replaceextension(filename, ".ljsc");
				var res, err = os.compile(filename, output);
				if( res != null ) {
					data = loadScript(output);
					os.remove(output);
				} else {
					print(err);
					print("Embedding source instead.");
					data = stripScript(loadScript(filename));
				}
			} else {
				data = stripScript(loadScript(filename));
			}
		}

		var script = {};
		script.filename = filename;
		script.name     = name;
		script.data     = data;
		table.insert(result, script);
	}


// Prepare the file header

	var result = buffered.new();
	buffered.writeln(result, "/* Premake's Lua scripts, as static data buffers for release mode builds */");
	buffered.writeln(result, "/* DO NOT EDIT - this file is autogenerated - see BUILD.txt */");
	buffered.writeln(result, "/* To regenerate this file, run: premake5 embed */");
	buffered.writeln(result, "");
	buffered.writeln(result, '#include "host/premake.h"');
	buffered.writeln(result, "");

// Find all of the _manifest.ljs files within the project

	var mask = path.join(_MAIN_SCRIPT_DIR, "**/_manifest.ljs");
	var manifests = os.matchfiles(mask);

// Find all of the _user_modules.ljs files within the project

	var userModuleFiles = {};
	userModuleFiles = table.join(userModuleFiles, os.matchfiles(path.join(_MAIN_SCRIPT_DIR, "**/_user_modules.ljs")));
	userModuleFiles = table.join(userModuleFiles, os.matchfiles(path.join(_MAIN_SCRIPT_DIR, "_user_modules.ljs")));


// Generate table of embedded content.
	var contentTable = {};
	var nativeTable = {};

	print("Compiling... ");
	for( mi = 1, #manifests ) {
		var manifestName = manifests[mi];
		var manifestDir  = path.getdirectory(manifestName);
		var moduleName   = path.getbasename(manifestDir);
		var baseDir      = path.getdirectory(manifestDir);

		var files = dofile(manifests[mi]);
		for( fi = 1, #files ) {
			var filename = path.join(manifestDir, files[fi]);
			addScript(contentTable, filename, path.getrelative(baseDir, filename));
		}

		// find native code in modules.
		if( moduleName != "src" ) {
			var nativeFile = path.join(manifestDir, 'native', moduleName .. '.c');
			if( os.isfile(nativeFile) ) {
				var pretty_name = moduleName->gsub("^%l", string.upper);
				table.insert(nativeTable, pretty_name);
			}
		}
	}

	addScript(contentTable, path.join(_SCRIPT_DIR, "../src/_premake_main.ljs"), "src/_premake_main.ljs");
	addScript(contentTable, path.join(_SCRIPT_DIR, "../src/_manifest.ljs"), "src/_manifest.ljs");

// Add the list of modules

	var modules = dofile("../src/_modules.ljs");
	for( _, userModules in ipairs(userModuleFiles) ) {
		modules = table.join(modules, dofile(userModules));
	}

	addScript(contentTable, "_modules.ljs", "src/_modules.ljs", "return {" .. table.implode(modules, '"', '"', ', ') .. "}");

// Embed the actual script contents

	print("Embedding...");
	for( mi = 1, #contentTable ) {
		outputScript(result, contentTable[mi]);
	}

// Generate an index of the script file names. Script names are stored
// relative to the directory containing the manifest, i.e. the main
// Xcode script, which is at $/modules/xcode/xcode.ljs is stored as
// "xcode/xcode.ljs".
	buffered.writeln(result, "const buildin_mapping builtin_scripts[] = {");

	for( mi = 1, #contentTable ) {
		if( contentTable[mi].table ) {
			buffered.writeln(result, string.format('\t{"%s", %s, sizeof(%s)},', contentTable[mi].name, contentTable[mi].table, contentTable[mi].table));
		} else {
			buffered.writeln(result, string.format('\t{"%s", NULL, 0},', contentTable[mi].name));
		}
	}

	buffered.writeln(result, "\t{NULL, NULL, 0}");
	buffered.writeln(result, "};");
	buffered.writeln(result, "");

// write out the registerModules method.

	for( _, name in ipairs(nativeTable) ) {
		buffered.writeln(result, string.format("extern void register%s(lua_State* L);", name));
	}
	buffered.writeln(result, "");
	buffered.writeln(result, "void registerModules(lua_State* L)");
	buffered.writeln(result, "{");
	buffered.writeln(result, "\t(void)(L);");
	for( _, name in ipairs(nativeTable) ) {
		buffered.writeln(result, string.format("\tregister%s(L);", name));
	}
	buffered.writeln(result, "}");
	buffered.writeln(result, "");

// Write it all out. Check against the current contents of scripts.c first,
// and only overwrite it if there are actual changes.

	print("Writing...");
	var scriptsFile = path.getabsolute(path.join(_SCRIPT_DIR, "../src/scripts.c"));
	var output = buffered.tostring(result);

	var f, err = os.writefile_ifnotequal(output, scriptsFile);
	if( (f < 0) ) {
		error(err, 0);
	} else if( (f > 0) ) {
		printf("Generated %s...", path.getrelative(os.getcwd(), scriptsFile));
	}
