//
// tests/config/test_links.ljs
// Test the list of linked objects retrieval function.
// Copyright (c) 2012-2013 Jason Perkins and the Premake project
//

	var p = premake;
	var suite = test.declare("config_links");
	var config = p.config;


//
// Setup and teardown
//

	var wks, prj;

	function suite.setup() {
		p.action.set("test");
		_TARGET_OS = "windows";
		wks, prj = test.createWorkspace();
	}

	var function prepare(kind, part, linkage) {
		cfg = test.getconfig(prj, "Debug");
		return config.getlinks(cfg, kind, part, linkage);
	}


//
// If no links are present, should return an empty table.
//

	function suite.emptyResult_onNoLinks() {
		var r = prepare("all", "object");
		test.isequal(0, #r);
	}


//
// System libraries which include path information are made project relative.
//

	function suite.pathMadeRelative_onSystemLibWithPath() {
		location ("build");
		links ({ "../libs/z" });
		var r = prepare("all", "fullpath");
		test.isequal({ "../../libs/z" }, r);
	}



//
// Handle the case where the library extension has been explicitly
// included in the link statement.
//

	function suite.skipsExtension_onExplicitExtension() {
		system ("windows");
		links ({ "user32.lib" });
		var r = prepare("all", "fullpath");
		test.isequal({ "user32.lib" }, r);
	}


//
// Check handling of shell variables in library paths.
//

	function suite.variableMaintained_onLeadingVariable() {
		system ("windows");
		location ("build");
		links ({ "$(LOCAL_DEV_PATH)/sdk/lib/DEVMAPI" });
		var r = prepare("all", "fullpath");
		test.isequal({ "$(LOCAL_DEV_PATH)/sdk/lib/DEVMAPI" }, r);
	}

	function suite.variableMaintained_onQuotedVariable() {
		system ("windows");
		location ("build");
		links ({ '"$(LOCAL_DEV_PATH)/sdk/lib/DEVMAPI.lib"' });
		var r = prepare("all", "fullpath");
		test.isequal({ '"$(LOCAL_DEV_PATH)/sdk/lib/DEVMAPI.lib"' }, r);
	}


//
// If fetching directories, the libdirs should be included in the result.
//

	function suite.includesLibDirs_onDirectories() {
		libdirs ({ "../libs" });
		var r = prepare("all", "directory");
		test.isequal({ "../libs" }, r);
	}


//
// Managed C++ projects should ignore links to managed assemblies, which
// are designated with an explicit ".dll" extension.
//

	function suite.skipsAssemblies_onManagedCpp() {
		system ("windows");
		clr ("On");
		links ({ "user32", "System.dll" });
		var r = prepare("all", "fullpath");
		test.isequal({ "user32" }, r);
	}


//
// When explicitly requesting managed links, any unmanaged items in the
// list should be ignored.
//

	function suite.skipsUnmanagedLibs_onManagedLinkage() {
		system ("windows");
		clr ("On");
		links ({ "user32", "System.dll" });
		var r = prepare("all", "fullpath", "managed");
		test.isequal({ "System.dll" }, r);
	}


//
// Managed projects can link to other managed projects, and unmanaged
// projects can link to unmanaged projects.
//

	function suite.canLink_CppAndCpp() {
		links ({ "MyProject2" });

		project ("MyProject2");
		kind ("StaticLib");
		language ("C++");

		var r = prepare("all", "fullpath");
		test.isequal({ "bin/Debug/MyProject2.lib" }, r);
	}

	function suite.canLink_CsAndCs() {
		language ("C#");
		links ({ "MyProject2" });

		project ("MyProject2");
		kind ("SharedLib");
		language ("C#");

		var r = prepare("all", "fullpath");
		test.isequal({ "bin/Debug/MyProject2.dll" }, r);
	}

	function suite.canLink_ManagedCppAndManagedCpp() {
		clr ("On");
		links ({ "MyProject2" });

		project ("MyProject2");
		kind ("StaticLib");
		language ("C++");
		clr ("On");

		var r = prepare("all", "fullpath");
		test.isequal({ "bin/Debug/MyProject2.lib" }, r);
	}

	function suite.canLink_ManagedCppAndCs() {
		clr ("On");
		links ({ "MyProject2" });

		project ("MyProject2");
		kind ("SharedLib");
		language ("C#");

		var r = prepare("all", "fullpath");
		test.isequal({ "bin/Debug/MyProject2.dll" }, r);
	}


//
// Managed and unmanaged projects can not link to each other.
//


	function suite.ignoreLink_CppAndCs() {
		links ({ "MyProject2" });

		project ("MyProject2");
		kind ("SharedLib");
		language ("C#");

		var r = prepare("all", "fullpath");
		test.isequal({}, r);
	}
