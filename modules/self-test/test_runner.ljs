//-
// self-test/test_runner.ljs
//
// Execute unit tests and test suites.
//
// Author Jason Perkins
// Copyright (c) 2008-2016 Jason Perkins and the Premake project.
//-

	var p = premake;

	var m = p.modules.self_test;

	var _ = {};



	function m.runTest(test) {
		var failed = 0;
		var failedTests = {};

		var suites = m.getSuites();
		var suitesKeys, suiteTestsKeys, totalTestCount = _.preprocessTests(suites, test);

		_.log(term.lightGreen, "[==========]", string.format(" Running %d tests from %d test suites.", totalTestCount, #suitesKeys));
		var startTime = os.clock();

		for( index, suiteName in ipairs(suitesKeys) ) {
		  suite = suites[suiteName];
			if( ! m.isSuppressed(suiteName) ) {
				var xtest = {
					suiteName = suiteName,
					suite = suite
				};

				var suiteFailed, suiteFailedTests = _.runTestSuite(xtest, suiteTestsKeys[suiteName]);

				failed +=   suiteFailed;
				failedTests = table.join(failedTests, suiteFailedTests);
			}
		}

		_.log(term.lightGreen, "[==========]", string.format(" %d tests from %d test suites ran. (%.0f ms total)", totalTestCount, #suitesKeys, (os.clock() - startTime) * 1000));
		_.log(term.lightGreen, "[  PASSED  ]", string.format(" %d tests.", totalTestCount - failed));
		if( failed > 0 ) {
			_.log(term.lightRed, "[  FAILED  ]", string.format(" %d tests, listed below:", failed));
			for( index, testName in ipairs(failedTests) ) {
				_.log(term.lightRed, "[  FAILED  ]", " " .. testName);
			}
		}

		return (totalTestCount - failed), failed;
	}



	function _.runTestSuite(test, keys) {
		var failed = 0;
		var failedTests = {};
		_.log(term.lightGreen, "[----------]", string.format(" %d tests from %s", #keys, test.suiteName));
		var startTime = os.clock();

		if( test.suite != null ) {
			for( index, testName in ipairs(keys) ) {
				testFunction = test.suite[testName];
				test.testName = testName;
				test.testFunction = testFunction;

				if( m.isValid(test) && ! m.isSuppressed(test.suiteName .. "." .. test.testName) ) {
					var err = _.runTest(test);
					if( err ) {
						++failed    ;
						table.insert(failedTests, test.suiteName .. "." .. test.testName .. "\n" .. err);
					}
				}
			}
		}

		_.log(term.lightGreen, "[----------]", string.format(" %d tests from %s (%.0f ms total)\n", #keys, test.suiteName, (os.clock() - startTime) * 1000));
		return failed, failedTests;
	}



	function _.runTest(test) {
		_.log(term.lightGreen, "[ RUN      ]", string.format(" %s.%s", test.suiteName, test.testName));
		var startTime = os.clock();
		var cwd = os.getcwd();
		var hooks = _.installTestingHooks();

		_TESTS_DIR = test.suite._TESTS_DIR;
		_SCRIPT_DIR = test.suite._SCRIPT_DIR;

		m.suiteName = test.suiteName;
		m.testName = test.testName;

		var ok, err = _.setupTest(test);

		if( ok ) {
			ok, err = _.executeTest(test);
		}

		var tok, terr = _.teardownTest(test);
		ok = ok && tok;
		err = err || terr;

		_.removeTestingHooks(hooks);
		os.chdir(cwd);

		if( ok ) {
			_.log(term.lightGreen, "[       OK ]", string.format(" %s.%s (%.0f ms)", test.suiteName, test.testName, (os.clock() - startTime) * 1000));
			return null;
		} else {
			_.log(term.lightRed, "[  FAILED  ]", string.format(" %s.%s (%.0f ms)", test.suiteName, test.testName, (os.clock() - startTime) * 1000));
			m.print(string.format("%s", err));
			return err;
		}
	}



	function _.log(color, left, right) {
		term.pushColor(color);
		io.write(left);
		term.popColor();
		m.print(right);
	}



	function _.preprocessTests(suites, filter) {
		var suitesKeys = {};
		var suiteTestsKeys = {};
		var totalTestCount = 0;

		for( suiteName, suite in pairs(suites) ) {
			if( ! m.isSuppressed(suiteName) && suite != null && (! filter.suiteName || filter.suiteName == suiteName) ) {
				var test = {};

				table.insertsorted(suitesKeys, suiteName);

				test.suiteName = suiteName;
				test.suite = suite;

				suiteTestsKeys[suiteName] = {};
				for( testName, testFunction in pairs(suite) ) {
					test.testName = testName;
					test.testFunction = testFunction;

					if( m.isValid(test) && ! m.isSuppressed(test.suiteName .. "." .. test.testName) && (! filter.testName || filter.testName == testName) ) {
						table.insertsorted(suiteTestsKeys[suiteName], testName);
					}
				}
				totalTestCount = totalTestCount + #suiteTestsKeys[suiteName];
			}
		}

		return suitesKeys, suiteTestsKeys, totalTestCount;
	}



	function _.installTestingHooks() {
		var hooks = {};

		hooks.action = _ACTION;
		hooks.options = _OPTIONS;
		hooks.targetOs = _TARGET_OS;

		hooks.io_open = io.open;
		hooks.io_output = io.output;
		hooks.os_writefile_ifnotequal = os.writefile_ifnotequal;
		hooks.p_utf8 = p.utf8;
		hooks.print = print;
		hooks.setTextColor = term.setTextColor;

		var mt = getmetatable(io.stderr);
		_.builtin_write = mt.write;
		mt.write = _.stub_stderr_write;

		_OPTIONS = table.shallowcopy(_OPTIONS) || {};
		setmetatable(_OPTIONS, getmetatable(hooks.options));

		io.open = _.stub_io_open;
		io.output = _.stub_io_output;
		os.writefile_ifnotequal = _.stub_os_writefile_ifnotequal;
		print = _.stub_print;
		p.utf8 = _.stub_utf8;
		term.setTextColor = _.stub_setTextColor;

		stderr_capture = null;

		p.clearWarnings();
		p.eol("\n");
		p.escaper(null);
		p.indent("\t");
		p.api.reset();

		m.stderr_capture = null;
		m.value_openedfilename = null;
		m.value_openedfilemode = null;
		m.value_closedfile = false;

		return hooks;
	}




	function _.removeTestingHooks(hooks) {
		p.action.set(hooks.action);
		_OPTIONS = hooks.options;
		_TARGET_OS = hooks.targetOs;

		io.open = hooks.io_open;
		io.output = hooks.io_output;
		os.writefile_ifnotequal = hooks.os_writefile_ifnotequal;
		p.utf8 = hooks.p_utf8;
		print = hooks.print;
		term.setTextColor = hooks.setTextColor;

		var mt = getmetatable(io.stderr);
		mt.write = _.builtin_write;
	}



	function _.setupTest(test) {
		if( type(test.suite.setup) == "function" ) {
			return xpcall(test.suite.setup, _.errorHandler);
		} else {
			return true;
		}
	}



	function _.executeTest(test) {
		var result, err;
		p.capture(function() {
			result, err = xpcall(test.testFunction, _.errorHandler);
		});
		return result, err;
	}



	function _.teardownTest(test) {
		if( type(test.suite.teardown) == "function" ) {
			return xpcall(test.suite.teardown, _.errorHandler);
		} else {
			return true;
		}
	}



	function _.errorHandler(err) {
		var msg = err;

		// if the error doesn't include a stack trace, add one
		if( ! msg->find("stack traceback:", 1, true) ) {
			msg = debug.traceback(err, 2);
		}

		// trim of the trailing context of the originating xpcall
		var i = msg->find("[C]: in function 'xpcall'", 1, true);
		if( i ) {
			msg = msg->sub(1, i - 3);
		}

		// if the resulting stack trace is only one level deep, ignore it
		var n = select(2, msg->gsub('\n', '\n'));
		if( n == 2 ) {
			msg = msg->sub(1, msg->find('\n', 1, true) - 1);
		}

		return msg;
	}



	function _.stub_io_open(fname, mode) {
		m.value_openedfilename = fname;
		m.value_openedfilemode = mode;
		return {
			read = function() {
			},
			close = function() {
				m.value_closedfile = true;
			}
		};
	}



	function _.stub_io_output(f) {
	}



	function _.stub_os_writefile_ifnotequal(content, fname) {
		m.value_openedfilename = fname;
		m.value_closedfile = true;
		return 0;
	}



	function _.stub_print(s) {
	}




	function _.stub_stderr_write(...) {
		if( select(1, ...) == io.stderr ) {
			m.stderr_capture = (m.stderr_capture || "") .. select(2, ...);
		} else {
			return _.builtin_write(...);
		}
	}



	function _.stub_utf8() {
	}


	function _.stub_setTextColor() {
	}
