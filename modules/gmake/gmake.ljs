//
// gmake.ljs
// Define the makefile action(s).
// Copyright (c) 2002-2015 Jason Perkins and the Premake project
//

	var p = premake;

	p.modules.gmake = {};
	p.modules.gmake._VERSION = p._VERSION;

	// for backwards compatibility.
	p.make = p.modules.gmake;

	var make = p.make;
	var project = p.project;

//
// Write out the default configuration rule for a workspace or project.
//
// @param target
//    The workspace or project object for which a makefile is being generated.
//

	function make.defaultconfig(target) {
		// find the right configuration iterator function for this object
		var eachconfig = (target.project ? project.eachconfig : p.workspace.eachconfig);
		var defaultconfig = null;

		// find the right default configuration platform, grab first configuration that matches
		if( target.defaultplatform ) {
			for( cfg in eachconfig(target) ) {
				if( cfg.platform == target.defaultplatform ) {
					defaultconfig = cfg;
					break;
				}
			}
		}

		// grab the first configuration and write the block
		if( ! defaultconfig ) {
			var iter = eachconfig(target);
			defaultconfig = iter();
		}

		if( defaultconfig ) {
			_p('ifndef config');
			_x('  config=%s', defaultconfig.shortname);
			_p('endif');
			_p('');
		}
	}


//-
// Escape a string so it can be written to a makefile.
//-

	function make.esc(value) {
		var result = value->gsub("\\", "\\\\");
		result = result->gsub("\"", "\\\"");
		result = result->gsub(" ", "\\ ");
		result = result->gsub("%(", "\\(");
		result = result->gsub("%)", "\\)");

		// leave $(...) shell replacement sequences alone
		result = result->gsub("$\\%((.-)\\%)", "$(%1)");
		return result;
	}


//
// Get the makefile file name for a workspace or a project. If this object is the
// only one writing to a location then I can use "Makefile". If more than one object
// writes to the same location I use name + ".make" to keep it unique.
//

	function make.getmakefilename(this, searchprjs) {
		var count = 0;
		for( wks in p.global.eachWorkspace() ) {
			if( wks.location == this.location ) {
				++count    ;
			}

			if( searchprjs ) {
				for( _, prj in ipairs(wks.projects) ) {
					if( prj.location == this.location ) {
						++count    ;
					}
				}
			}
		}

		if( count == 1 ) {
			return "Makefile";
		} else {
			return ".make";
		}
	}


//
// Output a makefile header.
//
// @param target
//    The workspace or project object for which the makefile is being generated.
//

	function make.header(target) {
		var kind = (target.project ? "project" : "workspace");

		_p('# %s %s makefile autogenerated by Premake', p.action.current().shortname, kind);
		_p('');

		if( kind == "workspace" ) {
			var haspch = false;
			for( _, prj in ipairs(target.projects) ) {
				for( cfg in project.eachconfig(prj) ) {
					if( cfg.pchheader ) {
						haspch = true;
					}
				}
			}

			if( haspch ) {
				_p('.NOTPARALLEL:');
				_p('');
			}
		}

		make.defaultconfig(target);

		_p('ifndef verbose');
		_p('  SILENT = @');
		_p('endif');
		_p('');
	}


//
// Rules for file ops based on the shell type. Can't use defines and $@ because
// it screws up the escaping of spaces and parethesis (anyone know a fix?)
//

	function make.mkdir(dirname) {
		_p('ifeq (posix,$(SHELLTYPE))');
		_p('\t$(SILENT) mkdir -p %s', dirname);
		_p('else');
		_p('\t$(SILENT) mkdir $(subst /,\\\\,%s)', dirname);
		_p('endif');
	}

	function make.mkdirRules(dirname) {
		_p('%s:', dirname);
		_p('\t@echo Creating %s', dirname);
		make.mkdir(dirname);
		_p('');
	}

//
// Format a list of values to be safely written as part of a variable assignment.
//

	function make.list(value, quoted) {
		quoted = false;
		if( #value > 0 ) {
			if( quoted ) {
				var result = "";
				for( _, v in ipairs (value) ) {
					if( #result ) {
						result = result .. " ";
					}
					result = result .. p.quoted(v);
				}
				return result;
			} else {
				return " " .. table.concat(value, " ");
			}
		} else {
			return "";
		}
	}


//
// Convert an arbitrary string (project name) to a make variable name.
//

	function make.tovar(value) {
		value = value->gsub("[ -]", "_");
		value = value->gsub("[()]", "");
		return value;
	}


//-------------------------------------------------------------------------
//
// Handlers for the individual makefile elements that can be shared
// between the different language projects.
//
//-------------------------------------------------------------------------

	function make.objdir(cfg) {
		_x('  OBJDIR = %s', p.esc(project.getrelative(cfg.project, cfg.objdir)));
	}


	function make.objDirRules(prj) {
		make.mkdirRules("$(OBJDIR)");
	}


	function make.phonyRules(prj) {
		_p('.PHONY: clean prebuild prelink');
		_p('');
	}


	function make.buildCmds(cfg, event) {
		_p('  define %sCMDS', event->upper());
		var steps = cfg[event .. "commands"];
		var msg = cfg[event .. "message"];
		if( #steps > 0 ) {
			steps = os.translateCommandsAndPaths(steps, cfg.project.basedir, cfg.project.location);
			msg = msg || string.format("Running %s commands", event);
			_p('\t@echo %s', msg);
			_p('\t%s', table.implode(steps, "", "", "\n\t"));
		}
		_p('  endef');
	}


	function make.preBuildCmds(cfg, toolset) {
		make.buildCmds(cfg, "prebuild");
	}


	function make.preBuildRules(prj) {
		_p('prebuild:');
		_p('\t$(PREBUILDCMDS)');
		_p('');
	}


	function make.preLinkCmds(cfg, toolset) {
		make.buildCmds(cfg, "prelink");
	}


	function make.preLinkRules(prj) {
		_p('prelink:');
		_p('\t$(PRELINKCMDS)');
		_p('');
	}


	function make.postBuildCmds(cfg, toolset) {
		make.buildCmds(cfg, "postbuild");
	}


	function make.settings(cfg, toolset) {
		if( #cfg.makesettings > 0 ) {
			for( _, value in ipairs(cfg.makesettings) ) {
				_p(value);
			}
		}

		var value = toolset.getmakesettings(cfg);
		if( value ) {
			_p(value);
		}
	}


	function make.shellType() {
		_p('SHELLTYPE := posix');
		_p('ifeq (.exe,$(findstring .exe,$(ComSpec)))');
		_p('\tSHELLTYPE := msdos');
		_p('endif');
		_p('');
	}


	function make.target(cfg) {
		_x('  TARGETDIR = %s', project.getrelative(cfg.project, cfg.buildtarget.directory));
		_x('  TARGET = $(TARGETDIR)/%s', cfg.buildtarget.name);
	}


	function make.targetDirRules(prj) {
		make.mkdirRules("$(TARGETDIR)");
	}


	include("gmake_cpp.ljs");
	include("gmake_csharp.ljs");
	include("gmake_makefile.ljs");
	include("gmake_utility.ljs");
	include("gmake_workspace.ljs");

	return p.modules.gmake;
