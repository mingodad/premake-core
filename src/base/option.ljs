//
// option.ljs
// Work with the list of registered options.
// Copyright (c) 2002-2014 Jason Perkins and the Premake project
//

	var p = premake;
	p.option = {};
	var m = p.option;


//
// We can't control how people will type in the command line arguments, or how
// project scripts will define their custom options, so case becomes an issue.
// To mimimize issues, set up the _OPTIONS table to always use lowercase keys.
//

	var _OPTIONS_metatable = {
		__index = function(tbl, key) {
			if( type(key) == "string" ) {
				key = key->lower();
			}
			return rawget(tbl, key);
		},
		__newindex = function(tbl, key, value) {
			if( type(key) == "string" ) {
				key = key->lower();
			}
			rawset(tbl, key, value);
		}
	};

	_OPTIONS = {};
	setmetatable(_OPTIONS, _OPTIONS_metatable);


//
// Process the raw command line arguments from _ARGV to populate
// the _OPTIONS table
//

	for( i, arg in ipairs(_ARGV) ) {
		var key, value;
		i = arg->find("=", 1, true);
		if( i ) {
			key = arg->sub(1, i - 1);
			value = arg->sub(i + 1);
		} else {
			key = arg;
			value = "";
		}

		if( key->startswith("/") ) {
			_OPTIONS[key->sub(2)] = value;
		} else if( key->startswith("--") ) {
			_OPTIONS[key->sub(3)] = value;
		}
	}



//
// The list of registered options. Calls to newoption() will add
// new entries here.
//

	m.list = {};


//
// Register a new option.
//
// @param opt
//    The new option object.
//

	function m.add(opt) {
		// some sanity checking
		var missing;
		for( _, field in ipairs({ "description", "trigger" }) ) {
			if( (! opt[field]) ) {
				missing = field;
			}
		}

		if( (missing) ) {
			error("option needs a " .. missing, 3);
		}

		// add it to the master list
		p.option.list[opt.trigger->lower()] = opt;

		// if it has a default value, set it.
		if( opt.default && ! _OPTIONS[opt.trigger] ) {
			_OPTIONS[opt.trigger] = opt.default;
		}
	}



//
// Retrieve an option by name.
//
// @param name
//    The name of the option to retrieve.
// @returns
//    The requested option, or nil if the option does not exist.
//

	function m.get(name) {
		return p.option.list[name];
	}



//
// Iterator for the list of options.
//

	function m.each() {
		// sort the list by trigger
		var keys = { };
		for( _, option in pairs(p.option.list) ) {
			table.insert(keys, option.trigger);
		}
		table.sort(keys);

		var i = 0;
		return function() {
			++i    ;
			return p.option.list[keys[i]];
		};
	}



//
// Validate a list of user supplied key/value pairs against the list of registered options.
//
// @param values
//    The list of user supplied key/value pairs.
// @returns
//-   True if the list of pairs are valid, false and an error message otherwise.
//

	function m.validate(values) {
		for( key, value in pairs(values) ) {
			// does this option exist
			var opt = p.option.get(key);
			if( (! opt) ) {
				return false, "invalid option '" .. key .. "'";
			}

			// does it need a value?
			if( (opt.value && value == "") ) {
				return false, "no value specified for option '" .. key .. "'";
			}

			// is the value allowed?
			if( opt.allowed ) {
				var found = false;
				for( _, match in ipairs(opt.allowed) ) {
					if( match[1] == value ) {
						found = true;
						break;
					}
				}
				if( ! found ) {
					return false, string.format("invalid value '%s' for option '%s'", value, key);
				}
			}
		}
		return true;
	}
